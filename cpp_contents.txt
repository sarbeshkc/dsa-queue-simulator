
================================================================================
File: include\core\Constants.h
================================================================================

// Constants.h
#pragma once
#include <cstdint>

enum class LaneId {
    AL1_INCOMING,
    AL2_PRIORITY,
    AL3_FREELANE,
    BL1_INCOMING,
    BL2_NORMAL,
    BL3_FREELANE,
    CL1_INCOMING,
    CL2_NORMAL,
    CL3_FREELANE,
    DL1_INCOMING,
    DL2_NORMAL,
    DL3_FREELANE
};

enum class Direction {
    STRAIGHT,
    LEFT,
    RIGHT
};

enum class LightState {
    RED,
    GREEN
};

namespace SimConstants {
    // Window and Display
    static constexpr int WINDOW_WIDTH = 1280;
    static constexpr int WINDOW_HEIGHT = 960;
    static constexpr int CENTER_X = WINDOW_WIDTH / 2;
    static constexpr int CENTER_Y = WINDOW_HEIGHT / 2;

    // Road and Lane Configuration
    static constexpr int ROAD_WIDTH = 360;     // Width for 3 lanes
    static constexpr int LANE_WIDTH = 120;     // Individual lane width
    static constexpr float QUEUE_SPACING = 60.0f;
    static constexpr float QUEUE_START_OFFSET = 200.0f;

    // Vehicle Configuration
    static constexpr float VEHICLE_WIDTH = 40.0f;
    static constexpr float VEHICLE_HEIGHT = 30.0f;
    static constexpr float VEHICLE_BASE_SPEED = 50.0f;
    static constexpr float VEHICLE_TURN_SPEED = 30.0f;

    // Traffic Light Configuration
    static constexpr float LIGHT_SIZE = 40.0f;
    static constexpr float LIGHT_SPACING = 60.0f;

    // Intersection Configuration
    static constexpr float INTERSECTION_RADIUS = 180.0f;
    static constexpr float TURN_GUIDE_RADIUS = 150.0f;

    // System Timing
    static constexpr int FILE_CHECK_INTERVAL = 100;    // ms
    static constexpr int TRAFFIC_UPDATE_INTERVAL = 50; // ms
    static constexpr float VEHICLE_PROCESS_TIME = 3.0f; // seconds

// Add these constants to the class
static constexpr float UPDATE_INTERVAL = 0.016f;         // ~60 FPS
};


================================================================================
File: include\core\Lane.h
================================================================================

// Lane.h
#pragma once
#include "Vehicle.h"
#include "utils/Queue.h"
#include <memory>
#include <string>

class Lane {
private:
    LaneId id;
    Queue<std::shared_ptr<Vehicle>> vehicleQueue;
    bool isPriority;
    std::string dataFile;

public:
    Lane(LaneId id, bool isPriority);

    void addVehicle(std::shared_ptr<Vehicle> vehicle);
    std::shared_ptr<Vehicle> removeVehicle();
    Direction getVehicleDirection(size_t index) const;  // Add this method
    size_t getQueueSize() const;
    bool isPriorityLane() const;
    LaneId getId() const;
    const std::string& getDataFile() const;
    void update();
};


================================================================================
File: include\core\TrafficLight.h
================================================================================

// TrafficLight.h
#pragma once
#include <SDL3/SDL.h>
#include "Constants.h"
#include <cstdint>

class TrafficLight {
private:
    LightState state;
    LightState nextState;
    float transitionProgress;
    float transitionDuration;
    float stateTimer;
    bool isTransitioning;

public:
    TrafficLight();  // Just declare the constructor here
    void update(float deltaTime);
    void setState(LightState newState);
    LightState getState() const;
    void render(SDL_Renderer* renderer, float x, float y) const;
};


================================================================================
File: include\core\Vehicle.h
================================================================================

// include/core/Vehicle.hpp
#pragma once
#include "Constants.h"
#include <cstdint>

class Vehicle {
private:
    uint32_t id;
    Direction direction;
    LaneId currentLane;

public:
    Vehicle(uint32_t id, Direction dir, LaneId lane);
    uint32_t getId() const;
    Direction getDirection() const;
    LaneId getCurrentLane() const;
};


================================================================================
File: include\managers\FileHandler.h
================================================================================

// include/managers/FileHandler.hpp
#pragma once
#include "core/Vehicle.h"
#include <memory>
#include <vector>
#include <string>
#include <map>
#include <filesystem>
#include <fstream>
#include <iostream>

class FileHandler {
private:



    static constexpr int WINDOW_WIDTH = 1024;
    static constexpr int WINDOW_HEIGHT = 768;
    static constexpr int ROAD_WIDTH = 270;     // Width for 3 lanes (90 * 3)
    static constexpr int LANE_WIDTH = 90;      // Individual lane width
    static constexpr int CENTER_X = WINDOW_WIDTH / 2;
    static constexpr int CENTER_Y = WINDOW_HEIGHT / 2;
    static constexpr float QUEUE_SPACING = 40.0f;
    static constexpr float QUEUE_START_OFFSET = 250.0f;



    static const std::string BASE_PATH;


void ensureDataDirectoryExists() {
    const auto dataPath = std::filesystem::current_path() / "data" / "lanes";
    std::filesystem::create_directories(dataPath);
    std::cout << "Data directory ensured at: " << dataPath << std::endl;
}

// Add this to FileHandler class header
void debugPrintFileContents(const std::filesystem::path& filepath) {
    std::ifstream file(filepath);
    if (!file) {
        std::cerr << "Could not open file for debug: " << filepath << std::endl;
        return;
    }

    std::string line;
    while (std::getline(file, line)) {
        std::cout << "File content: " << line << std::endl;
    }
}
    std::map<LaneId, std::filesystem::path> laneFiles;
    std::map<std::filesystem::path, int64_t> lastReadPositions;
    std::filesystem::path dataDir;

public:
    FileHandler();  // Declaration only, definition will be in cpp file

    std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> readNewVehicles();
    void clearLaneFiles();

private:
    std::vector<std::shared_ptr<Vehicle>> parseVehicleData(const std::string& data, LaneId laneId);
};


================================================================================
File: include\managers\IntersectionController.h
================================================================================

// IntersectionController.h
#pragma once

#include "core/Lane.h"
#include "core/Vehicle.h"
#include "utils/PriorityQueue.h"
#include <vector>
#include <memory>
#include <cmath>

class IntersectionController {
public:
    // Public types for status reporting
    struct LaneStatus {
        LaneId id;
        size_t queueSize;
        int priority;
        bool isActive;
        float waitTime;
    };

    struct ProcessingStats {
        float avgWaitTime;
        size_t totalVehiclesProcessed;
        size_t currentQueueSizes[12]; // One for each lane
        bool isPriorityMode;
    };

    // Constructor
    explicit IntersectionController(std::vector<std::unique_ptr<Lane>>& lanes);

    // Core update method
    void update(float deltaTime);

    // State query methods
    bool isInPriorityMode() const { return isPriorityMode; }
    std::vector<LaneStatus> getLaneStatuses() const;
    ProcessingStats getStats() const;

private:
    // Core components
    std::vector<std::unique_ptr<Lane>>& lanes;
    PriorityQueue<LaneId> laneQueue;

    // State tracking
    bool isPriorityMode;
    float stateTimer;
    float elapsedTime;
    float processingTimer;
    size_t vehiclesProcessedInState;
    size_t totalVehiclesProcessed;

    // Configuration constants
    static constexpr size_t PRIORITY_THRESHOLD = 10;
    static constexpr size_t PRIORITY_RELEASE_THRESHOLD = 5;
    static constexpr float BASE_VEHICLE_PROCESS_TIME = 2.0f;
    static constexpr float MIN_STATE_TIME = 5.0f;
    static constexpr float MAX_STATE_TIME = 30.0f;
    static constexpr float MAX_WAIT_TIME = 45.0f;

    // Queue management methods
    void updateLaneQueue();
    void processPriorityLane();
    void processNormalLanes();
    void processFreeLanes();
    size_t calculateVehiclesToProcess() const;

    // State management methods
    void handleStateTransition();
    void checkWaitTimes();
    void updateTimers(float deltaTime);

    // Utility methods
    float calculateAverageWaitingVehicles() const;
    float calculateProcessingTime() const;
    bool shouldSwitchToNormalMode() const;
    bool shouldSwitchToPriorityMode() const;
    void resetStateTimers();
    Lane* getPriorityLane() const;
    bool isFreeLane(LaneId id) const;
    int calculateLanePriority(const Lane& lane) const;
};


================================================================================
File: include\managers\TrafficManager.h
================================================================================

// TrafficManager.h
#pragma once
#include <vector>
#include <memory>
#include <map>
#include "core/Constants.h"
#include "core/Lane.h"
#include "core/TrafficLight.h"
#include "core/Vehicle.h"

struct VehicleState {
    std::shared_ptr<Vehicle> vehicle;
    float x, y;             // Current position
    float targetX, targetY; // Target position
    float speed;            // Movement speed
    bool isMoving;
    Direction direction;
    bool hasStartedTurn;
    float turnProgress;
    float waitTime;
    float turnAngle;        // Current turning angle
    float targetAngle;      // Final angle after turn
};

class TrafficManager {
private:
    std::vector<std::unique_ptr<Lane>> lanes;
    std::map<LaneId, TrafficLight> trafficLights;
    std::map<uint32_t, VehicleState> activeVehicles;
    bool inPriorityMode;
    float stateTimer;
    float lastUpdateTime;

    // Vehicle processing methods
    void updateVehiclePositions(float deltaTime);
    void updateVehicleQueuePosition(VehicleState& state, LaneId laneId, size_t queuePosition);
    void calculateTargetPosition(VehicleState& state, LaneId laneId);
    bool checkCollision(const VehicleState& state, float newX, float newY) const;
    float calculateTurningRadius(Direction dir) const;

    // Traffic control methods
    void updateTrafficLights(float deltaTime);
    void synchronizeTrafficLights();
    bool checkPriorityConditions() const;
    void processPriorityLane();
    void processNormalLanes(size_t vehicleCount);
    size_t calculateVehiclesToProcess() const;

public:
    TrafficManager();
    void update(float deltaTime);
    void addVehicleToLane(LaneId laneId, std::shared_ptr<Vehicle> vehicle);
    void addNewVehicleToState(std::shared_ptr<Vehicle> vehicle, LaneId laneId);
    size_t getLaneSize(LaneId laneId) const;

    // Getters for rendering
    bool isInPriorityMode() const { return inPriorityMode; }
    const std::vector<std::unique_ptr<Lane>>& getLanes() const { return lanes; }
    const std::map<LaneId, TrafficLight>& getTrafficLights() const { return trafficLights; }
    const std::map<uint32_t, VehicleState>& getActiveVehicles() const { return activeVehicles; }
};


================================================================================
File: include\utils\PriorityQueue.h
================================================================================

// include/utils/PriorityQueue.hpp
#pragma once
#include "Queue.h"

template <typename T> class PriorityQueue : public Queue<T> {
  struct PriorityNode : public Queue<T>::Node {
    int priority;
    PriorityNode(const T &value, int p) : Queue<T>::Node(value), priority(p) {}
  };

public:
  void enqueuePriority(const T &value, int priority) {
    auto newNode = std::make_shared<PriorityNode>(value, priority);

    if (this->isEmpty() ||
        static_cast<PriorityNode *>(this->front.get())->priority < priority) {
      newNode->next = this->front;
      this->front = newNode;
    } else {
      auto current = this->front;
      while (current->next &&
             static_cast<PriorityNode *>(current->next.get())->priority >=
                 priority) {
        current = current->next;
      }
      newNode->next = current->next;
      current->next = newNode;
    }
    this->size++;
  }
};


================================================================================
File: include\utils\Queue.h
================================================================================

// include/utils/Queue.h
#pragma once
#include <memory>
#include <stdexcept>

template<typename T>
class Queue {
protected:
    struct Node {
        T data;
        std::shared_ptr<Node> next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::shared_ptr<Node> front;
    std::shared_ptr<Node> rear;
    size_t size;

public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}

    virtual ~Queue() = default;

    void enqueue(const T& value) {
        auto newNode = std::make_shared<Node>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    T dequeue() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    bool isEmpty() const {
        return front == nullptr;
    }

    size_t getSize() const {
        return size;
    }

    T peek() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return front->data;
    }

    // Add index-based peek
    T peek(size_t index) const {
        if (index >= size) {
            throw std::out_of_range("Index out of bounds");
        }

        auto current = front;
        for (size_t i = 0; i < index; i++) {
            current = current->next;
        }
        return current->data;
    }
};


================================================================================
File: include\visualization\DebugOverlay.h
================================================================================

// include/visualization/DebugOverlay.h
#pragma once
#define _USE_MATH_DEFINES
#include <cmath>
#include <SDL3/SDL.h>
#include "managers/TrafficManager.h"
#include <map>

class DebugOverlay {
private:
    struct LaneStatistics {
        int vehicleCount;
        float avgWaitTime;
        int processedCount;
    };

    std::map<LaneId, LaneStatistics> stats;
    void updateStatistics(const TrafficManager& trafficManager);
    void renderQueueStats(SDL_Renderer* renderer, int x, int y);
    void renderLaneLoadIndicator(SDL_Renderer* renderer, int x, int y);
    void renderSystemStatus(SDL_Renderer* renderer, int x, int y);

public:
    DebugOverlay() = default;
    void render(SDL_Renderer* renderer, const TrafficManager& trafficManager);
};


================================================================================
File: include\visualization\Renderer.h
================================================================================

#pragma once

#define _USE_MATH_DEFINES  // Required for M_PI constant

// Core SDL includes
#include <SDL3/SDL.h>

// Project includes
#include "managers/TrafficManager.h"
#include "visualization/DebugOverlay.h"
#include "core/Constants.h"

// Standard library includes
#include <memory>
#include <map>
#include <cmath>

/**
 * @class Renderer
 * @brief Handles visualization for the traffic simulation system
 */
class Renderer {
private:
    // Core SDL components
    SDL_Window* window;
    SDL_Renderer* renderer;

    // Debug components
    DebugOverlay debugOverlay;
    bool debugMode;
    bool showGrid;

    // Rendering constants
    static constexpr float VEHICLE_WIDTH = 40.0f;
    static constexpr float VEHICLE_HEIGHT = 30.0f;
    static constexpr float LIGHT_SIZE = 20.0f;
    static constexpr float ARROW_SIZE = 30.0f;
    static constexpr float DASH_LENGTH = 20.0f;
    static constexpr float GAP_LENGTH = 20.0f;
    static constexpr float HOUSING_PADDING = 5.0f;

    // Environment rendering methods
    void renderBackground();
    void renderGrassAreas();
    void renderRoads();
    void renderRoadEdges();
    void renderLanes();
    void renderIntersection();
    void renderCrosswalks();
    void renderStopLines();

    // Traffic elements rendering
    void renderDirectionalArrows();
    void renderTrafficLights(const std::map<LaneId, TrafficLight>& lights);

    void renderTrafficLight(float x, float y, float rotation, LightState state);
    void renderVehicles(const std::map<uint32_t, VehicleState>& vehicles);
    void renderVehicle(float x, float y, Direction dir, bool isPriority, float angle, bool isMoving);
    void renderPriorityLane();
    void renderPriorityLaneIndicator();
    void renderTurningGuides();

    // Debug visualization
    void renderLaneIdentifiers();
    void renderVehicleCount(const TrafficManager& trafficManager);
    void drawDebugGrid();

    // Helper methods
    void drawArrow(float x, float y, float angle, Direction dir);
    void renderCircle(float x, float y, float radius);
    void renderDashedLine(float x1, float y1, float x2, float y2);
    void renderRoundedRect(float x, float y, float w, float h, float radius);
    SDL_FPoint rotatePoint(float x, float y, float cx, float cy, float angle);
    float calculateTurningAngle(const VehicleState& state) const;
    SDL_Color getLaneColor(LaneId laneId, bool isActive) const;

public:
    // Constructor and destructor
    Renderer();
    ~Renderer();

    // Core methods
    bool initialize();
    void render(const TrafficManager& trafficManager);
    void cleanup();
    bool isInitialized() const { return window != nullptr && renderer != nullptr; }

    // Configuration methods
    void setDebugMode(bool enabled) { debugMode = enabled; }
    void toggleGridDisplay() { showGrid = !showGrid; }
    void updateWindowSize(int width, int height);
};


================================================================================
File: src\common\types.h
================================================================================

// src/common/types.h
#pragma once
#include <cstdint>
#include <string>

enum class LaneId {
    AL1_INCOMING,
    AL2_PRIORITY,
    AL3_FREELANE,
    BL1_INCOMING,
    BL2_NORMAL,
    BL3_FREELANE,
    CL1_INCOMING,
    CL2_NORMAL,
    CL3_FREELANE,
    DL1_INCOMING,
    DL2_NORMAL,
    DL3_FREELANE
};

enum class LightState {
    RED,
    GREEN
};

;


================================================================================
File: src\common\vector2d.h
================================================================================

// src/utils/vector2d.h
#pragma once

struct Vector2D {
    float x;
    float y;

    Vector2D() : x(0.0f), y(0.0f) {}
    Vector2D(float x, float y) : x(x), y(y) {}

    Vector2D operator+(const Vector2D& other) const {
        return Vector2D(x + other.x, y + other.y);
    }

    Vector2D operator*(float scalar) const {
        return Vector2D(x * scalar, y * scalar);
    }
};



================================================================================
File: src\core\Lane.cpp
================================================================================

// src/core/Lane.cpp
#include "core/Lane.h"
#include <filesystem>

Lane::Lane(LaneId id, bool isPriority)
    : id(id), isPriority(isPriority) {
    // Set up data file path based on lane ID
    std::string lanePrefix;
    switch(id) {
        case LaneId::AL1_INCOMING: lanePrefix = "a1"; break;
        case LaneId::AL2_PRIORITY: lanePrefix = "a2"; break;
        case LaneId::AL3_FREELANE: lanePrefix = "a3"; break;
        // ... add other cases
        default: lanePrefix = "unknown";
    }
    dataFile = "data/lanes/lane_" + lanePrefix + ".txt";
}


Direction Lane::getVehicleDirection(size_t index) const {
    if (index >= vehicleQueue.getSize()) {
        return Direction::STRAIGHT;  // Default direction
    }

    // This assumes you maintain the vehicles in order in your queue
    // You might need to adjust this based on your Queue implementation
    auto vehicle = vehicleQueue.peek(index);
    return vehicle ? vehicle->getDirection() : Direction::STRAIGHT;
}

void Lane::addVehicle(std::shared_ptr<Vehicle> vehicle) {
    vehicleQueue.enqueue(vehicle);
}

std::shared_ptr<Vehicle> Lane::removeVehicle() {
    if (vehicleQueue.isEmpty()) return nullptr;
    return vehicleQueue.dequeue();
}

size_t Lane::getQueueSize() const {
    return vehicleQueue.getSize();
}

bool Lane::isPriorityLane() const {
    return isPriority;
}

LaneId Lane::getId() const {
    return id;
}

const std::string& Lane::getDataFile() const {
    return dataFile;
}

void Lane::update() {
    // Update logic for free lanes
    if (id == LaneId::AL3_FREELANE ||
        id == LaneId::BL3_FREELANE ||
        id == LaneId::CL3_FREELANE ||
        id == LaneId::DL3_FREELANE) {
        // Free lanes process vehicles immediately
        while (!vehicleQueue.isEmpty()) {
            removeVehicle();
        }
    }
}


================================================================================
File: src\core\TrafficLight.cpp
================================================================================

// src/core/TrafficLight.cpp
#include "core/TrafficLight.h"

TrafficLight::TrafficLight()
    : state(LightState::RED)
    , nextState(LightState::RED)
    , transitionProgress(0.0f)
    , transitionDuration(1.0f)
    , stateTimer(0.0f)
    , isTransitioning(false) {}

void TrafficLight::update(float deltaTime) {
    stateTimer += deltaTime;

    if (isTransitioning) {
        transitionProgress += deltaTime / transitionDuration;
        if (transitionProgress >= 1.0f) {
            transitionProgress = 0.0f;
            isTransitioning = false;
            state = nextState;
        }
    }
    else if (stateTimer >= 5.0f) {  // 5 seconds per state
        stateTimer = 0.0f;
        isTransitioning = true;
        nextState = (state == LightState::RED) ? LightState::GREEN : LightState::RED;
    }
}

void TrafficLight::setState(LightState newState) {
    state = newState;
    stateTimer = 0.0f;
}

LightState TrafficLight::getState() const {
    return state;
}

void TrafficLight::render(SDL_Renderer* renderer, float x, float y) const {
    const float SIZE = 30.0f;
    const float SPACING = 40.0f;

    // Draw light housing
    SDL_FRect housing = {x - 5, y - 5, SIZE + 10, (SIZE * 2) + SPACING + 10};
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);
    SDL_RenderFillRect(renderer, &housing);

    // Draw red light
    SDL_FRect redLight = {x, y, SIZE, SIZE};
    float redIntensity = (state == LightState::RED) ?
        (isTransitioning ? 1.0f - transitionProgress : 1.0f) :
        (isTransitioning ? transitionProgress : 0.0f);
    SDL_SetRenderDrawColor(renderer,
        static_cast<uint8_t>(255 * redIntensity),
        0,
        0,
        255);
    SDL_RenderFillRect(renderer, &redLight);

    // Draw green light
    SDL_FRect greenLight = {x, y + SIZE + SPACING, SIZE, SIZE};
    float greenIntensity = (state == LightState::GREEN) ?
        (isTransitioning ? 1.0f - transitionProgress : 1.0f) :
        (isTransitioning ? transitionProgress : 0.0f);
    SDL_SetRenderDrawColor(renderer,
        0,
        static_cast<uint8_t>(255 * greenIntensity),
        0,
        255);
    SDL_RenderFillRect(renderer, &greenLight);

    // Draw borders
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}


================================================================================
File: src\core\Vehicle.cpp
================================================================================

// include/cor

// src/core/Vehicle.cpp
#include "core/Vehicle.h"

Vehicle::Vehicle(uint32_t id, Direction dir, LaneId lane)
    : id(id), direction(dir), currentLane(lane) {}

uint32_t Vehicle::getId() const { return id; }
Direction Vehicle::getDirection() const { return direction; }
LaneId Vehicle::getCurrentLane() const { return currentLane; }



================================================================================
File: src\main.cpp
================================================================================

// src/main.cpp
#include <SDL3/SDL.h>
#include "managers/TrafficManager.h"
#include "managers/FileHandler.h"
#include "visualization/Renderer.h"
#include <iostream>
#include <chrono>

class Simulator {
private:
    TrafficManager trafficManager;
    Renderer renderer;
    bool running;

    void processInput() {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
                case SDL_EVENT_QUIT:
                    running = false;
                    break;
                case SDL_EVENT_KEY_DOWN:
                    // For SDL3, we use scancode instead of keysym
                    if (event.key.scancode == SDL_SCANCODE_ESCAPE) {
                        running = false;
                    }
                    break;
            }
        }
    }

    void update(float deltaTime) {
        trafficManager.update(deltaTime);
    }

    void render() {
        renderer.render(trafficManager);
    }

public:
    Simulator() : running(false) {}

    bool initialize() {
        if (!renderer.initialize()) {
            std::cerr << "Failed to initialize renderer" << std::endl;
            return false;
        }

        // Clear any existing vehicle data
        FileHandler fileHandler;
        fileHandler.clearLaneFiles();

        running = true;
        return true;
    }

    void run() {
        auto lastUpdateTime = std::chrono::high_resolution_clock::now();

        while (running) {
            auto currentTime = std::chrono::high_resolution_clock::now();
            float deltaTime = std::chrono::duration<float>(currentTime - lastUpdateTime).count();
            lastUpdateTime = currentTime;

            processInput();
            update(deltaTime);
            render();

            // Cap frame rate at ~60 FPS
            if (deltaTime < 0.016f) {
                SDL_Delay(static_cast<uint32_t>((0.016f - deltaTime) * 1000));
            }
        }
    }

    void cleanup() {
        renderer.cleanup();
    }
};

int main(int argc, char* argv[]) {
    (void)argc; // Suppress unused parameter warning
    (void)argv; // Suppress unused parameter warning

    Simulator simulator;

    if (!simulator.initialize()) {
        std::cerr << "Failed to initialize simulator" << std::endl;
        return 1;
    }

    std::cout << "Traffic Simulator Started\n";
    std::cout << "Press ESC to exit\n";

    simulator.run();
    simulator.cleanup();

    return 0;
}


================================================================================
File: src\managers\FileHandler.cpp
================================================================================

#include "managers/FileHandler.h"
#include <fstream>
#include <sstream>
#include <filesystem>
#include <iostream>



const std::string FileHandler::BASE_PATH = "data/lanes";

// FileHandler Constructor
FileHandler::FileHandler() {
    try {
        // Get absolute path for data directory
        dataDir = (std::filesystem::current_path() / BASE_PATH).lexically_normal();
        std::cout << "FileHandler using absolute path: " << dataDir << std::endl;

        // Initialize lane files with absolute paths
        laneFiles = {
            {LaneId::AL1_INCOMING, (dataDir / "lane_a1.txt").lexically_normal()},
            {LaneId::AL2_PRIORITY, (dataDir / "lane_a2.txt").lexically_normal()},
            {LaneId::AL3_FREELANE, (dataDir / "lane_a3.txt").lexically_normal()},
            {LaneId::BL1_INCOMING, (dataDir / "lane_b1.txt").lexically_normal()},
            {LaneId::BL2_NORMAL,   (dataDir / "lane_b2.txt").lexically_normal()},
            {LaneId::BL3_FREELANE, (dataDir / "lane_b3.txt").lexically_normal()},
            {LaneId::CL1_INCOMING, (dataDir / "lane_c1.txt").lexically_normal()},
            {LaneId::CL2_NORMAL,   (dataDir / "lane_c2.txt").lexically_normal()},
            {LaneId::CL3_FREELANE, (dataDir / "lane_c3.txt").lexically_normal()},
            {LaneId::DL1_INCOMING, (dataDir / "lane_d1.txt").lexically_normal()},
            {LaneId::DL2_NORMAL,   (dataDir / "lane_d2.txt").lexically_normal()},
            {LaneId::DL3_FREELANE, (dataDir / "lane_d3.txt").lexically_normal()}
        };

        // Create data directory if it doesn't exist
        std::filesystem::create_directories(dataDir);

        // Verify all files exist and are readable
        for (const auto& [laneId, filepath] : laneFiles) {
            std::cout << "Checking file for lane " << static_cast<int>(laneId)
                     << ": " << filepath << std::endl;

            // Create file if it doesn't exist
            if (!std::filesystem::exists(filepath)) {
                std::cout << "File does not exist, creating: " << filepath << std::endl;
                std::ofstream createFile(filepath);
                if (!createFile) {
                    throw std::runtime_error("Cannot create file: " + filepath.string());
                }
                createFile.close();
            }

            // Verify read access
            std::ifstream testRead(filepath);
            if (!testRead) {
                throw std::runtime_error("Cannot read from " + filepath.string());
            }
            testRead.close();

            // Initialize read position
            lastReadPositions[filepath] = 0;

            std::cout << "Successfully verified file: " << filepath << std::endl;
        }

        std::cout << "FileHandler successfully initialized" << std::endl;
        std::cout << "Data directory: " << dataDir << std::endl;
        std::cout << "Number of lanes: " << laneFiles.size() << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "FileHandler initialization failed: " << e.what() << std::endl;
        throw;
    }
}// src/managers/FileHandler.cpp
std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> FileHandler::readNewVehicles() {
    std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> newVehicles;

    std::cout << "\n=== Reading Vehicle Files ===" << std::endl;

    for (const auto& [laneId, filepath] : laneFiles) {
        std::cout << "Checking file: " << filepath << std::endl;

        if (!std::filesystem::exists(filepath)) {
            std::cerr << "File does not exist: " << filepath << std::endl;
            continue;
        }

        std::ifstream file(filepath.string(), std::ios::in);
        if (!file) {
            std::cerr << "Cannot open file: " << filepath << std::endl;
            continue;
        }

        // Get file size
        file.seekg(0, std::ios::end);
        int64_t fileSize = file.tellg();
        std::cout << "File size: " << fileSize << " bytes" << std::endl;
        std::cout << "Last read position: " << lastReadPositions[filepath] << std::endl;

        if (fileSize > lastReadPositions[filepath]) {
            file.seekg(lastReadPositions[filepath]);
            std::string line;

            while (std::getline(file, line)) {
                std::cout << "Reading line: " << line << std::endl;

                // Skip empty lines
                if (line.empty()) continue;

                // Parse vehicle data (format: "ID,Direction;")
                size_t commaPos = line.find(',');
                size_t semicolonPos = line.find(';');

                if (commaPos != std::string::npos && semicolonPos != std::string::npos) {
                    try {
                        // Parse ID
                        uint32_t id = std::stoul(line.substr(0, commaPos));

                        // Parse direction
                        char dirChar = line[commaPos + 1];
                        Direction dir;
                        switch (dirChar) {
                            case 'S': dir = Direction::STRAIGHT; break;
                            case 'L': dir = Direction::LEFT; break;
                            case 'R': dir = Direction::RIGHT; break;
                            default:
                                std::cerr << "Invalid direction character: " << dirChar << std::endl;
                                continue;
                        }

                        std::cout << "Creating vehicle: ID=" << id
                                 << ", Direction=" << static_cast<int>(dir)
                                 << ", Lane=" << static_cast<int>(laneId) << std::endl;

                        auto vehicle = std::make_shared<Vehicle>(id, dir, laneId);
                        newVehicles.emplace_back(laneId, vehicle);
                    } catch (const std::exception& e) {
                        std::cerr << "Error parsing line: " << line << " - " << e.what() << std::endl;
                    }
                } else {
                    std::cerr << "Invalid line format: " << line << std::endl;
                }
            }

            lastReadPositions[filepath] = file.tellg();
            std::cout << "Updated read position to: " << lastReadPositions[filepath] << std::endl;
        }
    }

    std::cout << "Found " << newVehicles.size() << " new vehicles" << std::endl;
    return newVehicles;
}


std::vector<std::shared_ptr<Vehicle>> FileHandler::parseVehicleData(
    const std::string& data, LaneId laneId) {
    std::vector<std::shared_ptr<Vehicle>> vehicles;
    std::stringstream ss(data);
    std::string vehicleData;

    while (std::getline(ss, vehicleData, ';')) {
        if (vehicleData.empty()) continue;

        // Expected format: "id,direction"
        std::stringstream vehicleSS(vehicleData);
        std::string idStr, dirStr;

        if (std::getline(vehicleSS, idStr, ',') &&
            std::getline(vehicleSS, dirStr, ',')) {
            try {
                uint32_t id = std::stoul(idStr);
                Direction dir;

                if (dirStr == "S") dir = Direction::STRAIGHT;
                else if (dirStr == "L") dir = Direction::LEFT;
                else if (dirStr == "R") dir = Direction::RIGHT;
                else continue;

                vehicles.push_back(std::make_shared<Vehicle>(id, dir, laneId));
            } catch (...) {
                // Skip invalid data
                continue;
            }
        }
    }

    return vehicles;
}

void FileHandler::clearLaneFiles() {
    for (const auto& [_, filepath] : laneFiles) {
        std::ofstream file(filepath, std::ios::trunc);
        lastReadPositions[filepath] = 0;
    }
}





================================================================================
File: src\managers\IntersectionController.cpp
================================================================================

// IntersectionController.cpp
#include "managers/IntersectionController.h"
#include <algorithm>
#include <numeric>

IntersectionController::IntersectionController(std::vector<std::unique_ptr<Lane>>& lanes)
    : lanes(lanes)
    , isPriorityMode(false)
    , stateTimer(0.0f)
    , elapsedTime(0.0f)
    , processingTimer(0.0f)
    , vehiclesProcessedInState(0)
    , totalVehiclesProcessed(0)
{
    updateLaneQueue();
}

void IntersectionController::update(float deltaTime) {
    updateTimers(deltaTime);

    // Check state transitions
    handleStateTransition();

    // Process vehicles based on current state
    if (processingTimer >= calculateProcessingTime()) {
        if (isPriorityMode) {
            processPriorityLane();
        } else {
            processNormalLanes();
        }
        processingTimer = 0.0f;
    }

    // Always process free lanes
    processFreeLanes();

    // Check wait times and update priorities
    checkWaitTimes();
    updateLaneQueue();
}

void IntersectionController::updateTimers(float deltaTime) {
    stateTimer += deltaTime;
    elapsedTime += deltaTime;
    processingTimer += deltaTime;
}

void IntersectionController::handleStateTransition() {
    if (isPriorityMode && shouldSwitchToNormalMode()) {
        isPriorityMode = false;
        resetStateTimers();
    }
    else if (!isPriorityMode && shouldSwitchToPriorityMode()) {
        isPriorityMode = true;
        resetStateTimers();
    }

    // Force state change if stuck too long
    if (stateTimer >= MAX_STATE_TIME) {
        isPriorityMode = !isPriorityMode;
        resetStateTimers();
    }
}

void IntersectionController::updateLaneQueue() {
    // Clear existing queue
    while (!laneQueue.isEmpty()) {
        laneQueue.dequeue();
    }

    // Add lanes with calculated priorities
    for (const auto& lane : lanes) {
        if (!isFreeLane(lane->getId())) {
            int priority = calculateLanePriority(*lane);
            laneQueue.enqueuePriority(lane->getId(), priority);
        }
    }
}

int IntersectionController::calculateLanePriority(const Lane& lane) const {
    int priority = 1; // Base priority

    if (lane.isPriorityLane() && lane.getQueueSize() > PRIORITY_THRESHOLD) {
        priority = 3; // Highest priority
    }
    else if (lane.getQueueSize() > 8) {
        priority = 2; // Medium priority
    }

    return priority;
}

void IntersectionController::processPriorityLane() {
    Lane* priorityLane = getPriorityLane();
    if (!priorityLane) return;

    size_t initialSize = priorityLane->getQueueSize();
    while (priorityLane->getQueueSize() > PRIORITY_RELEASE_THRESHOLD) {
        auto vehicle = priorityLane->removeVehicle();
        if (vehicle) {
            vehiclesProcessedInState++;
            totalVehiclesProcessed++;
        }
    }
}

void IntersectionController::processNormalLanes() {
    size_t vehiclesToProcess = calculateVehiclesToProcess();

    for (auto& lane : lanes) {
        if (!isFreeLane(lane->getId()) && !lane->isPriorityLane()) {
            for (size_t i = 0; i < vehiclesToProcess && lane->getQueueSize() > 0; ++i) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

void IntersectionController::processFreeLanes() {
    for (auto& lane : lanes) {
        if (isFreeLane(lane->getId())) {
            while (lane->getQueueSize() > 0) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

size_t IntersectionController::calculateVehiclesToProcess() const {
    // |V| = 1/n Σ|Li| formula from assignment
    float avgVehicles = calculateAverageWaitingVehicles();
    return static_cast<size_t>(std::ceil(avgVehicles));
}

float IntersectionController::calculateAverageWaitingVehicles() const {
    size_t totalVehicles = 0;
    size_t normalLaneCount = 0;

    for (const auto& lane : lanes) {
        if (!isFreeLane(lane->getId()) && !lane->isPriorityLane()) {
            totalVehicles += lane->getQueueSize();
            normalLaneCount++;
        }
    }

    return normalLaneCount > 0 ?
        static_cast<float>(totalVehicles) / static_cast<float>(normalLaneCount) : 0.0f;
}

float IntersectionController::calculateProcessingTime() const {
    // Total processing time = |V| * t where t is BASE_VEHICLE_PROCESS_TIME
    float avgVehicles = calculateAverageWaitingVehicles();
    return avgVehicles * BASE_VEHICLE_PROCESS_TIME;
}

bool IntersectionController::shouldSwitchToNormalMode() const {
    if (!isPriorityMode) return false;

    Lane* priorityLane = getPriorityLane();
    return priorityLane &&
           priorityLane->getQueueSize() <= PRIORITY_RELEASE_THRESHOLD &&
           stateTimer >= MIN_STATE_TIME;
}

bool IntersectionController::shouldSwitchToPriorityMode() const {
    if (isPriorityMode) return false;

    Lane* priorityLane = getPriorityLane();
    return priorityLane &&
           priorityLane->getQueueSize() > PRIORITY_THRESHOLD &&
           stateTimer >= MIN_STATE_TIME;
}

void IntersectionController::resetStateTimers() {
    stateTimer = 0.0f;
    processingTimer = 0.0f;
    vehiclesProcessedInState = 0;
}

Lane* IntersectionController::getPriorityLane() const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [](const auto& lane) { return lane->isPriorityLane(); });
    return it != lanes.end() ? it->get() : nullptr;
}

bool IntersectionController::isFreeLane(LaneId id) const {
    return id == LaneId::AL3_FREELANE ||
           id == LaneId::BL3_FREELANE ||
           id == LaneId::CL3_FREELANE ||
           id == LaneId::DL3_FREELANE;
}

void IntersectionController::checkWaitTimes() {
    for (const auto& lane : lanes) {
        if (lane->getQueueSize() > 0 && !isFreeLane(lane->getId())) {
            // Process lanes that have been waiting too long
            if (lane->getQueueSize() >= 8) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

std::vector<IntersectionController::LaneStatus> IntersectionController::getLaneStatuses() const {
    std::vector<LaneStatus> statuses;

    for (const auto& lane : lanes) {
        LaneStatus status;
        status.id = lane->getId();
        status.queueSize = lane->getQueueSize();
        status.isActive = isPriorityMode ? lane->isPriorityLane() :
                         !isFreeLane(lane->getId());
        status.priority = calculateLanePriority(*lane);

        statuses.push_back(status);
    }

    return statuses;
}

IntersectionController::ProcessingStats IntersectionController::getStats() const {
    ProcessingStats stats;
    stats.totalVehiclesProcessed = totalVehiclesProcessed;
    stats.isPriorityMode = isPriorityMode;

    // Fill current queue sizes
    size_t laneIndex = 0;
    for (const auto& lane : lanes) {
        stats.currentQueueSizes[laneIndex++] = lane->getQueueSize();
    }

    return stats;
}


================================================================================
File: src\managers\TrafficManager.cpp
================================================================================

#include "managers/TrafficManager.h"
#include "managers/FileHandler.h"
#include <algorithm>
#include <cmath>
#include <iostream>

TrafficManager::TrafficManager()
    : inPriorityMode(false)
    , stateTimer(0.0f)
    , lastUpdateTime(0.0f) {

    // Initialize all lanes with their respective configurations
    lanes.push_back(std::make_unique<Lane>(LaneId::AL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::AL2_PRIORITY, true));  // Priority lane
    lanes.push_back(std::make_unique<Lane>(LaneId::AL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL3_FREELANE, false));

    // Initialize traffic lights for controlled lanes
    trafficLights[LaneId::AL2_PRIORITY] = TrafficLight();
    trafficLights[LaneId::BL2_NORMAL] = TrafficLight();
    trafficLights[LaneId::CL2_NORMAL] = TrafficLight();
    trafficLights[LaneId::DL2_NORMAL] = TrafficLight();

    // Set initial traffic light states
    synchronizeTrafficLights();
}

void TrafficManager::update(float deltaTime) {
    using namespace SimConstants;

    stateTimer += deltaTime;
    lastUpdateTime += deltaTime;

    static float fileCheckTimer = 0.0f;
    fileCheckTimer += deltaTime;

    // Check for new vehicles at regular intervals
    if (fileCheckTimer >= FILE_CHECK_INTERVAL / 1000.0f) {
        FileHandler fileHandler;
        auto newVehicles = fileHandler.readNewVehicles();

        for (const auto& [laneId, vehicle] : newVehicles) {
            addVehicleToLane(laneId, vehicle);
            addNewVehicleToState(vehicle, laneId);
        }
        fileCheckTimer = 0.0f;
    }

    // Update vehicle positions and states
    updateVehiclePositions(deltaTime);

    // Check and handle priority conditions
    if (checkPriorityConditions()) {
        if (!inPriorityMode) {
            synchronizeTrafficLights();
        }
        inPriorityMode = true;
        processPriorityLane();
    } else {
        if (inPriorityMode) {
            synchronizeTrafficLights();
        }
        inPriorityMode = false;

        // Process normal lanes at regular intervals
        if (lastUpdateTime >= VEHICLE_PROCESS_TIME) {
            size_t vehiclesToProcess = calculateVehiclesToProcess();
            processNormalLanes(vehiclesToProcess);
            lastUpdateTime = 0.0f;
        }
    }

    // Update traffic lights
    updateTrafficLights(deltaTime);

    // Process free lanes continuously
    for (auto& lane : lanes) {
        if (lane->getId() == LaneId::AL3_FREELANE ||
            lane->getId() == LaneId::BL3_FREELANE ||
            lane->getId() == LaneId::CL3_FREELANE ||
            lane->getId() == LaneId::DL3_FREELANE) {

            while (lane->getQueueSize() > 0) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    auto it = activeVehicles.find(vehicle->getId());
                    if (it != activeVehicles.end()) {
                        it->second.isMoving = true;
                    }
                }
            }
        }
    }
}

void TrafficManager::addVehicleToLane(LaneId laneId, std::shared_ptr<Vehicle> vehicle) {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [laneId](const auto& lane) { return lane->getId() == laneId; });

    if (it != lanes.end()) {
        (*it)->addVehicle(vehicle);
    }
}

void TrafficManager::addNewVehicleToState(std::shared_ptr<Vehicle> vehicle, LaneId laneId) {
    using namespace SimConstants;

    VehicleState state;
    state.vehicle = vehicle;
    state.speed = VEHICLE_BASE_SPEED;
    state.isMoving = false;
    state.direction = vehicle->getDirection();
    state.hasStartedTurn = false;
    state.turnProgress = 0.0f;
    state.waitTime = 0.0f;

    // Calculate initial position based on lane and queue position
    size_t queuePosition = getLaneSize(laneId);

    // Set position based on lane configuration
    switch (laneId) {
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE: {
            float laneOffset = static_cast<float>(
                (static_cast<int>(laneId) - static_cast<int>(LaneId::AL1_INCOMING))
            ) * LANE_WIDTH;
            state.x = CENTER_X - QUEUE_START_OFFSET - (queuePosition * QUEUE_SPACING);
            state.y = CENTER_Y - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            break;
        }

        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE: {
            float laneOffset = static_cast<float>(
                (static_cast<int>(laneId) - static_cast<int>(LaneId::BL1_INCOMING))
            ) * LANE_WIDTH;
            state.x = CENTER_X - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            state.y = CENTER_Y - QUEUE_START_OFFSET - (queuePosition * QUEUE_SPACING);
            break;
        }

        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE: {
            float laneOffset = static_cast<float>(
                (static_cast<int>(laneId) - static_cast<int>(LaneId::CL1_INCOMING))
            ) * LANE_WIDTH;
            state.x = CENTER_X + QUEUE_START_OFFSET + (queuePosition * QUEUE_SPACING);
            state.y = CENTER_Y - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            break;
        }

        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE: {
            float laneOffset = static_cast<float>(
                (static_cast<int>(laneId) - static_cast<int>(LaneId::DL1_INCOMING))
            ) * LANE_WIDTH;
            state.x = CENTER_X - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            state.y = CENTER_Y + QUEUE_START_OFFSET + (queuePosition * QUEUE_SPACING);
            break;
        }
    }

    // Calculate target position for vehicle's path
    calculateTargetPosition(state, laneId);

    std::cout << "Added vehicle " << vehicle->getId()
              << " to lane " << static_cast<int>(laneId)
              << " at position (" << state.x << "," << state.y << ")"
              << " with direction " << static_cast<int>(state.direction)
              << std::endl;

    activeVehicles[vehicle->getId()] = state;
}

void TrafficManager::updateVehiclePositions(float deltaTime) {
    auto it = activeVehicles.begin();
    while (it != activeVehicles.end()) {
        auto& state = it->second;

        if (state.isMoving) {
            float dx = state.targetX - state.x;
            float dy = state.targetY - state.y;
            float distance = std::sqrt(dx * dx + dy * dy);

            // Remove vehicle if it reached its destination
            if (distance < 1.0f) {
                it = activeVehicles.erase(it);
                continue;
            }

            // Calculate movement with gradual speed increase
            float speedFactor = 1.0f - std::exp(-distance / 200.0f);
            float currentSpeed = state.speed * speedFactor;

            float moveX = (dx / distance) * currentSpeed * deltaTime;
            float moveY = (dy / distance) * currentSpeed * deltaTime;

            // Check for collisions before moving
            if (!checkCollision(state, state.x + moveX, state.y + moveY)) {
                state.x += moveX;
                state.y += moveY;
            }
            ++it;
        } else {
            // Update queue position for waiting vehicles
            updateVehicleQueuePosition(
                state,
                state.vehicle->getCurrentLane(),
                getLaneSize(state.vehicle->getCurrentLane())
            );
            ++it;
        }
    }
}

void TrafficManager::updateVehicleQueuePosition(VehicleState& state, LaneId laneId,
                                              size_t queuePosition) {
    using namespace SimConstants;

    float laneOffset = 0.0f;

    // Calculate lane-specific offset
    switch (laneId) {
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE:
            laneOffset = static_cast<float>(
                (static_cast<int>(laneId) - static_cast<int>(LaneId::AL1_INCOMING))
            ) * LANE_WIDTH;
            state.x = CENTER_X - QUEUE_START_OFFSET - (queuePosition * QUEUE_SPACING);
            state.y = CENTER_Y - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            break;

        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE:
            laneOffset = static_cast<float>(
                (static_cast<int>(laneId) - static_cast<int>(LaneId::BL1_INCOMING))
            ) * LANE_WIDTH;
            state.x = CENTER_X - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            state.y = CENTER_Y - QUEUE_START_OFFSET - (queuePosition * QUEUE_SPACING);
            break;

        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE:
            laneOffset = static_cast<float>(
                (static_cast<int>(laneId) - static_cast<int>(LaneId::CL1_INCOMING))
            ) * LANE_WIDTH;
            state.x = CENTER_X + QUEUE_START_OFFSET + (queuePosition * QUEUE_SPACING);
            state.y = CENTER_Y - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            break;

        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE:
            laneOffset = static_cast<float>(
                (static_cast<int>(laneId) - static_cast<int>(LaneId::DL1_INCOMING))
            ) * LANE_WIDTH;
            state.x = CENTER_X - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            state.y = CENTER_Y + QUEUE_START_OFFSET + (queuePosition * QUEUE_SPACING);
            break;
    }
}

void TrafficManager::calculateTargetPosition(VehicleState& state, LaneId laneId) {
    using namespace SimConstants;

    const float EXIT_DISTANCE = 450.0f;

    // Calculate target position based on direction and current lane
    switch (state.direction) {
        case Direction::STRAIGHT: {
            switch (laneId) {
                case LaneId::AL1_INCOMING:
                case LaneId::AL2_PRIORITY:
                case LaneId::AL3_FREELANE:
                    state.targetX = CENTER_X + EXIT_DISTANCE;
                    state.targetY = state.y;
                    break;

                case LaneId::BL1_INCOMING:
                case LaneId::BL2_NORMAL:
                case LaneId::BL3_FREELANE:
                    state.targetX = state.x;
                    state.targetY = CENTER_Y + EXIT_DISTANCE;
                    break;

                case LaneId::CL1_INCOMING:
                case LaneId::CL2_NORMAL:
                case LaneId::CL3_FREELANE:
                    state.targetX = CENTER_X - EXIT_DISTANCE;
                    state.targetY = state.y;
                    break;

                case LaneId::DL1_INCOMING:
                case LaneId::DL2_NORMAL:
                case LaneId::DL3_FREELANE:
                    state.targetX = state.x;
                    state.targetY = CENTER_Y - EXIT_DISTANCE;
                    break;
            }
            break;
        }

        case Direction::LEFT: {
            float turnRadius = TURN_GUIDE_RADIUS;
            switch (laneId) {
                case LaneId::AL1_INCOMING:
                case LaneId::AL2_PRIORITY:
                case LaneId::AL3_FREELANE:
                    state.targetX = state.x + turnRadius;
                    state.targetY = CENTER_Y - EXIT_DISTANCE;
                    break;

                case LaneId::BL1_INCOMING:
                case LaneId::BL2_NORMAL:
case LaneId::BL3_FREELANE:
                    state.targetX = CENTER_X - EXIT_DISTANCE;
                    state.targetY = state.y + turnRadius;
                    break;

                case LaneId::CL1_INCOMING:
                case LaneId::CL2_NORMAL:
                case LaneId::CL3_FREELANE:
                    state.targetX = state.x - turnRadius;
                    state.targetY = CENTER_Y + EXIT_DISTANCE;
                    break;

                case LaneId::DL1_INCOMING:
                case LaneId::DL2_NORMAL:
                case LaneId::DL3_FREELANE:
                    state.targetX = CENTER_X + EXIT_DISTANCE;
                    state.targetY = state.y - turnRadius;
                    break;
            }
            break;
        }

        case Direction::RIGHT: {
            float turnRadius = TURN_GUIDE_RADIUS * 0.6f;  // Tighter turn for right turns
            switch (laneId) {
                case LaneId::AL1_INCOMING:
                case LaneId::AL2_PRIORITY:
                case LaneId::AL3_FREELANE:
                    state.targetX = state.x + turnRadius;
                    state.targetY = CENTER_Y + EXIT_DISTANCE;
                    break;

                case LaneId::BL1_INCOMING:
                case LaneId::BL2_NORMAL:
                case LaneId::BL3_FREELANE:
                    state.targetX = CENTER_X + EXIT_DISTANCE;
                    state.targetY = state.y + turnRadius;
                    break;

                case LaneId::CL1_INCOMING:
                case LaneId::CL2_NORMAL:
                case LaneId::CL3_FREELANE:
                    state.targetX = state.x - turnRadius;
                    state.targetY = CENTER_Y - EXIT_DISTANCE;
                    break;

                case LaneId::DL1_INCOMING:
                case LaneId::DL2_NORMAL:
                case LaneId::DL3_FREELANE:
                    state.targetX = CENTER_X - EXIT_DISTANCE;
                    state.targetY = state.y - turnRadius;
                    break;
            }
            break;
        }
    }
}

bool TrafficManager::checkCollision(const VehicleState& state, float newX, float newY) const {
    using namespace SimConstants;

    const float MIN_DISTANCE = VEHICLE_WIDTH * 1.2f;  // Safe distance between vehicles

    // Check collision with all other active vehicles
    for (const auto& [otherId, otherState] : activeVehicles) {
        if (otherId != state.vehicle->getId()) {
            float dx = newX - otherState.x;
            float dy = newY - otherState.y;
            float distance = std::sqrt(dx * dx + dy * dy);

            if (distance < MIN_DISTANCE) {
                return true;  // Collision detected
            }
        }
    }
    return false;  // No collision
}

void TrafficManager::updateTrafficLights(float deltaTime) {
    // Update each traffic light's state
    for (auto& [_, light] : trafficLights) {
        light.update(deltaTime);
    }

    // Synchronize traffic lights based on priority mode
    if (!inPriorityMode) {
        // Normal mode: opposing lights are synchronized
        if (trafficLights[LaneId::BL2_NORMAL].getState() == LightState::GREEN) {
            trafficLights[LaneId::DL2_NORMAL].setState(LightState::GREEN);
            trafficLights[LaneId::AL2_PRIORITY].setState(LightState::RED);
            trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
        } else {
            trafficLights[LaneId::AL2_PRIORITY].setState(LightState::GREEN);
            trafficLights[LaneId::CL2_NORMAL].setState(LightState::GREEN);
            trafficLights[LaneId::BL2_NORMAL].setState(LightState::RED);
            trafficLights[LaneId::DL2_NORMAL].setState(LightState::RED);
        }
    } else {
        // Priority mode: priority lane gets green, others red
        trafficLights[LaneId::AL2_PRIORITY].setState(LightState::GREEN);
        trafficLights[LaneId::BL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(LightState::RED);
    }
}

void TrafficManager::synchronizeTrafficLights() {
    // Set initial states based on priority mode
    if (inPriorityMode) {
        trafficLights[LaneId::AL2_PRIORITY].setState(LightState::GREEN);
        trafficLights[LaneId::BL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(LightState::RED);
    } else {
        // Start with North-South traffic flow
        trafficLights[LaneId::AL2_PRIORITY].setState(LightState::RED);
        trafficLights[LaneId::BL2_NORMAL].setState(LightState::GREEN);
        trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(LightState::GREEN);
    }
}

bool TrafficManager::checkPriorityConditions() const {
    // Check if priority lane (AL2) has more than 10 vehicles
    auto priorityLane = std::find_if(lanes.begin(), lanes.end(),
        [](const auto& lane) {
            return lane->isPriorityLane() && lane->getQueueSize() > 10;
        });
    return priorityLane != lanes.end();
}

void TrafficManager::processPriorityLane() {
    // Process vehicles in priority lane until queue length is below threshold
    for (auto& lane : lanes) {
        if (lane->isPriorityLane() && lane->getQueueSize() > 5) {
            while (lane->getQueueSize() > 5) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    auto it = activeVehicles.find(vehicle->getId());
                    if (it != activeVehicles.end()) {
                        it->second.isMoving = true;
                    }
                }
            }
            break;
        }
    }
}

void TrafficManager::processNormalLanes(size_t vehicleCount) {
    if (vehicleCount == 0) return;

    // Process vehicles from normal lanes based on calculated count
    for (auto& lane : lanes) {
        if (!lane->isPriorityLane() &&
            lane->getId() != LaneId::AL3_FREELANE &&
            lane->getId() != LaneId::BL3_FREELANE &&
            lane->getId() != LaneId::CL3_FREELANE &&
            lane->getId() != LaneId::DL3_FREELANE) {

            // Process up to vehicleCount vehicles from each normal lane
            for (size_t i = 0; i < vehicleCount && lane->getQueueSize() > 0; ++i) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    auto it = activeVehicles.find(vehicle->getId());
                    if (it != activeVehicles.end()) {
                        it->second.isMoving = true;
                    }
                }
            }
        }
    }
}

size_t TrafficManager::calculateVehiclesToProcess() const {
    // Calculate average number of waiting vehicles in normal lanes
    size_t totalVehicles = 0;
    size_t normalLaneCount = 0;

    for (const auto& lane : lanes) {
        if (!lane->isPriorityLane() &&
            lane->getId() != LaneId::AL3_FREELANE &&
            lane->getId() != LaneId::BL3_FREELANE &&
            lane->getId() != LaneId::CL3_FREELANE &&
            lane->getId() != LaneId::DL3_FREELANE) {

            totalVehicles += lane->getQueueSize();
            normalLaneCount++;
        }
    }

    if (normalLaneCount == 0) return 0;

    // Calculate and return the number of vehicles to process
    float avgVehicles = static_cast<float>(totalVehicles) / static_cast<float>(normalLaneCount);
    float vehicleRatio = 0.3f;  // Process 30% of average waiting vehicles
    return static_cast<size_t>(std::ceil(avgVehicles * vehicleRatio));
}

size_t TrafficManager::getLaneSize(LaneId laneId) const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [laneId](const auto& lane) { return lane->getId() == laneId; });

    return (it != lanes.end()) ? (*it)->getQueueSize() : 0;
}

float TrafficManager::calculateTurningRadius(Direction dir) const {
    using namespace SimConstants;
    return (dir == Direction::LEFT) ? INTERSECTION_RADIUS * 1.5f :
           (dir == Direction::RIGHT) ? INTERSECTION_RADIUS * 0.5f :
           INTERSECTION_RADIUS;
}


================================================================================
File: src\utils\Queue.cpp
================================================================================

// include/utils/Queue.hpp
#pragma once
#include <memory>
#include <stdexcept>

template<typename T>
class Queue {
protected:
    struct Node {
        T data;
        std::shared_ptr<Node> next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::shared_ptr<Node> front;
    std::shared_ptr<Node> rear;
    size_t size;

public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}

    virtual ~Queue() = default;

    void enqueue(const T& value) {
        auto newNode = std::make_shared<Node>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    T dequeue() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    bool isEmpty() const {
        return front == nullptr;
    }

    size_t getSize() const {
        return size;
    }

    T peek() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return front->data;
    }
};


================================================================================
File: src\utils\vector2d.h
================================================================================



================================================================================
File: src\visualization\DebugOverlay.cpp
================================================================================

// src/visualization/DebugOverlay.cpp
#define _USE_MATH_DEFINES
#include <cmath>
#include "visualization/DebugOverlay.h"

void DebugOverlay::render(SDL_Renderer* renderer, const TrafficManager& trafficManager) {
    // Draw background for debug panel
    SDL_FRect debugPanel = {10.0f, 10.0f, 200.0f, 300.0f};
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200);
    SDL_RenderFillRect(renderer, &debugPanel);

    // Priority mode indicator
    if (trafficManager.isInPriorityMode()) {
        SDL_FRect priorityIndicator = {20.0f, 20.0f, 20.0f, 20.0f};
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderFillRect(renderer, &priorityIndicator);
    }

    // Queue lengths visualization
    int yOffset = 50;
    for (const auto& lane : trafficManager.getLanes()) {
        SDL_FRect queueBar = {
            20.0f,
            static_cast<float>(yOffset),
            static_cast<float>(lane->getQueueSize() * 5),
            15.0f
        };

        // Color based on lane type
        if (lane->isPriorityLane()) {
            SDL_SetRenderDrawColor(renderer, 255, 100, 100, 255);
        } else if (lane->getId() == LaneId::AL3_FREELANE ||
                   lane->getId() == LaneId::BL3_FREELANE ||
                   lane->getId() == LaneId::CL3_FREELANE ||
                   lane->getId() == LaneId::DL3_FREELANE) {
            SDL_SetRenderDrawColor(renderer, 100, 255, 100, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 100, 150, 255, 255);
        }

        SDL_RenderFillRect(renderer, &queueBar);
        yOffset += 20;
    }
}

void DebugOverlay::updateStatistics(const TrafficManager& trafficManager) {
    for (const auto& lane : trafficManager.getLanes()) {
        LaneStatistics& laneStat = stats[lane->getId()];
        laneStat.vehicleCount = static_cast<int>(lane->getQueueSize());
    }
}

void DebugOverlay::renderQueueStats(SDL_Renderer* renderer, int x, int y) {
    int yOffset = y;
    for (const auto& [laneId, stat] : stats) {
        SDL_FRect bar = {
            static_cast<float>(x + 10),
            static_cast<float>(yOffset),
            static_cast<float>(stat.vehicleCount * 5),
            15.0f
        };

        if (stat.vehicleCount > 10) {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        } else if (stat.vehicleCount > 5) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        }

        SDL_RenderFillRect(renderer, &bar);
        yOffset += 20;
    }
}

void DebugOverlay::renderLaneLoadIndicator(SDL_Renderer* renderer, int x, int y) {
    const float RADIUS = 50.0f;
    const int SEGMENTS = 12;
    const float TWO_PI = static_cast<float>(2.0 * M_PI);

    for (int i = 0; i < SEGMENTS; i++) {
        float startAngle = (TWO_PI * i) / SEGMENTS;
        float endAngle = (TWO_PI * (i + 1)) / SEGMENTS;

        float startX = x + RADIUS * cosf(startAngle);
        float startY = y + RADIUS * sinf(startAngle);
        float endX = x + RADIUS * cosf(endAngle);
        float endY = y + RADIUS * sinf(endAngle);

        // Color based on load
        int laneIndex = i % 4;
        LaneId laneId = static_cast<LaneId>(laneIndex);
        int load = stats[laneId].vehicleCount;

        if (load > 10) {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        } else if (load > 5) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        }

        SDL_RenderLine(renderer, startX, startY, endX, endY);
    }
}

void DebugOverlay::renderSystemStatus(SDL_Renderer* renderer, int x, int y) {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    // TODO: Add text rendering for system status when needed
}


================================================================================
File: src\visualization\Renderer.cpp
================================================================================


#define _USE_MATH_DEFINES

#include "visualization/Renderer.h"
#include <iostream>
#include <cmath>
#include <cmath>
Renderer::Renderer()
    : window(nullptr)
    , renderer(nullptr)
    , debugMode(false) {
}

Renderer::~Renderer() {
    cleanup();
}

bool Renderer::initialize() {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        std::cerr << "SDL initialization failed: " << SDL_GetError() << std::endl;
        return false;
    }

    window = SDL_CreateWindow(
        "Traffic Junction Simulator",
        SimConstants::WINDOW_WIDTH,
        SimConstants::WINDOW_HEIGHT,
        SDL_WINDOW_RESIZABLE
    );

    if (!window) {
        std::cerr << "Window creation failed: " << SDL_GetError() << std::endl;
        return false;
    }

    renderer = SDL_CreateRenderer(window, nullptr);
    if (!renderer) {
        std::cerr << "Renderer creation failed: " << SDL_GetError() << std::endl;
        return false;
    }

    return true;
}

void Renderer::render(const TrafficManager& trafficManager) {
    // Clear screen with black background
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    // Core rendering
    renderBackground();
    renderRoads();
    renderLanes();
    renderIntersection();
    renderCrosswalks();
    renderStopLines();
    renderDirectionalArrows();

    // Traffic elements
    renderTrafficLights(trafficManager.getTrafficLights());
    renderVehicles(trafficManager.getActiveVehicles());

    // Priority mode indicators
    if (trafficManager.isInPriorityMode()) {
        renderPriorityLaneIndicator();
    }

    // Debug visualization
    if (debugMode) {
        if (showGrid) {
            drawDebugGrid();
        }
        renderLaneIdentifiers();
        renderVehicleCount(trafficManager);
        debugOverlay.render(renderer, trafficManager);
    }

    SDL_RenderPresent(renderer);
}


void Renderer::renderBackground() {
    // Create a gradient sky effect
    for (int y = 0; y < SimConstants::WINDOW_HEIGHT; ++y) {
        float t = static_cast<float>(y) / SimConstants::WINDOW_HEIGHT;
        uint8_t skyR = static_cast<uint8_t>(135 * (1 - t) + 30 * t);
        uint8_t skyG = static_cast<uint8_t>(206 * (1 - t) + 30 * t);
        uint8_t skyB = static_cast<uint8_t>(235 * (1 - t) + 30 * t);

        SDL_SetRenderDrawColor(renderer, skyR, skyG, skyB, 255);
        SDL_RenderLine(renderer, 0, y, SimConstants::WINDOW_WIDTH, y);
    }

    // Render grass areas with texture
    renderGrassAreas();
}

void Renderer::renderGrassAreas() {
    using namespace SimConstants;
    SDL_SetRenderDrawColor(renderer, 34, 139, 34, 255); // Base grass color

    // Define the four corner grass areas around the intersection
    SDL_FRect grassAreas[] = {
        // Top-left quadrant
        {0, 0, CENTER_X - ROAD_WIDTH/2.0f, CENTER_Y - ROAD_WIDTH/2.0f},
        // Top-right quadrant
        {CENTER_X + ROAD_WIDTH/2.0f, 0,
         static_cast<float>(WINDOW_WIDTH) - (CENTER_X + ROAD_WIDTH/2.0f),
         CENTER_Y - ROAD_WIDTH/2.0f},
        // Bottom-left quadrant
        {0, CENTER_Y + ROAD_WIDTH/2.0f,
         CENTER_X - ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_HEIGHT) - (CENTER_Y + ROAD_WIDTH/2.0f)},
        // Bottom-right quadrant
        {CENTER_X + ROAD_WIDTH/2.0f, CENTER_Y + ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_WIDTH) - (CENTER_X + ROAD_WIDTH/2.0f),
         static_cast<float>(WINDOW_HEIGHT) - (CENTER_Y + ROAD_WIDTH/2.0f)}
    };

    // Fill base grass areas
    for (const auto& area : grassAreas) {
        SDL_RenderFillRect(renderer, &area);
    }

    // Add grass texture variation using random dots
    SDL_SetRenderDrawColor(renderer, 28, 120, 28, 255);
    for (int i = 0; i < 2000; i++) {
        int x = rand() % WINDOW_WIDTH;
        int y = rand() % WINDOW_HEIGHT;

        // Check if point is in grass area (not on road)
        bool inRoad = (x > CENTER_X - ROAD_WIDTH/2 && x < CENTER_X + ROAD_WIDTH/2) ||
                     (y > CENTER_Y - ROAD_WIDTH/2 && y < CENTER_Y + ROAD_WIDTH/2);

        if (!inRoad) {
            SDL_RenderPoint(renderer, x, y);
        }
    }
}

void Renderer::renderRoads() {
    using namespace SimConstants;

    // Main road surface with asphalt texture
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);

    // Draw horizontal road
    SDL_FRect horizontalRoad = {
        0, CENTER_Y - ROAD_WIDTH/2.0f,
        static_cast<float>(WINDOW_WIDTH),
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &horizontalRoad);

    // Draw vertical road
    SDL_FRect verticalRoad = {
        CENTER_X - ROAD_WIDTH/2.0f, 0,
        static_cast<float>(ROAD_WIDTH),
        static_cast<float>(WINDOW_HEIGHT)
    };
    SDL_RenderFillRect(renderer, &verticalRoad);

    // Add road edges and curbs
    renderRoadEdges();
}

void Renderer::renderRoadEdges() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 150, 150, 150, 255);
    const float CURB_WIDTH = 4.0f;

    // Render curbs for all road edges
    SDL_FRect curbs[] = {
        // Horizontal road curbs
        {0, CENTER_Y - ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_WIDTH), CURB_WIDTH},
        {0, CENTER_Y + ROAD_WIDTH/2.0f - CURB_WIDTH,
         static_cast<float>(WINDOW_WIDTH), CURB_WIDTH},

        // Vertical road curbs
        {CENTER_X - ROAD_WIDTH/2.0f, 0,
         CURB_WIDTH, static_cast<float>(WINDOW_HEIGHT)},
        {CENTER_X + ROAD_WIDTH/2.0f - CURB_WIDTH, 0,
         CURB_WIDTH, static_cast<float>(WINDOW_HEIGHT)}
    };

    for (const auto& curb : curbs) {
        SDL_RenderFillRect(renderer, &curb);
    }
}

void Renderer::renderLanes() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    float laneWidth = ROAD_WIDTH / 3.0f;

    // Draw horizontal lane dividers
    for (int i = 1; i < 3; i++) {
        float y = CENTER_Y - ROAD_WIDTH/2.0f + i * laneWidth;
        renderDashedLine(0, y, WINDOW_WIDTH, y);
    }

    // Draw vertical lane dividers
    for (int i = 1; i < 3; i++) {
        float x = CENTER_X - ROAD_WIDTH/2.0f + i * laneWidth;
        renderDashedLine(x, 0, x, WINDOW_HEIGHT);
    }

    // Render special lane markings
    renderPriorityLane();
}

void Renderer::renderPriorityLane() {
    using namespace SimConstants;

    // Highlight AL2 priority lane with semi-transparent orange
    SDL_SetRenderDrawColor(renderer, 255, 165, 0, 100);
    float laneWidth = ROAD_WIDTH / 3.0f;

    SDL_FRect priorityLane = {
        0,
        CENTER_Y - laneWidth/2.0f,
        static_cast<float>(CENTER_X - ROAD_WIDTH/2.0f),
        laneWidth
    };

    SDL_RenderFillRect(renderer, &priorityLane);
}

void Renderer::renderTrafficLight(float x, float y, float rotation, LightState state) {
    // Constants for traffic light dimensions
    const float LIGHT_SPACING = 15.0f;        // Space between each light
    const float LIGHT_RADIUS = LIGHT_SIZE/2.0f;

    // Calculate oriented position for the traffic light housing
    float orientedX = x;
    float orientedY = y;

    // Apply rotation if needed to orient the traffic light correctly
    if (rotation != 0.0f) {
        SDL_FPoint rotated = rotatePoint(x, y,
            static_cast<float>(SimConstants::CENTER_X),
            static_cast<float>(SimConstants::CENTER_Y),
            rotation
        );
        orientedX = rotated.x;
        orientedY = rotated.y;
    }

    // Draw the traffic light housing (black background box)
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 255);  // Dark gray color
    SDL_FRect housing = {
        orientedX - HOUSING_PADDING,
        orientedY - HOUSING_PADDING,
        LIGHT_SIZE + (HOUSING_PADDING * 2.0f),
        (LIGHT_SIZE * 3.0f) + (HOUSING_PADDING * 4.0f)  // Room for three lights
    };
    SDL_RenderFillRect(renderer, &housing);

    // Draw outline for the housing
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);  // Lighter gray for border
    SDL_RenderRect(renderer, &housing);

    // Calculate positions for each light
    float centerX = orientedX + LIGHT_SIZE/2.0f;
    float redY = orientedY + LIGHT_SIZE/2.0f;
    float yellowY = redY + LIGHT_SIZE + LIGHT_SPACING;
    float greenY = yellowY + LIGHT_SIZE + LIGHT_SPACING;

    // Draw red light
    SDL_SetRenderDrawColor(renderer,
        state == LightState::RED ? 255 : 64,  // Bright red when active, dim when inactive
        0, 0, 255);
    renderCircle(centerX, redY, LIGHT_RADIUS);

    // Draw yellow light (always dim in two-state system)
    SDL_SetRenderDrawColor(renderer, 64, 64, 0, 255);
    renderCircle(centerX, yellowY, LIGHT_RADIUS);

    // Draw green light
    SDL_SetRenderDrawColor(renderer, 0,
        state == LightState::GREEN ? 255 : 64,  // Bright green when active, dim when inactive
        0, 255);
    renderCircle(centerX, greenY, LIGHT_RADIUS);
}

void Renderer::renderTrafficLights(const std::map<LaneId, TrafficLight>& lights) {
    using namespace SimConstants;

    // Define the standard positions for traffic lights
    struct LightPosition {
        float x;
        float y;
        float rotation;
        LaneId laneId;
    };

    // Define fixed positions for each traffic light
    const LightPosition positions[] = {
        // West approach (AL2 - Priority lane)
        {
            static_cast<float>(CENTER_X - ROAD_WIDTH/2.0f - 50.0f),
            static_cast<float>(CENTER_Y - LIGHT_SIZE * 3.0f),
            0.0f,
            LaneId::AL2_PRIORITY
        },
        // North approach (BL2)
        {
            static_cast<float>(CENTER_X - LIGHT_SIZE * 3.0f),
            static_cast<float>(CENTER_Y - ROAD_WIDTH/2.0f - 50.0f),
            90.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::BL2_NORMAL
        },
        // East approach (CL2)
        {
            static_cast<float>(CENTER_X + ROAD_WIDTH/2.0f + 50.0f),
            static_cast<float>(CENTER_Y - LIGHT_SIZE * 3.0f),
            180.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::CL2_NORMAL
        },
        // South approach (DL2)
        {
            static_cast<float>(CENTER_X - LIGHT_SIZE * 3.0f),
            static_cast<float>(CENTER_Y + ROAD_WIDTH/2.0f + 50.0f),
            270.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::DL2_NORMAL
        }
    };

    // Render each traffic light
    for (const auto& position : positions) {
        auto it = lights.find(position.laneId);
        if (it != lights.end()) {
            renderTrafficLight(
                position.x,
                position.y,
                position.rotation,
                it->second.getState()
            );
        }
    }
}void Renderer::renderVehicles(const std::map<uint32_t, VehicleState>& vehicles) {
    for (const auto& [id, state] : vehicles) {
        float angle = calculateTurningAngle(state);
        renderVehicle(
            state.x, state.y,
            state.direction,
            state.vehicle->getCurrentLane() == LaneId::AL2_PRIORITY,
            angle,
            state.isMoving
        );
    }
}

void Renderer::renderVehicle(float x, float y, Direction dir, bool isPriority, float angle, bool isMoving) {
    const float halfWidth = VEHICLE_WIDTH / 2.0f;
    const float halfHeight = VEHICLE_HEIGHT / 2.0f;

    // Create a smoother vehicle shape
    SDL_FPoint vertices[8] = {
        // Front
        {x + (halfWidth * 0.8f) * cosf(angle), y + (halfWidth * 0.8f) * sinf(angle)},
        // Front right
        {x + halfWidth * cosf(angle + 0.4f), y + halfWidth * sinf(angle + 0.4f)},
        // Right
        {x + halfWidth * cosf(angle + M_PI/2), y + halfWidth * sinf(angle + M_PI/2)},
        // Back right
        {x + halfWidth * cosf(angle + M_PI - 0.4f), y + halfWidth * sinf(angle + M_PI - 0.4f)},
        // Back
        {x - (halfWidth * 0.8f) * cosf(angle), y - (halfWidth * 0.8f) * sinf(angle)},
        // Back left
        {x + halfWidth * cosf(angle + M_PI + 0.4f), y + halfWidth * sinf(angle + M_PI + 0.4f)},
        // Left
        {x + halfWidth * cosf(angle - M_PI/2), y + halfWidth * sinf(angle - M_PI/2)},
        // Front left
        {x + halfWidth * cosf(angle - 0.4f), y + halfWidth * sinf(angle - 0.4f)}
    };

    // Draw shadow
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 100);
    for (int i = 0; i < 8; i++) {
        SDL_RenderLine(renderer,
            vertices[i].x + 2, vertices[i].y + 2,
            vertices[(i + 1) % 8].x + 2, vertices[(i + 1) % 8].y + 2);
    }

    // Vehicle body color
    if (isPriority) {
        SDL_SetRenderDrawColor(renderer, 255, 140, 0, 255); // Orange for priority
    } else {
        SDL_SetRenderDrawColor(renderer, 30, 144, 255, 255); // Blue for normal
    }

    // Draw vehicle body
    for (int i = 0; i < 8; i++) {
        SDL_RenderLine(renderer,
            vertices[i].x, vertices[i].y,
            vertices[(i + 1) % 8].x, vertices[(i + 1) % 8].y);
    }

    // Draw headlights
    SDL_SetRenderDrawColor(renderer, 255, 255, 200, 255);
    renderCircle(vertices[0].x - 5 * cosf(angle + 0.2f),
                vertices[0].y - 5 * sinf(angle + 0.2f), 3);
    renderCircle(vertices[0].x - 5 * cosf(angle - 0.2f),
                vertices[0].y - 5 * sinf(angle - 0.2f), 3);

    // Direction indicators
    if (dir != Direction::STRAIGHT) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 0, 200);
        if (dir == Direction::LEFT) {
            renderCircle(vertices[6].x, vertices[6].y, 4);
        } else {
            renderCircle(vertices[2].x, vertices[2].y, 4);
        }
    }

    // Movement trail
    if (isMoving) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 50);
        float t = static_cast<float>(SDL_GetTicks()) / 1000.0f;
        for (int i = 1; i <= 3; i++) {
            float offset = i * (5.0f + sinf(t * 4.0f) * 2.0f);
            float trailX = x - offset * cosf(angle);
            float trailY = y - offset * sinf(angle);
            renderCircle(trailX, trailY, 2);
        }
    }
}

void Renderer::renderIntersection() {
    using namespace SimConstants;

    // Draw intersection box with slightly darker asphalt
    SDL_SetRenderDrawColor(renderer, 45, 45, 45, 255);
    SDL_FRect intersection = {
        CENTER_X - ROAD_WIDTH/2.0f,
        CENTER_Y - ROAD_WIDTH/2.0f,
        static_cast<float>(ROAD_WIDTH),
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &intersection);

    // Draw intersection guidelines
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 100);

    // Center cross guidelines
    renderDashedLine(
        CENTER_X - ROAD_WIDTH/2.0f, CENTER_Y,
        CENTER_X + ROAD_WIDTH/2.0f, CENTER_Y
    );
    renderDashedLine(
        CENTER_X, CENTER_Y - ROAD_WIDTH/2.0f,
        CENTER_X, CENTER_Y + ROAD_WIDTH/2.0f
    );

    // Draw turning guide arcs
    renderTurningGuides();
}

void Renderer::renderTurningGuides() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 50);
    const int SEGMENTS = 32;
    const float TURN_RADIUS = ROAD_WIDTH / 2.0f;

    // Draw turning guide arcs for each corner
    for (int corner = 0; corner < 4; corner++) {
        float centerX = CENTER_X + ((corner & 1) ? ROAD_WIDTH/4.0f : -ROAD_WIDTH/4.0f);
        float centerY = CENTER_Y + ((corner & 2) ? ROAD_WIDTH/4.0f : -ROAD_WIDTH/4.0f);

        for (int i = 0; i < SEGMENTS; i++) {
            float startAngle = (corner * 90 + i * 90.0f / SEGMENTS) * M_PI / 180.0f;
            float endAngle = (corner * 90 + (i + 1) * 90.0f / SEGMENTS) * M_PI / 180.0f;

            float x1 = centerX + TURN_RADIUS * cosf(startAngle);
            float y1 = centerY + TURN_RADIUS * sinf(startAngle);
            float x2 = centerX + TURN_RADIUS * cosf(endAngle);
            float y2 = centerY + TURN_RADIUS * sinf(endAngle);

            SDL_RenderLine(renderer, x1, y1, x2, y2);
        }
    }
}

void Renderer::renderStopLines() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float STOP_LINE_WIDTH = 8.0f;
    const float OFFSET = ROAD_WIDTH/2.0f - 20.0f;

    // Draw stop lines at each intersection approach
    SDL_FRect stopLines[] = {
        // West approach
        {CENTER_X - OFFSET - STOP_LINE_WIDTH,
         CENTER_Y - LANE_WIDTH,
         STOP_LINE_WIDTH,
         LANE_WIDTH * 2},

        // North approach
        {CENTER_X - LANE_WIDTH,
         CENTER_Y - OFFSET - STOP_LINE_WIDTH,
         LANE_WIDTH * 2,
         STOP_LINE_WIDTH},

        // East approach
        {CENTER_X + OFFSET,
         CENTER_Y - LANE_WIDTH,
         STOP_LINE_WIDTH,
         LANE_WIDTH * 2},

        // South approach
        {CENTER_X - LANE_WIDTH,
         CENTER_Y + OFFSET,
         LANE_WIDTH * 2,
         STOP_LINE_WIDTH}
    };

    for (const auto& line : stopLines) {
        SDL_RenderFillRect(renderer, &line);
    }
}

void Renderer::renderDirectionalArrows() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 128);
    const float ARROW_DISTANCE = 150.0f;

    // Draw direction arrows for each lane
    for (int lane = -1; lane <= 1; lane++) {
        float laneOffset = static_cast<float>(lane * LANE_WIDTH);

        // West approach (right-side driving)
        drawArrow(CENTER_X - ARROW_DISTANCE, CENTER_Y + laneOffset,
                 0.0f, Direction::STRAIGHT);

        // North approach
        drawArrow(CENTER_X + laneOffset, CENTER_Y - ARROW_DISTANCE,
                 static_cast<float>(M_PI / 2), Direction::STRAIGHT);

        // East approach
        drawArrow(CENTER_X + ARROW_DISTANCE, CENTER_Y + laneOffset,
                 static_cast<float>(M_PI), Direction::STRAIGHT);

        // South approach
        drawArrow(CENTER_X + laneOffset, CENTER_Y + ARROW_DISTANCE,
                 static_cast<float>(-M_PI / 2), Direction::STRAIGHT);
    }

    // Add left turn arrows for free lanes
    drawArrow(CENTER_X - ARROW_DISTANCE, CENTER_Y + LANE_WIDTH,
             0.0f, Direction::LEFT);
    drawArrow(CENTER_X + LANE_WIDTH, CENTER_Y - ARROW_DISTANCE,
             static_cast<float>(M_PI / 2), Direction::LEFT);
    drawArrow(CENTER_X + ARROW_DISTANCE, CENTER_Y + LANE_WIDTH,
             static_cast<float>(M_PI), Direction::LEFT);
    drawArrow(CENTER_X + LANE_WIDTH, CENTER_Y + ARROW_DISTANCE,
             static_cast<float>(-M_PI / 2), Direction::LEFT);
}

void Renderer::drawArrow(float x, float y, float angle, Direction dir) {
    const float ARROW_LENGTH = 30.0f;
    const float HEAD_SIZE = 10.0f;
    const float HEAD_ANGLE = static_cast<float>(M_PI / 6);

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    // Draw arrow shaft
    float endX = x + ARROW_LENGTH * cosA;
    float endY = y + ARROW_LENGTH * sinA;
    SDL_RenderLine(renderer, x, y, endX, endY);

    // Draw arrow head
    float leftX = endX - HEAD_SIZE * cosf(angle + HEAD_ANGLE);
    float leftY = endY - HEAD_SIZE * sinf(angle + HEAD_ANGLE);
    float rightX = endX - HEAD_SIZE * cosf(angle - HEAD_ANGLE);
    float rightY = endY - HEAD_SIZE * sinf(angle - HEAD_ANGLE);

    SDL_RenderLine(renderer, endX, endY, leftX, leftY);
    SDL_RenderLine(renderer, endX, endY, rightX, rightY);

    // Add curved arrow for left turns
    if (dir == Direction::LEFT) {
        const float CURVE_RADIUS = 15.0f;
        const int SEGMENTS = 8;

        for (int i = 0; i < SEGMENTS; i++) {
            float startAngle = angle - M_PI/2 + (i * M_PI/2) / SEGMENTS;
            float endAngle = angle - M_PI/2 + ((i + 1) * M_PI/2) / SEGMENTS;

            float x1 = x + CURVE_RADIUS * cosf(startAngle);
            float y1 = y + CURVE_RADIUS * sinf(startAngle);
            float x2 = x + CURVE_RADIUS * cosf(endAngle);
            float y2 = y + CURVE_RADIUS * sinf(endAngle);

            SDL_RenderLine(renderer, x1, y1, x2, y2);
        }
    }
}

void Renderer::renderCircle(float x, float y, float radius) {
    const int SEGMENTS = 16;
    for (int i = 0; i < SEGMENTS; i++) {
        float angle1 = 2.0f * M_PI * i / SEGMENTS;
        float angle2 = 2.0f * M_PI * (i + 1) / SEGMENTS;

        SDL_RenderLine(renderer,
            x + radius * cosf(angle1),
            y + radius * sinf(angle1),
            x + radius * cosf(angle2),
            y + radius * sinf(angle2)
        );
    }
}

void Renderer::renderDashedLine(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    float length = std::sqrt(dx * dx + dy * dy);
    float nx = dx / length;
    float ny = dy / length;

    float x = x1;
    float y = y1;
    bool drawing = true;
    float remainingLength = length;

    while (remainingLength > 0) {
        float segmentLength = std::min(drawing ? DASH_LENGTH : GAP_LENGTH, remainingLength);

        if (drawing) {
            float endX = x + nx * segmentLength;
            float endY = y + ny * segmentLength;
            SDL_RenderLine(renderer, x, y, endX, endY);
        }

        x += nx * segmentLength;
        y += ny * segmentLength;
        remainingLength -= segmentLength;
        drawing = !drawing;
    }
}

void Renderer::cleanup() {
    if (renderer) {
        SDL_DestroyRenderer(renderer);
        renderer = nullptr;
    }
    if (window) {
        SDL_DestroyWindow(window);
        window = nullptr;
    }
    SDL_Quit();
}

float Renderer::calculateTurningAngle(const VehicleState& state) const {
    return atan2f(state.targetY - state.y, state.targetX - state.x);
}

SDL_Color Renderer::getLaneColor(LaneId laneId, bool isActive) const {
    if (isActive) {
        if (laneId == LaneId::AL2_PRIORITY) {
            return {255, 165, 0, 255}; // Orange for active priority lane
        }
        return {0, 255, 0, 255}; // Green for active normal lanes
    }

    if (laneId == LaneId::AL2_PRIORITY) {
        return {255, 165, 0, 128}; // Semi-transparent orange for inactive priority lane
    }
    return {255, 255, 255, 128}; // Semi-transparent white for inactive normal lanes
}

void Renderer::drawDebugGrid() {
    SDL_SetRenderDrawColor(renderer, 128, 128, 128, 64);

    // Draw vertical grid lines
    for (float x = 0.0f; x < static_cast<float>(SimConstants::WINDOW_WIDTH); x += 50.0f) {
        SDL_RenderLine(renderer,
            static_cast<int>(x), 0,
            static_cast<int>(x), SimConstants::WINDOW_HEIGHT
        );
    }

    // Draw horizontal grid lines
    for (float y = 0.0f; y < static_cast<float>(SimConstants::WINDOW_HEIGHT); y += 50.0f) {
        SDL_RenderLine(renderer,
            0, static_cast<int>(y),
            SimConstants::WINDOW_WIDTH, static_cast<int>(y)
        );
    }
}



void Renderer::renderCrosswalks() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float STRIPE_WIDTH = 5.0f;
    const float STRIPE_LENGTH = 30.0f;
    const float STRIPE_GAP = 5.0f;
    const float CROSSWALK_WIDTH = 20.0f;

    // Render crosswalks on all four sides of the intersection
    for (int i = 0; i < 4; ++i) {
        float angle = static_cast<float>(i * 90) * static_cast<float>(M_PI) / 180.0f;
        float baseX = CENTER_X + cosf(angle) * (ROAD_WIDTH / 2.0f - CROSSWALK_WIDTH);
        float baseY = CENTER_Y + sinf(angle) * (ROAD_WIDTH / 2.0f - CROSSWALK_WIDTH);

        // Draw zebra stripes
        for (float offset = 0; offset < ROAD_WIDTH; offset += STRIPE_WIDTH + STRIPE_GAP) {
            SDL_FPoint p1 = rotatePoint(baseX, baseY + offset, CENTER_X, CENTER_Y, angle);
            SDL_FPoint p2 = rotatePoint(baseX + STRIPE_LENGTH, baseY + offset, CENTER_X, CENTER_Y, angle);

            SDL_FRect stripe = {
                p1.x, p1.y,
                STRIPE_WIDTH,
                p2.y - p1.y
            };
            SDL_RenderFillRect(renderer, &stripe);
        }
    }
}

SDL_FPoint Renderer::rotatePoint(float x, float y, float cx, float cy, float angle) {
    // First, translate point back to origin by subtracting center coordinates
    float translatedX = x - cx;
    float translatedY = y - cy;

    // Perform the rotation using the rotation matrix:
    // | cos(θ) -sin(θ) |
    // | sin(θ)  cos(θ) |
    float rotatedX = translatedX * cosf(angle) - translatedY * sinf(angle);
    float rotatedY = translatedX * sinf(angle) + translatedY * cosf(angle);

    // Translate back to original position by adding center coordinates
    SDL_FPoint result = {
        rotatedX + cx,
        rotatedY + cy
    };

    return result;
}

void Renderer::renderPriorityLaneIndicator() {
    using namespace SimConstants;

    // Draw priority mode indicator in top-left corner
    const float INDICATOR_SIZE = 30.0f;
    const float PADDING = 10.0f;

    SDL_SetRenderDrawColor(renderer, 255, 69, 0, 255); // Orange for priority
    SDL_FRect indicator = {
        PADDING,
        PADDING,
        INDICATOR_SIZE,
        INDICATOR_SIZE
    };
    SDL_RenderFillRect(renderer, &indicator);

    // Add pulsing effect
    float t = static_cast<float>(SDL_GetTicks()) / 1000.0f;
    uint8_t alpha = static_cast<uint8_t>(128 + 127 * sinf(t * 2.0f));
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, alpha);
    SDL_RenderRect(renderer, &indicator);
}

void Renderer::renderLaneIdentifiers() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float OFFSET = ROAD_WIDTH / 2.0f + 30.0f;

    // Define lane positions and labels
    struct LaneLabel {
        float x, y;
        LaneId id;
    } labels[] = {
        {CENTER_X - OFFSET, CENTER_Y - LANE_WIDTH, LaneId::AL1_INCOMING},
        {CENTER_X - OFFSET, CENTER_Y, LaneId::AL2_PRIORITY},
        {CENTER_X - OFFSET, CENTER_Y + LANE_WIDTH, LaneId::AL3_FREELANE},

        {CENTER_X - LANE_WIDTH, CENTER_Y - OFFSET, LaneId::BL1_INCOMING},
        {CENTER_X, CENTER_Y - OFFSET, LaneId::BL2_NORMAL},
        {CENTER_X + LANE_WIDTH, CENTER_Y - OFFSET, LaneId::BL3_FREELANE},

        {CENTER_X + OFFSET, CENTER_Y - LANE_WIDTH, LaneId::CL1_INCOMING},
        {CENTER_X + OFFSET, CENTER_Y, LaneId::CL2_NORMAL},
        {CENTER_X + OFFSET, CENTER_Y + LANE_WIDTH, LaneId::CL3_FREELANE},

        {CENTER_X - LANE_WIDTH, CENTER_Y + OFFSET, LaneId::DL1_INCOMING},
        {CENTER_X, CENTER_Y + OFFSET, LaneId::DL2_NORMAL},
        {CENTER_X + LANE_WIDTH, CENTER_Y + OFFSET, LaneId::DL3_FREELANE}
    };

    // Draw background rectangles for labels
    for (const auto& label : labels) {
        SDL_FRect bg = {
            label.x - 25.0f,
            label.y - 12.0f,
            50.0f,
            24.0f
        };

        // Different colors for different lane types
        if (label.id == LaneId::AL2_PRIORITY) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 128); // Orange for priority
        } else if (static_cast<int>(label.id) % 3 == 2) {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 128); // Green for free lanes
        } else {
            SDL_SetRenderDrawColor(renderer, 100, 100, 100, 128); // Gray for normal lanes
        }

        SDL_RenderFillRect(renderer, &bg);
    }
}

void Renderer::renderVehicleCount(const TrafficManager& trafficManager) {
    using namespace SimConstants;

    const float PADDING = 10.0f;
    const float BOX_WIDTH = 150.0f;
    const float BOX_HEIGHT = 80.0f;

    // Draw background panel
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200);
    SDL_FRect countBox = {
        PADDING,
        WINDOW_HEIGHT - BOX_HEIGHT - PADDING,
        BOX_WIDTH,
        BOX_HEIGHT
    };
    SDL_RenderFillRect(renderer, &countBox);

    // Draw separator lines
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 128);
    SDL_RenderLine(renderer,
        countBox.x,
        countBox.y + BOX_HEIGHT / 2.0f,
        countBox.x + BOX_WIDTH,
        countBox.y + BOX_HEIGHT / 2.0f
    );

    // Vehicle counts are rendered here
    // Note: Actual text rendering would require SDL_ttf setup
    // For now, we just show the box layout
}

// End of Renderer.cpp

