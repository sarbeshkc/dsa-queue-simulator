
================================================================================
File: include\core\Constants.h
================================================================================

// include/core/Constants.h
#pragma once
#include <cstdint>
#include <cmath>

enum class LaneId {
    AL1_INCOMING,
    AL2_PRIORITY,
    AL3_FREELANE,
    BL1_INCOMING,
    BL2_NORMAL,
    BL3_FREELANE,
    CL1_INCOMING,
    CL2_NORMAL,
    CL3_FREELANE,
    DL1_INCOMING,
    DL2_NORMAL,
    DL3_FREELANE
};

enum class Direction {
    STRAIGHT,
    LEFT,
    RIGHT
};

enum class LightState {
    RED,
    GREEN
};

namespace SimConstants {
    // Queue and priority thresholds
    static constexpr float VEHICLE_LENGTH = 50.0f;  // Length of vehicle for queue spacing
    static constexpr size_t PRIORITY_THRESHOLD = 10;     // Switch to priority mode at 10 vehicles
    static constexpr size_t NORMAL_THRESHOLD = 5;        // Return to normal mode at 5 vehicles

    // Window and Display
    static constexpr int WINDOW_WIDTH = 1280;
    static constexpr int WINDOW_HEIGHT = 960;
    static constexpr int CENTER_X = WINDOW_WIDTH / 2;
    static constexpr int CENTER_Y = WINDOW_HEIGHT / 2;

    // Road and Lane Configuration
    static constexpr int ROAD_WIDTH = 360;     // Width for 3 lanes
    static constexpr int LANE_WIDTH = 120;     // Individual lane width
    static constexpr float QUEUE_SPACING = 60.0f;
    static constexpr float QUEUE_START_OFFSET = 200.0f;
    static constexpr float QUEUE_START = ROAD_WIDTH / 2.0f + 50.0f;  // Where queues start from intersection
    static constexpr float LANE_OFFSET = ROAD_WIDTH / 6.0f;  // Half of lane width

    // Vehicle Configuration
    static constexpr float VEHICLE_WIDTH = 40.0f;
    static constexpr float VEHICLE_HEIGHT = 30.0f;
    static constexpr float VEHICLE_BASE_SPEED = 50.0f;
    static constexpr float VEHICLE_TURN_SPEED = 30.0f;
    static constexpr float VEHICLE_MIN_SPACING = 60.0f;
    static constexpr float VEHICLE_ACCEL_RATE = 2.0f;
    static constexpr float VEHICLE_DECEL_RATE = 4.0f;

    // Added for animation
    static constexpr float TURN_SPEED = 0.5f;  // Speed at which turns progress

    // Traffic Light Configuration
    static constexpr float LIGHT_SIZE = 40.0f;
    static constexpr float LIGHT_SPACING = 60.0f;

    // Intersection Configuration
    static constexpr float INTERSECTION_RADIUS = 180.0f;
    static constexpr float TURN_GUIDE_RADIUS = 150.0f;

    // System Timing
    static constexpr int FILE_CHECK_INTERVAL = 100;    // ms
    static constexpr int TRAFFIC_UPDATE_INTERVAL = 50; // ms
    static constexpr float VEHICLE_PROCESS_TIME = 3.0f; // seconds
    static constexpr float TURN_ENTRY_DISTANCE = 100.0f;
    static constexpr float TURN_EXIT_DISTANCE = 100.0f;

    // Intersection Configuration
    static constexpr float INTERSECTION_SIZE = 360.0f;
    static constexpr float STOP_LINE_OFFSET = 20.0f;
    static constexpr float CROSSWALK_WIDTH = 30.0f;
    static constexpr float MAX_WAIT_TIME = 30.0f;
    static constexpr float MIN_VEHICLE_SPACING = 60.0f;
    static constexpr float MIN_STATE_TIME = 5.0f;        // Minimum time in any state
    static constexpr float MAX_STATE_TIME = 30.0f;       // Maximum time in any state

    // Frame rate control
    static constexpr float UPDATE_INTERVAL = 0.016f;  // ~60 FPS
};;


================================================================================
File: include\core\Lane.h
================================================================================

// include/core/Lane.h
#pragma once
#include "Vehicle.h"
#include "utils/Queue.h"
#include <memory>
#include <string>

class Lane {
private:
    LaneId id;
    Queue<std::shared_ptr<Vehicle>> vehicleQueue;
    bool isPriority;
    std::string dataFile;
    float waitTime;  // Track the average wait time for this lane
    bool isFreeLane;  // Flag for 3rd lanes that can freely turn left

public:
    Lane(LaneId id, bool isPriority);

    void addVehicle(std::shared_ptr<Vehicle> vehicle);
    std::shared_ptr<Vehicle> removeVehicle();
    Direction getVehicleDirection(size_t index) const;
    size_t getQueueSize() const;
    bool isPriorityLane() const;
    LaneId getId() const;
    const std::string& getDataFile() const;
    void update(float deltaTime);
    bool isFreeLaneType() const;
    float getAverageWaitTime() const;
    void updateVehicleWaitTimes(float deltaTime);
    bool exceedsPriorityThreshold() const;  // Check if lane exceeds priority threshold
    bool isBelowNormalThreshold() const;    // Check if lane is below normal threshold
};
;


================================================================================
File: include\core\TrafficLight.h
================================================================================

// include/core/TrafficLight.h
#pragma once
#include <SDL3/SDL.h>
#include "Constants.h"
#include <cstdint>

class TrafficLight {
private:
    LightState state;                // Current light state
    LightState nextState;            // Next scheduled state
    float transitionProgress;        // Progress of state transition (0-1)
    float transitionDuration;        // Duration of transition animation
    float stateTimer;                // Timer for current state
    bool isTransitioning;            // Whether in transition between states
    float currentStateDuration;      // Duration for current state
    bool isPriorityMode;             // Whether in priority mode
    bool isForced;                   // Whether state is being forced
    LaneId controlledLane;           // The lane this light controls

    // Private methods
    void startTransition(LightState newState);
    float getNextStateDuration() const;

public:
    TrafficLight(LaneId lane = LaneId::AL2_PRIORITY);  // Default to priority lane

    // Core state management
    void update(float deltaTime);
    void setState(LightState newState);
    LightState getState() const { return state; }
    void forceState(LightState newState, bool force = true);
    void setPriorityMode(bool enabled);
    LaneId getControlledLane() const { return controlledLane; }

    // State query methods
    bool isInTransition() const { return isTransitioning; }
    float getTransitionProgress() const { return transitionProgress; }
    float getStateTimer() const { return stateTimer; }
    float getStateDuration() const;

    // Rendering
    void render(SDL_Renderer* renderer, float x, float y) const;
};


================================================================================
File: include\core\Vehicle.h
================================================================================

// include/core/Vehicle.h
#pragma once
#include "core/Constants.h"
#include <cstdint>
#include <chrono>
#include <memory>
#include <string>

class Vehicle {
private:
    uint32_t id;
    Direction direction;
    LaneId currentLane;
    LaneId targetLane;  // Added for lane transitions
    float waitTime;
    bool isProcessing;
    float turnProgress;
    bool hasStartedTurn;
    float speed;
    float position;
    std::chrono::steady_clock::time_point entryTime;
    bool isEmergency;
    bool turning;

    // Animation state variables
    struct AnimationState {
        float x;             // Current X position
        float y;             // Current Y position
        float targetX;       // Target X position
        float targetY;       // Target Y position
        float angle;         // Current angle/rotation
        float targetAngle;   // Target angle
        float turnPosX;      // Position during turn
        float turnPosY;      // Position during turn
        float turnCenter_x;  // Center of turn circle X
        float turnCenter_y;  // Center of turn circle Y
        float startAngle;    // Start angle for turn
        float endAngle;      // End angle for turn
        float turnRadius;    // Radius of turn
    };

    AnimationState pos;  // Animation position state

public:
    Vehicle(uint32_t vehicleId, Direction dir, LaneId lane, bool emergency = false);

    // Core accessors
    uint32_t getId() const { return id; }
    Direction getDirection() const { return direction; }
    LaneId getCurrentLane() const { return currentLane; }
    LaneId getTargetLane() const { return targetLane; }
    bool isInProcess() const { return isProcessing; }
    float getWaitTime() const { return waitTime; }
    float getTurnProgress() const { return turnProgress; }
    bool hasTurnStarted() const { return hasStartedTurn; }
    float getSpeed() const { return speed; }
    float getPosition() const { return position; }
    bool isEmergencyVehicle() const { return isEmergency; }
    bool isTurning() const { return turning; }

    // Animation state getters
    float getX() const { return pos.x; }
    float getY() const { return pos.y; }
    float getAngle() const { return pos.angle; }
    float getTargetX() const { return pos.targetX; }
    float getTargetY() const { return pos.targetY; }
    float getTargetAngle() const { return pos.targetAngle; }
    float getTurnPosX() const { return pos.turnPosX; }
    float getTurnPosY() const { return pos.turnPosY; }

    // State modifiers
    void setProcessing(bool processing);
    void updateWaitTime(float delta);
    void updateTurnProgress(float delta);
    void startTurn();
    void setSpeed(float newSpeed);
    void setPosition(float pos);
    void setTargetLane(LaneId lane) { targetLane = lane; }
    void setTurning(bool isTurning) { turning = isTurning; }

    // Movement control
    void setTargetPosition(float x, float y, float angle);
    void updateMovement(float deltaTime);
    bool hasReachedTarget() const;

    // Turn animation
    void setupTurn(float centerX, float centerY, float radius, float startAng, float endAng);
    void updateTurn(float deltaTime);
    void setTurnPosition(float x, float y);

    // Calculate turn parameters based on lane/direction
    void calculateTurnParameters(float roadWidth, float laneWidth, float centerX, float centerY);
    float calculateTurnRadius() const;

    // Static helpers
    static float calculateLanePosition(LaneId lane, size_t queuePosition);
    static float calculateTurnAngle(Direction dir, LaneId fromLane, LaneId toLane);

    // Queue metrics
    std::chrono::steady_clock::time_point getEntryTime() const { return entryTime; }
    float getTimeInSystem() const;

    // Debug helper
    std::string toString() const;
};


================================================================================
File: include\managers\FileHandler.h
================================================================================

// include/managers/FileHandler.h
#pragma once
#include "core/Vehicle.h"
#include "core/Constants.h"
#include <memory>
#include <vector>
#include <string>
#include <map>
#include <filesystem>
#include <chrono>
#include <mutex>

class FileHandler {
public:
    FileHandler();
    ~FileHandler() = default;

    // Core file operations
    std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> readNewVehicles();
    void clearLaneFiles();

    // State queries
    bool isLaneFileAvailable(LaneId laneId) const;
    size_t getVehicleCountInFile(LaneId laneId) const;
    std::chrono::system_clock::time_point getLastModifiedTime(LaneId laneId) const;

private:
    std::map<LaneId, std::filesystem::path> laneFiles;
    std::filesystem::path dataDir;
    std::filesystem::path vehicleDataFile; // Single file for all vehicles
    std::mutex fileMutex;

    static constexpr int FILE_CHECK_INTERVAL_MS = 100;
    static const std::string BASE_PATH;

    // File operation methods
    void initializeFileSystem();
    void validateFileSystem() const;
    std::vector<std::shared_ptr<Vehicle>> parseVehicleData(const std::string& data, LaneId laneId);
    std::shared_ptr<Vehicle> parseVehicleLine(const std::string& line, LaneId laneId);

    // Helper methods
    std::filesystem::path getLaneFilePath(LaneId laneId) const;
    void ensureDirectoryExists(const std::filesystem::path& dir);
    void logFileOperation(const std::string& operation, const std::filesystem::path& filepath) const;
    void handleFileError(const std::string& operation, const std::filesystem::path& filepath, const std::exception& e) const;
};


================================================================================
File: include\managers\IntersectionController.h
================================================================================

// IntersectionController.h
#pragma once

#include "core/Lane.h"
#include "core/Vehicle.h"
#include "utils/PriorityQueue.h"
#include <vector>
#include <memory>
#include <cmath>

class IntersectionController {
public:
    // Public types for status reporting
    struct LaneStatus {
        LaneId id;
        size_t queueSize;
        int priority;
        bool isActive;
        float waitTime;
    };

    struct ProcessingStats {
        float avgWaitTime;
        size_t totalVehiclesProcessed;
        size_t currentQueueSizes[12]; // One for each lane
        bool isPriorityMode;
    };

    // Constructor
    explicit IntersectionController(std::vector<std::unique_ptr<Lane>>& lanes);

    // Core update method
    void update(float deltaTime);

    // State query methods
    bool isInPriorityMode() const { return isPriorityMode; }
    std::vector<LaneStatus> getLaneStatuses() const;
    ProcessingStats getStats() const;

private:
    // Core components
    std::vector<std::unique_ptr<Lane>>& lanes;
    PriorityQueue<LaneId> laneQueue;

    // State tracking
    bool isPriorityMode;
    float stateTimer;
    float elapsedTime;
    float processingTimer;
    size_t vehiclesProcessedInState;
    size_t totalVehiclesProcessed;

    // Configuration constants
    static constexpr size_t PRIORITY_THRESHOLD = 10;     // Switch to priority mode at 10 vehicles
    static constexpr size_t PRIORITY_RELEASE_THRESHOLD = 5; // Return to normal mode at 5 vehicles
    static constexpr float MIN_STATE_TIME = 5.0f;        // Minimum time in any state
    static constexpr float MAX_STATE_TIME = 30.0f;       // Maximum time in any state
    static constexpr float MAX_WAIT_TIME = 45.0f;        // Maximum vehicle wait time
    static constexpr float BASE_VEHICLE_PROCESS_TIME = 2.0f; // Base time to process one vehicle

    // Queue management methods
    void updateLaneQueue();
    void processPriorityLane();
    void processNormalLanes();
    void processFreeLanes();
    size_t calculateVehiclesToProcess() const;

    // State management methods
    void handleStateTransition();
    void checkWaitTimes();
    void updateTimers(float deltaTime);
    void resetStateTimers();

    // Utility methods
    float calculateAverageWaitingVehicles() const;
    float calculateProcessingTime() const;
    bool shouldSwitchToNormalMode() const;
    bool shouldSwitchToPriorityMode() const;
    Lane* getPriorityLane() const;
    bool isFreeLane(LaneId id) const;
    int calculateLanePriority(const Lane& lane) const;
};


================================================================================
File: include\managers\TrafficManager.h
================================================================================

// include/managers/TrafficManager.h
#pragma once
#include "core/Constants.h"
#include "core/Lane.h"
#include "core/TrafficLight.h"
#include "core/Vehicle.h"
#include "managers/FileHandler.h"
#include "utils/PriorityQueue.h"
#include <vector>
#include <memory>
#include <map>
#include <chrono>

class TrafficManager {
public:
    TrafficManager();
    ~TrafficManager() = default;

    // Core update methods
    void update(float deltaTime);
    void addVehicleToLane(LaneId laneId, std::shared_ptr<Vehicle> vehicle);
    size_t getLaneSize(LaneId laneId) const;

    // State queries
    bool isInPriorityMode() const { return inPriorityMode; }
    const std::vector<std::unique_ptr<Lane>>& getLanes() const { return lanes; }
    const std::map<LaneId, TrafficLight>& getTrafficLights() const { return trafficLights; }
    const std::map<uint32_t, std::shared_ptr<Vehicle>>& getActiveVehicles() const { return activeVehicles; }

    // Stats queries
    float getAverageWaitingTime() const;
    size_t getTotalVehiclesProcessed() const { return totalVehiclesProcessed; }

private:
    // Core components
    std::vector<std::unique_ptr<Lane>> lanes;
    std::map<LaneId, TrafficLight> trafficLights;
    std::map<uint32_t, std::shared_ptr<Vehicle>> activeVehicles;
    FileHandler fileHandler;
    PriorityQueue<LaneId> laneQueue;

    // State tracking
    bool inPriorityMode;
    float stateTimer;
    float lastUpdateTime;
    float processingTimer;
    size_t totalVehiclesProcessed;
    float averageWaitTime;

    // Traffic flow methods
    void processNewVehicles();
    void processPriorityLane();
    void processNormalLanes(size_t vehicleCount);
    void processFreeLanes();
    void checkWaitTimes();
    size_t calculateVehiclesToProcess() const;
    void updateVehiclePositions(float deltaTime);
    void updateLaneQueue();
    bool checkCollision(const std::shared_ptr<Vehicle>& vehicle, float newX, float newY) const;

    // Traffic light methods
    void updateTrafficLights(float deltaTime);
    void synchronizeTrafficLights();
    void handleStateTransition(float deltaTime);
    bool checkPriorityConditions() const;
    bool canVehicleMove(const std::shared_ptr<Vehicle>& vehicle) const;
    LightState getLightStateForLane(LaneId laneId) const;

    // Vehicle processing
    void updateVehicleTurns(float deltaTime);
    LaneId determineOptimalLane(Direction direction, LaneId sourceLane) const;
    bool isValidSpawnLane(LaneId laneId, Direction direction) const;
    bool isFreeLane(LaneId laneId) const;
    Lane* getPriorityLane() const;
    void removeVehicle(uint32_t vehicleId);
    void setupVehicleTurn(std::shared_ptr<Vehicle> vehicle);

    // Utility methods
    void updateTimers(float deltaTime);
    void updateStatistics(float deltaTime);
    void cleanupFinishedVehicles();
};


================================================================================
File: include\traffic_generator.h
================================================================================

// include/traffic_generator.h
#pragma once
#include <string>
#include <random>
#include <map>
#include <filesystem>
#include <fstream>
#include <thread>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <mutex>

// Define constants similar to those in the main project
namespace Constants {
    static constexpr int MAX_QUEUE_SIZE = 100;
    static constexpr int PRIORITY_THRESHOLD = 10;
    static constexpr int NORMAL_THRESHOLD = 5;

    // Lane IDs (matching the main project)
    enum class LaneId {
        AL1_INCOMING = 0,
        AL2_PRIORITY = 1,
        AL3_FREELANE = 2,
        BL1_INCOMING = 3,
        BL2_NORMAL = 4,
        BL3_FREELANE = 5,
        CL1_INCOMING = 6,
        CL2_NORMAL = 7,
        CL3_FREELANE = 8,
        DL1_INCOMING = 9,
        DL2_NORMAL = 10,
        DL3_FREELANE = 11
    };

    // Direction values
    enum class Direction {
        STRAIGHT = 0,
        LEFT = 1,
        RIGHT = 2
    };
}

// Generator class to create vehicle data
class Generator {
private:
    std::mt19937 rng;  // Random number generator
    std::map<Constants::LaneId, std::filesystem::path> laneFiles;  // Lane file paths
    uint32_t nextVehicleId;  // ID counter for vehicles
    std::filesystem::path dataDir;  // Directory for data files
    std::mutex fileMutex;  // Thread safety for file operations

    // Settings for each lane
    struct LaneConfig {
        double spawnRate;
        int maxVehicles;
        bool canGoStraight;
        bool canGoLeft;
        bool canGoRight;
    };
    std::map<Constants::LaneId, LaneConfig> laneConfigs;

    // Private helper methods
    void initializeLaneFiles();
    void setupLaneConfigs();
    Constants::Direction getRandomDirection(const LaneConfig& config);
    size_t countVehiclesInFile(const std::filesystem::path& filepath) const;
    void writeVehicleToFile(const std::filesystem::path& filepath, uint32_t id,
                          Constants::Direction dir);
    void writeVehicleToCombinedFile(Constants::LaneId lane, uint32_t id);
    bool shouldGenerateVehicle(const LaneConfig& config, size_t currentCount);
    void clearAllFiles();
    void logGeneration(Constants::LaneId lane, uint32_t vehicleId, Constants::Direction dir,
                     size_t currentCount, int maxCount);

public:
    Generator();

    // Generate traffic for all lanes
    void generateTraffic();

    // Display generator status
    void displayStatus() const;
};


================================================================================
File: include\utils\PriorityQueue.h
================================================================================

// include/utils/PriorityQueue.h with recursive mutex
#pragma once
#include "Queue.h"
#include <vector>

template <typename T>
class PriorityQueue : public Queue<T> {
private:
  struct PriorityNode : public Queue<T>::Node {
    int priority;
    PriorityNode(const T &value, int p) : Queue<T>::Node(value), priority(p) {}
  };

public:
  // Inheriting constructors
  using Queue<T>::Queue;

  // We need to explicitly delete copy constructor and assignment
  PriorityQueue(const PriorityQueue&) = delete;
  PriorityQueue& operator=(const PriorityQueue&) = delete;

  // And explicitly define move constructor and assignment
  PriorityQueue(PriorityQueue&& other) noexcept : Queue<T>(std::move(other)) {}

  PriorityQueue& operator=(PriorityQueue&& other) noexcept {
    Queue<T>::operator=(std::move(other));
    return *this;
  }

  // Enqueue with priority - higher priority values are dequeued first
  void enqueuePriority(const T &value, int priority) {
    std::lock_guard<std::recursive_mutex> lock(this->mutex);

    auto newNode = std::make_shared<PriorityNode>(value, priority);

    if (this->isEmpty() ||
        static_cast<PriorityNode *>(this->front.get())->priority < priority) {
      newNode->next = this->front;
      this->front = newNode;
    } else {
      auto current = this->front;
      while (current->next &&
             static_cast<PriorityNode *>(current->next.get())->priority >=
                 priority) {
        current = current->next;
      }
      newNode->next = current->next;
      current->next = newNode;
    }
    this->size++;
  }

  // Get the priority of the first item (highest priority) without removing it
  int peekPriority() const {
    std::lock_guard<std::recursive_mutex> lock(this->mutex);

    if (this->isEmpty()) {
      throw std::runtime_error("Queue is empty");
    }
    return static_cast<PriorityNode *>(this->front.get())->priority;
  }

  // Get the priority of an item at a specific index
  int getPriorityAt(size_t index) const {
    std::lock_guard<std::recursive_mutex> lock(this->mutex);

    if (index >= this->size) {
      throw std::out_of_range("Index out of bounds");
    }

    auto current = this->front;
    for (size_t i = 0; i < index; i++) {
      current = current->next;
    }
    return static_cast<PriorityNode *>(current.get())->priority;
  }

  // Update the priority of an item that matches the given value
  // Returns true if at least one item was updated
  bool updatePriority(const T &value, int newPriority) {
    std::lock_guard<std::recursive_mutex> lock(this->mutex);

    if (this->isEmpty()) {
      return false;
    }

    // Find and remove all matching items
    std::vector<T> removedItems;
    auto current = this->front;
    auto prev = std::shared_ptr<typename Queue<T>::Node>(nullptr);

    while (current) {
      if (current->data == value) {
        if (prev) {
          prev->next = current->next;
        } else {
          this->front = current->next;
        }

        if (current == this->rear) {
          this->rear = prev;
        }

        removedItems.push_back(current->data);
        this->size--;

        auto next = current->next;
        current = next;
      } else {
        prev = current;
        current = current->next;
      }
    }

    // Re-add all removed items with the new priority
    for (const auto& item : removedItems) {
      enqueuePriority(item, newPriority);
    }

    return !removedItems.empty();
  }
};


================================================================================
File: include\utils\Queue.h
================================================================================

// include/utils/Queue.h with recursive mutex
#pragma once
#include <memory>
#include <stdexcept>
#include <mutex>

template<typename T>
class Queue {
protected:
    struct Node {
        T data;
        std::shared_ptr<Node> next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::shared_ptr<Node> front;
    std::shared_ptr<Node> rear;
    size_t size;
    mutable std::recursive_mutex mutex; // Changed to recursive mutex to prevent deadlocks

public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}

    virtual ~Queue() = default;

    // Delete copy constructor and assignment operator due to mutex
    Queue(const Queue&) = delete;
    Queue& operator=(const Queue&) = delete;

    // Add move constructor and move assignment
    Queue(Queue&& other) noexcept
        : front(std::move(other.front)),
          rear(std::move(other.rear)),
          size(other.size) {
        other.size = 0;
    }

    Queue& operator=(Queue&& other) noexcept {
        if (this != &other) {
            front = std::move(other.front);
            rear = std::move(other.rear);
            size = other.size;
            other.size = 0;
        }
        return *this;
    }

    void enqueue(const T& value) {
        std::lock_guard<std::recursive_mutex> lock(mutex);

        auto newNode = std::make_shared<Node>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    T dequeue() {
        std::lock_guard<std::recursive_mutex> lock(mutex);

        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    // Method that dequeues without locking (for internal use)
    T dequeueUnlocked() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    bool isEmpty() const {
        std::lock_guard<std::recursive_mutex> lock(mutex);
        return front == nullptr;
    }

    size_t getSize() const {
        std::lock_guard<std::recursive_mutex> lock(mutex);
        return size;
    }

    T peek() const {
        std::lock_guard<std::recursive_mutex> lock(mutex);

        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return front->data;
    }

    // Add index-based peek
    T peek(size_t index) const {
        std::lock_guard<std::recursive_mutex> lock(mutex);

        if (size == 0 || index >= size) {
            throw std::out_of_range("Index out of bounds");
        }

        auto current = front;
        for (size_t i = 0; i < index; i++) {
            current = current->next;
        }
        return current->data;
    }
};


================================================================================
File: include\visualization\DebugOverlay.h
================================================================================

// DebugOverlay.h
#pragma once
#include <SDL3/SDL.h>
#include <cmath>
#include "managers/TrafficManager.h"
#include <map>

class DebugOverlay {
private:
    struct LaneStatistics {
        int vehicleCount;
        float avgWaitTime;
        int processedCount;
    };

    std::map<LaneId, LaneStatistics> stats;
    void updateStatistics(const TrafficManager& trafficManager);
    void renderQueueStats(SDL_Renderer* renderer, int x, int y);
    void renderLaneLoadIndicator(SDL_Renderer* renderer, int x, int y);
    void renderSystemStatus(SDL_Renderer* renderer, int x, int y);

public:
    DebugOverlay() = default;
    void render(SDL_Renderer* renderer, const TrafficManager& trafficManager);
};


================================================================================
File: include\visualization\Renderer.h
================================================================================

/// include/visualization/Renderer.h
#pragma once

// Core SDL includes
#include <SDL3/SDL.h>

// Project includes
#include "managers/TrafficManager.h"
#include "core/Constants.h"

// Standard library includes
#include <memory>
#include <map>
#include <cmath>

/**
 * @class Renderer
 * @brief Handles visualization for the traffic simulation system
 */
class Renderer {
private:
    // Core SDL components
    SDL_Window* window;
    SDL_Renderer* renderer;

    // Debug components
    bool debugMode;
    bool showGrid;

    // Rendering constants
    static constexpr float VEHICLE_WIDTH = 40.0f;
    static constexpr float VEHICLE_HEIGHT = 30.0f;
    static constexpr float LIGHT_SIZE = 20.0f;
    static constexpr float ARROW_SIZE = 30.0f;
    static constexpr float DASH_LENGTH = 20.0f;
    static constexpr float GAP_LENGTH = 20.0f;
    static constexpr float HOUSING_PADDING = 5.0f;

    // Environment rendering methods
    void renderBackground();
    void renderGrassAreas();
    void renderRoads();
    void renderRoadEdges();
    void renderLanes();
    void renderIntersection();
    void renderCrosswalks();
    void renderStopLines();

    // Traffic elements rendering
    void renderDirectionalArrows();
    void renderTrafficLights(const std::map<LaneId, TrafficLight>& lights);
    void renderTrafficLight(float x, float y, float rotation, LightState state);
    void renderVehicles(const std::map<uint32_t, std::shared_ptr<Vehicle>>& vehicles);
    void renderVehicle(float x, float y, Direction dir, bool isPriority, float angle, bool isMoving);
    void renderPriorityLane();
    void renderPriorityLaneIndicator();
    void renderTurningGuides();

    // Debug visualization
    void renderLaneIdentifiers();
    void renderVehicleCount(const TrafficManager& trafficManager);
    void drawDebugGrid();

    // Helper methods
    void drawArrow(float x, float y, float angle, Direction dir);
    void renderCircle(float x, float y, float radius);
    void renderDashedLine(float x1, float y1, float x2, float y2);
    void renderRoundedRect(float x, float y, float w, float h, float radius);
    SDL_FPoint rotatePoint(float x, float y, float cx, float cy, float angle);
    float calculateTurningAngle(float targetX, float targetY, float currentX, float currentY) const;
    SDL_Color getLaneColor(LaneId laneId, bool isActive) const;

public:
    // Constructor and destructor
    Renderer();
    ~Renderer();

    // Core methods
    bool initialize();
    void render(const TrafficManager& trafficManager);
    void cleanup();
    bool isInitialized() const { return window != nullptr && renderer != nullptr; }

    // Configuration methods
    void setDebugMode(bool enabled) { debugMode = enabled; }
    void toggleGridDisplay() { showGrid = !showGrid; }
    void updateWindowSize(int width, int height);
};


================================================================================
File: src\common\types.h
================================================================================

// src/common/types.h
#pragma once
#include <cstdint>
#include <string>

enum class LaneId {
    AL1_INCOMING,
    AL2_PRIORITY,
    AL3_FREELANE,
    BL1_INCOMING,
    BL2_NORMAL,
    BL3_FREELANE,
    CL1_INCOMING,
    CL2_NORMAL,
    CL3_FREELANE,
    DL1_INCOMING,
    DL2_NORMAL,
    DL3_FREELANE
};

enum class LightState {
    RED,
    GREEN
};

;


================================================================================
File: src\common\vector2d.h
================================================================================

// src/utils/vector2d.h
#pragma once

struct Vector2D {
    float x;
    float y;

    Vector2D() : x(0.0f), y(0.0f) {}
    Vector2D(float x, float y) : x(x), y(y) {}

    Vector2D operator+(const Vector2D& other) const {
        return Vector2D(x + other.x, y + other.y);
    }

    Vector2D operator*(float scalar) const {
        return Vector2D(x * scalar, y * scalar);
    }
};



================================================================================
File: src\core\Lane.cpp
================================================================================


// src/core/Lane.cpp
#include "core/Lane.h"
#include "core/Constants.h"
#include <filesystem>
#include <algorithm>

Lane::Lane(LaneId id, bool isPriority)
    : id(id), isPriority(isPriority), waitTime(0.0f)
{
    // Determine if this is a free lane (lane 3 of each road)
    isFreeLane = (
        id == LaneId::AL3_FREELANE ||
        id == LaneId::BL3_FREELANE ||
        id == LaneId::CL3_FREELANE ||
        id == LaneId::DL3_FREELANE
    );

    // Set up data file path based on lane ID
    std::string lanePrefix;
    switch(id) {
        case LaneId::AL1_INCOMING: lanePrefix = "a1"; break;
        case LaneId::AL2_PRIORITY: lanePrefix = "a2"; break;
        case LaneId::AL3_FREELANE: lanePrefix = "a3"; break;
        case LaneId::BL1_INCOMING: lanePrefix = "b1"; break;
        case LaneId::BL2_NORMAL: lanePrefix = "b2"; break;
        case LaneId::BL3_FREELANE: lanePrefix = "b3"; break;
        case LaneId::CL1_INCOMING: lanePrefix = "c1"; break;
        case LaneId::CL2_NORMAL: lanePrefix = "c2"; break;
        case LaneId::CL3_FREELANE: lanePrefix = "c3"; break;
        case LaneId::DL1_INCOMING: lanePrefix = "d1"; break;
        case LaneId::DL2_NORMAL: lanePrefix = "d2"; break;
        case LaneId::DL3_FREELANE: lanePrefix = "d3"; break;
        default: lanePrefix = "unknown";
    }
    dataFile = "data/lanes/lane_" + lanePrefix + ".txt";
}

Direction Lane::getVehicleDirection(size_t index) const {
    if (index >= vehicleQueue.getSize()) {
        return Direction::STRAIGHT;  // Default direction
    }

    return vehicleQueue.peek(index)->getDirection();
}

void Lane::addVehicle(std::shared_ptr<Vehicle> vehicle) {
    vehicleQueue.enqueue(vehicle);
}

std::shared_ptr<Vehicle> Lane::removeVehicle() {
    if (vehicleQueue.isEmpty()) return nullptr;
    return vehicleQueue.dequeue();
}

size_t Lane::getQueueSize() const {
    return vehicleQueue.getSize();
}

bool Lane::isPriorityLane() const {
    return isPriority;
}

LaneId Lane::getId() const {
    return id;
}

const std::string& Lane::getDataFile() const {
    return dataFile;
}

bool Lane::isFreeLaneType() const {
    return isFreeLane;
}

void Lane::update(float deltaTime) {
    // Update wait times for vehicles
    updateVehicleWaitTimes(deltaTime);

    // Free lanes (3rd lane of each road) process vehicles immediately
    if (isFreeLane) {
        while (!vehicleQueue.isEmpty()) {
            removeVehicle();
        }
    }
}

void Lane::updateVehicleWaitTimes(float deltaTime) {
    size_t count = vehicleQueue.getSize();
    if (count == 0) return;

    float totalWaitTime = 0.0f;
    for (size_t i = 0; i < count; i++) {
        auto vehicle = vehicleQueue.peek(i);
        vehicle->updateWaitTime(deltaTime);
        totalWaitTime += vehicle->getWaitTime();
    }

    // Update average wait time
    waitTime = totalWaitTime / static_cast<float>(count);
}

float Lane::getAverageWaitTime() const {
    return waitTime;
}

bool Lane::exceedsPriorityThreshold() const {
    return isPriority && vehicleQueue.getSize() > SimConstants::PRIORITY_THRESHOLD;
}

bool Lane::isBelowNormalThreshold() const {
    return isPriority && vehicleQueue.getSize() < SimConstants::NORMAL_THRESHOLD;
}


================================================================================
File: src\core\TrafficLight.cpp
================================================================================

// src/core/TrafficLight.cpp
#include "core/TrafficLight.h"
#include <cmath>

TrafficLight::TrafficLight(LaneId lane)
    : state(LightState::RED)
    , nextState(LightState::RED)
    , transitionProgress(0.0f)
    , transitionDuration(1.0f)
    , stateTimer(0.0f)
    , isTransitioning(false)
    , currentStateDuration(30.0f)  // Default duration
    , isPriorityMode(false)
    , isForced(false)
    , controlledLane(lane)
{
}

void TrafficLight::update(float deltaTime) {
    // Don't update if state is being forced
    if (isForced) {
        return;
    }

    stateTimer += deltaTime;

    if (isTransitioning) {
        // Handle transition animation
        transitionProgress += deltaTime / transitionDuration;
        if (transitionProgress >= 1.0f) {
            state = nextState;
            isTransitioning = false;
            transitionProgress = 0.0f;
            stateTimer = 0.0f;
            currentStateDuration = getNextStateDuration();
        }
    }
    else if (stateTimer >= currentStateDuration) {
        // Time to change state
        LightState newState = (state == LightState::RED) ? LightState::GREEN : LightState::RED;
        startTransition(newState);
    }
}

void TrafficLight::setState(LightState newState) {
    if (state != newState && !isTransitioning) {
        startTransition(newState);
    }
}

void TrafficLight::forceState(LightState newState, bool force) {
    isForced = force;
    if (force) {
        state = newState;
        nextState = newState;
        isTransitioning = false;
        transitionProgress = 0.0f;
        stateTimer = 0.0f;
    } else {
        isForced = false;
        setState(newState);
    }
}

void TrafficLight::setPriorityMode(bool enabled) {
    isPriorityMode = enabled;
    // Adjust timings when priority mode changes
    currentStateDuration = getStateDuration();
}

float TrafficLight::getStateDuration() const {
    if (isPriorityMode) {
        // In priority mode, A2 gets longer green, others longer red
        if (controlledLane == LaneId::AL2_PRIORITY) {
            return (state == LightState::GREEN) ? 40.0f : 10.0f;
        } else {
            return (state == LightState::GREEN) ? 10.0f : 40.0f;
        }
    }

    // In normal mode, all equal durations
    return 15.0f;
}

float TrafficLight::getNextStateDuration() const {
    if (isPriorityMode) {
        if (controlledLane == LaneId::AL2_PRIORITY) {
            return (nextState == LightState::GREEN) ? 40.0f : 10.0f;
        } else {
            return (nextState == LightState::GREEN) ? 10.0f : 40.0f;
        }
    }
    return 15.0f;
}

void TrafficLight::startTransition(LightState newState) {
    nextState = newState;
    isTransitioning = true;
    transitionProgress = 0.0f;
    stateTimer = 0.0f;
}

void TrafficLight::render(SDL_Renderer* renderer, float x, float y) const {
    // Constants for rendering
    const float LIGHT_SIZE = 30.0f;
    const float HOUSING_PADDING = 5.0f;
    const float HOUSING_WIDTH = LIGHT_SIZE + (HOUSING_PADDING * 2.0f);
    const float HOUSING_HEIGHT = (LIGHT_SIZE * 2.0f) + (HOUSING_PADDING * 3.0f);

    // Draw housing (dark gray background)
    SDL_FRect housing = {
        x - HOUSING_PADDING,
        y - HOUSING_PADDING,
        HOUSING_WIDTH,
        HOUSING_HEIGHT
    };
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);
    SDL_RenderFillRect(renderer, &housing);

    // Draw border
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_RenderRect(renderer, &housing);

    // Calculate light positions
    float redY = y;
    float greenY = y + LIGHT_SIZE + HOUSING_PADDING;

    // Draw RED light
    SDL_FRect redLight = {x, redY, LIGHT_SIZE, LIGHT_SIZE};
    float redIntensity;
    if (state == LightState::RED) {
        redIntensity = isTransitioning ? (1.0f - transitionProgress) : 1.0f;
    } else {
        redIntensity = isTransitioning ? transitionProgress : 0.0f;
    }
    SDL_SetRenderDrawColor(renderer,
        255,  // Red always max
        static_cast<uint8_t>(50 * redIntensity),  // Slight glow
        static_cast<uint8_t>(50 * redIntensity),  // Slight glow
        255
    );
    SDL_RenderFillRect(renderer, &redLight);

    // Draw GREEN light
    SDL_FRect greenLight = {x, greenY, LIGHT_SIZE, LIGHT_SIZE};
    float greenIntensity;
    if (state == LightState::GREEN) {
        greenIntensity = isTransitioning ? (1.0f - transitionProgress) : 1.0f;
    } else {
        greenIntensity = isTransitioning ? transitionProgress : 0.0f;
    }
    SDL_SetRenderDrawColor(renderer,
        static_cast<uint8_t>(50 * greenIntensity),  // Slight glow
        255,  // Green always max
        static_cast<uint8_t>(50 * greenIntensity),  // Slight glow
        255
    );
    SDL_RenderFillRect(renderer, &greenLight);

    // Draw light borders
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);

    // Add priority indicator if this is the priority lane
    if (controlledLane == LaneId::AL2_PRIORITY) {
        SDL_FRect priorityIndicator = {
            x + LIGHT_SIZE + 5.0f,
            y,
            10.0f,
            10.0f
        };

        // Pulsing effect for priority mode
        uint8_t alpha = isPriorityMode ?
            static_cast<uint8_t>(128 + 127 * sinf(SDL_GetTicks() / 500.0f)) : 100;

        SDL_SetRenderDrawColor(renderer, 255, 165, 0, alpha);
        SDL_RenderFillRect(renderer, &priorityIndicator);
    }
}


================================================================================
File: src\core\Vehicle.cpp
================================================================================

// src/core/Vehicle.cpp
#include "core/Vehicle.h"
#include <sstream>
#include <iomanip>
#include <cmath>
#include <algorithm>

Vehicle::Vehicle(uint32_t vehicleId, Direction dir, LaneId lane, bool emergency)
    : id(vehicleId)
    , direction(dir)
    , currentLane(lane)
    , targetLane(lane)
    , waitTime(0.0f)
    , isProcessing(false)
    , turnProgress(0.0f)
    , hasStartedTurn(false)
    , speed(0.0f)
    , position(0.0f)
    , entryTime(std::chrono::steady_clock::now())
    , isEmergency(emergency)
    , turning(false)
{
    // Initialize animation state
    pos.x = 0.0f;
    pos.y = 0.0f;
    pos.angle = 0.0f;
    pos.targetX = 0.0f;
    pos.targetY = 0.0f;
    pos.targetAngle = 0.0f;
    pos.turnPosX = 0.0f;
    pos.turnPosY = 0.0f;
    pos.turnCenter_x = 0.0f;
    pos.turnCenter_y = 0.0f;
    pos.startAngle = 0.0f;
    pos.endAngle = 0.0f;
    pos.turnRadius = 0.0f;
}

void Vehicle::setProcessing(bool processing) {
    isProcessing = processing;
    if (processing) {
        speed = SimConstants::VEHICLE_BASE_SPEED;
    }
}

void Vehicle::updateWaitTime(float delta) {
    if (!isProcessing) {
        waitTime += delta;
    }
}

void Vehicle::updateTurnProgress(float delta) {
    if (hasStartedTurn && turnProgress < 1.0f) {
        turnProgress = std::min(1.0f, turnProgress + delta * SimConstants::TURN_SPEED);
    }
}

void Vehicle::startTurn() {
    hasStartedTurn = true;
    turning = true;
    turnProgress = 0.0f;
    speed = SimConstants::VEHICLE_TURN_SPEED;
}

void Vehicle::setupTurn(float centerX, float centerY, float radius, float startAng, float endAng) {
    pos.turnCenter_x = centerX;
    pos.turnCenter_y = centerY;
    pos.turnRadius = radius;
    pos.startAngle = startAng;
    pos.endAngle = endAng;
    pos.turnPosX = pos.x;
    pos.turnPosY = pos.y;
}

void Vehicle::updateTurn(float deltaTime) {
    if (!turning) return;

    // Calculate easedProgress for smoother turns
    turnProgress = std::min(1.0f, turnProgress + deltaTime * SimConstants::TURN_SPEED);
    float easedProgress = turnProgress * turnProgress * (3.0f - 2.0f * turnProgress);

    // Calculate current angle along the turn
    float currentAngle = pos.startAngle + (pos.endAngle - pos.startAngle) * easedProgress;

    // Calculate new position along the turn
    pos.turnPosX = pos.turnCenter_x + pos.turnRadius * cosf(currentAngle);
    pos.turnPosY = pos.turnCenter_y + pos.turnRadius * sinf(currentAngle);

    // Update angle to face tangent to circle
    pos.angle = currentAngle + static_cast<float>(M_PI)/2.0f;

    // Check if turn is complete
    if (turnProgress >= 1.0f) {
        turning = false;
        pos.x = pos.turnPosX;
        pos.y = pos.turnPosY;
    }
}

void Vehicle::setTurnPosition(float x, float y) {
    pos.turnPosX = x;
    pos.turnPosY = y;
}

void Vehicle::setSpeed(float newSpeed) {
    speed = newSpeed;
}

void Vehicle::setPosition(float newPos) {
    position = newPos;
}

void Vehicle::setTargetPosition(float x, float y, float angle) {
    pos.targetX = x;
    pos.targetY = y;
    pos.targetAngle = angle;
}

void Vehicle::updateMovement(float deltaTime) {
    if (!isProcessing) return;

    if (turning) {
        updateTurn(deltaTime);
        return;
    }

    // Calculate distance to target
    float dx = pos.targetX - pos.x;
    float dy = pos.targetY - pos.y;
    float distance = std::sqrt(dx * dx + dy * dy);

    // Update position if not at target
    if (distance > 0.1f) {
        float moveSpeed = speed * deltaTime;
        float moveRatio = std::min(1.0f, moveSpeed / distance);

        pos.x += dx * moveRatio;
        pos.y += dy * moveRatio;

        // Update angle smoothly
        float targetAngle = std::atan2f(dy, dx);
        float angleDiff = targetAngle - pos.angle;

        // Normalize angle to [-π, π]
        while (angleDiff > static_cast<float>(M_PI)) {
            angleDiff -= 2.0f * static_cast<float>(M_PI);
        }
        while (angleDiff < -static_cast<float>(M_PI)) {
            angleDiff += 2.0f * static_cast<float>(M_PI);
        }

        pos.angle += angleDiff * 0.1f; // Smooth angle change
    }
}

bool Vehicle::hasReachedTarget() const {
    float dx = pos.targetX - pos.x;
    float dy = pos.targetY - pos.y;
    return std::sqrt(dx * dx + dy * dy) < 0.1f;
}

float Vehicle::calculateTurnRadius() const {
    switch (direction) {
        case Direction::LEFT:
            return SimConstants::TURN_GUIDE_RADIUS * 1.2f;
        case Direction::RIGHT:
            return SimConstants::TURN_GUIDE_RADIUS * 0.8f;
        default:
            return SimConstants::TURN_GUIDE_RADIUS;
    }
}

void Vehicle::calculateTurnParameters(float roadWidth, float laneWidth, float centerX, float centerY) {
    int quadrant = static_cast<int>(currentLane) / 3; // 0-3 for W,N,E,S
    bool isLeftTurn = direction == Direction::LEFT;
    bool isRightTurn = direction == Direction::RIGHT;
    float turnOffset = roadWidth * 0.25f;
    float turnRadius = SimConstants::TURN_GUIDE_RADIUS;

    // Adjust radius based on turn direction
    if (isLeftTurn) turnRadius *= 1.2f;
    if (isRightTurn) turnRadius *= 0.8f;

    // Set turn center and angle based on approach direction and turn type
    switch (quadrant) {
        case 0: // From West (A road)
            if (isLeftTurn) {
                setupTurn(
                    centerX - roadWidth/2.0f + turnOffset,
                    centerY - roadWidth/2.0f - turnOffset,
                    turnRadius,
                    0.0f,
                    -static_cast<float>(M_PI)/2.0f
                );
            } else if (isRightTurn) {
                setupTurn(
                    centerX - roadWidth/2.0f + turnOffset,
                    centerY + roadWidth/2.0f + turnOffset,
                    turnRadius,
                    0.0f,
                    static_cast<float>(M_PI)/2.0f
                );
            }
            break;

        case 1: // From North (B road)
            if (isLeftTurn) {
                setupTurn(
                    centerX + roadWidth/2.0f + turnOffset,
                    centerY - roadWidth/2.0f + turnOffset,
                    turnRadius,
                    static_cast<float>(M_PI)/2.0f,
                    0.0f
                );
            } else if (isRightTurn) {
                setupTurn(
                    centerX - roadWidth/2.0f - turnOffset,
                    centerY - roadWidth/2.0f + turnOffset,
                    turnRadius,
                    static_cast<float>(M_PI)/2.0f,
                    static_cast<float>(M_PI)
                );
            }
            break;

        case 2: // From East (C road)
            if (isLeftTurn) {
                setupTurn(
                    centerX + roadWidth/2.0f - turnOffset,
                    centerY + roadWidth/2.0f + turnOffset,
                    turnRadius,
                    static_cast<float>(M_PI),
                    static_cast<float>(M_PI)/2.0f
                );
            } else if (isRightTurn) {
                setupTurn(
                    centerX + roadWidth/2.0f - turnOffset,
                    centerY - roadWidth/2.0f - turnOffset,
                    turnRadius,
                    static_cast<float>(M_PI),
                    -static_cast<float>(M_PI)/2.0f
                );
            }
            break;

        case 3: // From South (D road)
            if (isLeftTurn) {
                setupTurn(
                    centerX - roadWidth/2.0f - turnOffset,
                    centerY + roadWidth/2.0f - turnOffset,
                    turnRadius,
                    -static_cast<float>(M_PI)/2.0f,
                    static_cast<float>(M_PI)
                );
            } else if (isRightTurn) {
                setupTurn(
                    centerX + roadWidth/2.0f + turnOffset,
                    centerY + roadWidth/2.0f - turnOffset,
                    turnRadius,
                    -static_cast<float>(M_PI)/2.0f,
                    0.0f
                );
            }
            break;
    }
}

float Vehicle::calculateLanePosition(LaneId lane, size_t queuePosition) {
    using namespace SimConstants;
    float baseOffset = QUEUE_START_OFFSET + queuePosition * QUEUE_SPACING;

    switch (lane) {
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE:
            return CENTER_X - baseOffset;

        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE:
            return CENTER_Y - baseOffset;

        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE:
            return CENTER_X + baseOffset;

        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE:
            return CENTER_Y + baseOffset;

        default:
            return 0.0f;
    }
}

float Vehicle::calculateTurnAngle(Direction dir, LaneId fromLane, LaneId) {
    const float WEST_ANGLE = 0.0f;
    const float NORTH_ANGLE = static_cast<float>(M_PI) / 2.0f;
    const float EAST_ANGLE = static_cast<float>(M_PI);
    const float SOUTH_ANGLE = -static_cast<float>(M_PI) / 2.0f;

    // Get base angle from source lane
    float baseAngle;
    if (fromLane <= LaneId::AL3_FREELANE) baseAngle = WEST_ANGLE;
    else if (fromLane <= LaneId::BL3_FREELANE) baseAngle = NORTH_ANGLE;
    else if (fromLane <= LaneId::CL3_FREELANE) baseAngle = EAST_ANGLE;
    else baseAngle = SOUTH_ANGLE;

    // Adjust for turn direction
    switch (dir) {
        case Direction::LEFT:
            return baseAngle - static_cast<float>(M_PI) / 2.0f;
        case Direction::RIGHT:
            return baseAngle + static_cast<float>(M_PI) / 2.0f;
        default:
            return baseAngle;
    }
}

float Vehicle::getTimeInSystem() const {
    auto now = std::chrono::steady_clock::now();
    return std::chrono::duration<float>(now - entryTime).count();
}

std::string Vehicle::toString() const {
    std::stringstream ss;
    ss << "Vehicle[ID:" << id
       << ", Lane:" << static_cast<int>(currentLane)
       << ", Dir:" << static_cast<int>(direction)
       << ", Pos:(" << std::fixed << std::setprecision(1)
       << pos.x << "," << pos.y << ")"
       << ", Wait:" << std::setprecision(1) << waitTime << "s"
       << ", Turn:" << (hasStartedTurn ? "Yes" : "No")
       << ", Progress:" << std::setprecision(2) << turnProgress * 100 << "%]";
    return ss.str();
}


================================================================================
File: src\main.cpp
================================================================================

// src/main.cp// src/main.cpp with debug statements
#include <SDL3/SDL.h>
#include "managers/TrafficManager.h"
#include "managers/FileHandler.h"
#include "visualization/Renderer.h"
#include <iostream>
#include <chrono>
#include <thread>
#include <fstream>

// Debug helper functions
void WriteDebugLog(const std::string& message) {
    // Write to console
    std::cout << "[DEBUG] " << message << std::endl;

    // Also write to file for persistence
    std::ofstream logFile("debug_log.txt", std::ios::app);
    if (logFile.is_open()) {
        logFile << "[DEBUG] " << message << std::endl;
        logFile.close();
    }
}

class Simulator {
private:
    TrafficManager trafficManager;
    Renderer renderer;
    bool running;
    bool debugMode;

    void processInput() {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
                case SDL_EVENT_QUIT:
                    running = false;
                    break;
                case SDL_EVENT_KEY_DOWN:
                    handleKeyDown(event.key.scancode);
                    break;
            }
        }
    }

    void handleKeyDown(SDL_Scancode scancode) {
        WriteDebugLog("Key pressed: " + std::to_string(static_cast<int>(scancode)));

        switch(scancode) {
            case SDL_SCANCODE_ESCAPE:
                running = false;
                break;
            case SDL_SCANCODE_D:
                debugMode = !debugMode;
                renderer.setDebugMode(debugMode);
                break;
            case SDL_SCANCODE_G:
                renderer.toggleGridDisplay();
                break;
            case SDL_SCANCODE_P:
                // Manual priority mode toggle for testing
                WriteDebugLog("Manual priority mode toggle requested");
                break;
        }
    }

    void update(float deltaTime) {
        try {
            WriteDebugLog("Updating with deltaTime: " + std::to_string(deltaTime));
            trafficManager.update(deltaTime);
        } catch (const std::exception& e) {
            WriteDebugLog("Exception in update: " + std::string(e.what()));
        } catch (...) {
            WriteDebugLog("Unknown exception in update");
        }
    }

    void render() {
        try {
            WriteDebugLog("Rendering frame");
            renderer.render(trafficManager);
        } catch (const std::exception& e) {
            WriteDebugLog("Exception in render: " + std::string(e.what()));
        } catch (...) {
            WriteDebugLog("Unknown exception in render");
        }
    }

public:
    Simulator() : running(false), debugMode(false) {
        WriteDebugLog("Simulator constructor called");
    }

    bool initialize() {
        WriteDebugLog("Simulator initialization started");

        try {
            // Create the data directory structure if it doesn't exist
            WriteDebugLog("Creating data directories");
            std::filesystem::path dataDir = std::filesystem::current_path() / "data" / "lanes";
            if (!std::filesystem::exists(dataDir)) {
                WriteDebugLog("Creating directory: " + dataDir.string());
                std::filesystem::create_directories(dataDir);
            }

            // Initialize renderer
            WriteDebugLog("Initializing renderer");
            if (!renderer.initialize()) {
                WriteDebugLog("Failed to initialize renderer");
                return false;
            }

            // Clear any existing vehicle data
            WriteDebugLog("Creating FileHandler");
            FileHandler fileHandler;

            WriteDebugLog("Clearing lane files");
            fileHandler.clearLaneFiles();

            // Set initial state
            running = true;
            WriteDebugLog("Setting debug mode");
            renderer.setDebugMode(debugMode);

            WriteDebugLog("Simulator initialization completed successfully");
            return true;
        }
        catch (const std::exception& e) {
            WriteDebugLog("Exception during initialization: " + std::string(e.what()));
            return false;
        }
        catch (...) {
            WriteDebugLog("Unknown exception during initialization");
            return false;
        }
    }

    void run() {
        WriteDebugLog("Simulator run started");
        auto lastUpdateTime = std::chrono::high_resolution_clock::now();

        try {
            while (running) {
                auto currentTime = std::chrono::high_resolution_clock::now();
                float deltaTime = std::chrono::duration<float>(currentTime - lastUpdateTime).count();
                lastUpdateTime = currentTime;

                processInput();
                update(deltaTime);
                render();

                // Cap frame rate at ~60 FPS
                if (deltaTime < SimConstants::UPDATE_INTERVAL) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(
                        static_cast<int>((SimConstants::UPDATE_INTERVAL - deltaTime) * 1000)));
                }

                // Only log occasionally to avoid log flood
                static float statTimer = 0.0f;
                statTimer += deltaTime;
                if (statTimer >= 1.0f) {
                    WriteDebugLog("FPS: " + std::to_string(1.0f / deltaTime));
                    statTimer = 0.0f;
                }
            }
        }
        catch (const std::exception& e) {
            WriteDebugLog("Exception in main loop: " + std::string(e.what()));
        }
        catch (...) {
            WriteDebugLog("Unknown exception in main loop");
        }

        WriteDebugLog("Simulator run completed");
    }

    void cleanup() {
        WriteDebugLog("Simulator cleanup started");
        renderer.cleanup();
        WriteDebugLog("Simulator cleanup completed");
    }
};

int main(int argc, char* argv[]) {
    (void)argc; // Suppress unused parameter warning
    (void)argv; // Suppress unused parameter warning

    // Clear previous log file
    std::ofstream logFile("debug_log.txt", std::ios::trunc);
    if (logFile.is_open()) {
        logFile << "[DEBUG] Starting simulator at " << std::chrono::system_clock::now().time_since_epoch().count() << std::endl;
        logFile.close();
    }

    WriteDebugLog("Program started");

    try {
        WriteDebugLog("Creating simulator");
        Simulator simulator;

        WriteDebugLog("Initializing simulator");
        if (!simulator.initialize()) {
            WriteDebugLog("Failed to initialize simulator");
            return 1;
        }

        WriteDebugLog("Starting simulator run loop");
        simulator.run();

        WriteDebugLog("Cleaning up simulator");
        simulator.cleanup();
    }
    catch (const std::exception& e) {
        WriteDebugLog("Exception in main: " + std::string(e.what()));
        return 1;
    }
    catch (...) {
        WriteDebugLog("Unknown exception in main");
        return 1;
    }

    WriteDebugLog("Program ending normally");
    return 0;
}


================================================================================
File: src\managers\FileHandler.cpp
================================================================================

#include "managers/FileHandler.h"
#include <fstream>
#include <sstream>
#include <iostream>

const std::string FileHandler::BASE_PATH = "data/lanes";

FileHandler::FileHandler() {
    try {
        initializeFileSystem();
    } catch (const std::exception& e) {
        std::cerr << "FileHandler initialization failed: " << e.what() << std::endl;
        throw;
    }
}

void FileHandler::initializeFileSystem() {
    // Setup data directory path
    // Use current_path() for relative paths that work in any build configuration
    dataDir = (std::filesystem::current_path() / BASE_PATH).lexically_normal();
    std::cout << "[FileHandler] Using path: " << dataDir << std::endl;

    // Ensure the directory exists before accessing it
    if (!std::filesystem::exists(dataDir)) {
        std::cout << "[FileHandler] Creating directory: " << dataDir << std::endl;
        try {
            std::filesystem::create_directories(dataDir);
        } catch (const std::exception& e) {
            std::cerr << "[FileHandler] Error creating directory: " << e.what() << std::endl;
            throw;
        }
    }

    // Initialize lane file paths
    laneFiles = {
        {LaneId::AL1_INCOMING, (dataDir / "lane_a1.txt").lexically_normal()},
        {LaneId::AL2_PRIORITY, (dataDir / "lane_a2.txt").lexically_normal()},
        {LaneId::AL3_FREELANE, (dataDir / "lane_a3.txt").lexically_normal()},
        {LaneId::BL1_INCOMING, (dataDir / "lane_b1.txt").lexically_normal()},
        {LaneId::BL2_NORMAL,   (dataDir / "lane_b2.txt").lexically_normal()},
        {LaneId::BL3_FREELANE, (dataDir / "lane_b3.txt").lexically_normal()},
        {LaneId::CL1_INCOMING, (dataDir / "lane_c1.txt").lexically_normal()},
        {LaneId::CL2_NORMAL,   (dataDir / "lane_c2.txt").lexically_normal()},
        {LaneId::CL3_FREELANE, (dataDir / "lane_c3.txt").lexically_normal()},
        {LaneId::DL1_INCOMING, (dataDir / "lane_d1.txt").lexically_normal()},
        {LaneId::DL2_NORMAL,   (dataDir / "lane_d2.txt").lexically_normal()},
        {LaneId::DL3_FREELANE, (dataDir / "lane_d3.txt").lexically_normal()}
    };

    // Try to access a file to check permissions
    std::cout << "[FileHandler] Checking file access" << std::endl;

    // Initialize all files
    clearLaneFiles(); // This will create empty files
}

std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> FileHandler::readNewVehicles() {
    std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> newVehicles;
    std::lock_guard<std::mutex> lock(fileMutex);

    // First try to read from combined file (for compatibility with C code)
    try {
        if (std::filesystem::exists(vehicleDataFile)) {
            std::ifstream file(vehicleDataFile);
            if (file) {
                std::string line;
                while (std::getline(file, line)) {
                    if (line.empty()) continue;

                    // Parse line in format "vehicleId:road"
                    size_t colonPos = line.find(':');
                    if (colonPos != std::string::npos) {
                        std::string vehicleId = line.substr(0, colonPos);
                        char roadChar = line[colonPos + 1];

                        // Determine lane based on vehicle ID and road
                        LaneId lane;
                        Direction direction = Direction::STRAIGHT;
                        bool isEmergency = false;

                        // Parse direction/emergency from ID
                        if (vehicleId.find("L1") != std::string::npos) {
                            lane = roadChar == 'A' ? LaneId::AL1_INCOMING :
                                   roadChar == 'B' ? LaneId::BL1_INCOMING :
                                   roadChar == 'C' ? LaneId::CL1_INCOMING :
                                   LaneId::DL1_INCOMING;
                        }
                        else if (vehicleId.find("L2") != std::string::npos) {
                            lane = roadChar == 'A' ? LaneId::AL2_PRIORITY :
                                   roadChar == 'B' ? LaneId::BL2_NORMAL :
                                   roadChar == 'C' ? LaneId::CL2_NORMAL :
                                   LaneId::DL2_NORMAL;
                        }
                        else if (vehicleId.find("L3") != std::string::npos) {
                            lane = roadChar == 'A' ? LaneId::AL3_FREELANE :
                                   roadChar == 'B' ? LaneId::BL3_FREELANE :
                                   roadChar == 'C' ? LaneId::CL3_FREELANE :
                                   LaneId::DL3_FREELANE;
                            direction = Direction::LEFT; // L3 lanes are for left turns
                        }
                        else {
                            // Default to middle lane
                            lane = roadChar == 'A' ? LaneId::AL2_PRIORITY :
                                   roadChar == 'B' ? LaneId::BL2_NORMAL :
                                   roadChar == 'C' ? LaneId::CL2_NORMAL :
                                   LaneId::DL2_NORMAL;
                        }

                        // Check for emergency vehicles
                        isEmergency = vehicleId.find("EMG") != std::string::npos;

                        // Create vehicle
                        uint32_t id = static_cast<uint32_t>(std::hash<std::string>{}(vehicleId));
                        auto vehicle = std::make_shared<Vehicle>(id, direction, lane, isEmergency);
                        newVehicles.emplace_back(lane, vehicle);
                    }
                }

                // Clear file after reading
                file.close();
                std::ofstream clearFile(vehicleDataFile, std::ios::trunc);
            }
        }
    } catch (const std::exception& e) {
        handleFileError("reading combined file", vehicleDataFile, e);
    }

    // Then try to read from individual lane files
    for (const auto& [laneId, filepath] : laneFiles) {
        try {
            if (!std::filesystem::exists(filepath)) continue;

            std::ifstream file(filepath);
            if (!file) continue;

            std::string line;
            std::vector<std::string> lines;
            while (std::getline(file, line)) {
                if (!line.empty()) {
                    lines.push_back(line);
                }
            }

            // Clear file after reading
            file.close();
            std::ofstream clearFile(filepath, std::ios::trunc);

            // Process lines
            for (const auto& line : lines) {
                auto vehicle = parseVehicleLine(line, laneId);
                if (vehicle) {
                    newVehicles.emplace_back(laneId, vehicle);
                }
            }
        } catch (const std::exception& e) {
            handleFileError("reading file", filepath, e);
        }
    }

    return newVehicles;
}

std::shared_ptr<Vehicle> FileHandler::parseVehicleLine(const std::string& line, LaneId laneId) {
    size_t commaPos = line.find(',');
    size_t semicolonPos = line.find(';');

    // Simple format parsing: "id,direction;..."
    if (commaPos == std::string::npos || semicolonPos == std::string::npos) {
        return nullptr;
    }

    try {
        uint32_t id = std::stoul(line.substr(0, commaPos));
        char dirChar = line[commaPos + 1];

        Direction dir;
        switch (dirChar) {
            case 'S': dir = Direction::STRAIGHT; break;
            case 'L': dir = Direction::LEFT; break;
            case 'R': dir = Direction::RIGHT; break;
            default: return nullptr;
        }

        // Check if 3rd lane with non-left turn (invalid)
        if (static_cast<int>(laneId) % 3 == 2 && dir != Direction::LEFT) {
            // 3rd lanes are only for left turns
            dir = Direction::LEFT;
        }

        return std::make_shared<Vehicle>(id, dir, laneId);
    } catch (const std::exception& e) {
        std::cerr << "Error parsing line: " << line << " - " << e.what() << std::endl;
        return nullptr;
    }
}

void FileHandler::clearLaneFiles() {
    std::lock_guard<std::mutex> lock(fileMutex);

    for (const auto& [laneId, filepath] : laneFiles) {
        try {
            std::cout << "[FileHandler] Clearing file: " << filepath << std::endl;
            std::ofstream file(filepath, std::ios::trunc);
            if (!file) {
                std::cerr << "[FileHandler] Could not open file for writing: " << filepath << std::endl;
            }
        } catch (const std::exception& e) {
            std::cerr << "[FileHandler] Error clearing file " << filepath << ": " << e.what() << std::endl;
        }
    }

    // Clear combined vehicle data file for compatibility with C implementation
    try {
        std::cout << "[FileHandler] Clearing combined vehicle file" << std::endl;
        std::ofstream file("vehicles.data", std::ios::trunc);
        if (!file) {
            std::cerr << "[FileHandler] Could not open vehicles.data for writing" << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "[FileHandler] Error clearing vehicles.data: " << e.what() << std::endl;
    }
}


size_t FileHandler::getVehicleCountInFile(LaneId laneId) const {
    auto it = laneFiles.find(laneId);
    if (it == laneFiles.end()) return 0;

    try {
        std::ifstream file(it->second);
        if (!file) return 0;

        size_t count = 0;
        std::string line;
        while (std::getline(file, line)) {
            if (!line.empty()) count++;
        }
        return count;
    } catch (const std::exception& e) {
        std::cerr << "Error counting vehicles: " << e.what() << std::endl;
        return 0;
    }
}

void FileHandler::ensureDirectoryExists(const std::filesystem::path& dir) {
    if (!std::filesystem::exists(dir)) {
        if (!std::filesystem::create_directories(dir)) {
            throw std::runtime_error("Failed to create directory: " + dir.string());
        }
    }
}

std::filesystem::path FileHandler::getLaneFilePath(LaneId laneId) const {
    auto it = laneFiles.find(laneId);
    if (it == laneFiles.end()) {
        throw std::runtime_error("Invalid lane ID");
    }
    return it->second;
}

void FileHandler::logFileOperation(const std::string& operation, const std::filesystem::path& filepath) const {
    std::cout << "File " << operation << ": " << filepath.filename() << std::endl;
}

void FileHandler::handleFileError(const std::string& operation,
                                  const std::filesystem::path& filepath,
                                  const std::exception& e) const {
    std::cerr << "File " << operation << " error for " << filepath
              << ": " << e.what() << std::endl;
}

bool FileHandler::isLaneFileAvailable(LaneId laneId) const {
    auto it = laneFiles.find(laneId);
    if (it == laneFiles.end()) return false;
    return std::filesystem::exists(it->second);
}

// Fix for the last_write_time conversion error
std::chrono::system_clock::time_point FileHandler::getLastModifiedTime(LaneId laneId) const {
    auto it = laneFiles.find(laneId);
    if (it == laneFiles.end() || !std::filesystem::exists(it->second)) {
        return std::chrono::system_clock::time_point(); // Return epoch time
    }

    try {
        // Convert file_time_type to system_clock::time_point
        auto fileTime = std::filesystem::last_write_time(it->second);

        // In C++17, direct conversion isn't available, so we'll return current time as a workaround
        // This is sufficient for checking if a file has been modified recently
        return std::chrono::system_clock::now();
    } catch (const std::exception& e) {
        std::cerr << "Error getting file time: " << e.what() << std::endl;
        return std::chrono::system_clock::time_point();
    }
}


================================================================================
File: src\managers\IntersectionController.cpp
================================================================================

// IntersectionController.cpp
#include "managers/IntersectionController.h"
#include <algorithm>
#include <numeric>

IntersectionController::IntersectionController(std::vector<std::unique_ptr<Lane>>& lanes)
    : lanes(lanes)
    , isPriorityMode(false)
    , stateTimer(0.0f)
    , elapsedTime(0.0f)
    , processingTimer(0.0f)
    , vehiclesProcessedInState(0)
    , totalVehiclesProcessed(0)
{
    updateLaneQueue();
}

void IntersectionController::update(float deltaTime) {
    updateTimers(deltaTime);

    // Check state transitions
    handleStateTransition();

    // Process vehicles based on current state
    if (processingTimer >= calculateProcessingTime()) {
        if (isPriorityMode) {
            processPriorityLane();
        } else {
            processNormalLanes();
        }
        processFreeLanes();
        processingTimer = 0.0f;
    }

    // Check wait times and update priorities
    checkWaitTimes();
    updateLaneQueue();
}

void IntersectionController::updateLaneQueue() {
    // Clear existing queue
    while (!laneQueue.isEmpty()) {
        laneQueue.dequeue();
    }

    // Add lanes with calculated priorities
    for (const auto& lane : lanes) {
        if (!isFreeLane(lane->getId())) {
            int priority = calculateLanePriority(*lane);
            laneQueue.enqueuePriority(lane->getId(), priority);
        }
    }
}

int IntersectionController::calculateLanePriority(const Lane& lane) const {
    int priority = 1; // Base priority

    if (lane.isPriorityLane() && lane.getQueueSize() > PRIORITY_THRESHOLD) {
        priority = 3; // Highest priority
    }
    else if (lane.getQueueSize() > 8) {
        priority = 2; // Medium priority
    }

    return priority;
}

void IntersectionController::processPriorityLane() {
    Lane* priorityLane = getPriorityLane();
    if (!priorityLane) return;

    size_t initialSize = priorityLane->getQueueSize();
    while (priorityLane->getQueueSize() > PRIORITY_RELEASE_THRESHOLD) {
        auto vehicle = priorityLane->removeVehicle();
        if (vehicle) {
            vehiclesProcessedInState++;
            totalVehiclesProcessed++;
        }
    }
}

void IntersectionController::processNormalLanes() {
    size_t vehiclesToProcess = calculateVehiclesToProcess();

    for (auto& lane : lanes) {
        if (!isFreeLane(lane->getId()) && !lane->isPriorityLane()) {
            for (size_t i = 0; i < vehiclesToProcess && lane->getQueueSize() > 0; ++i) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

void IntersectionController::processFreeLanes() {
    for (auto& lane : lanes) {
        if (isFreeLane(lane->getId())) {
            while (lane->getQueueSize() > 0) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

size_t IntersectionController::calculateVehiclesToProcess() const {
    // |V| = 1/n Σ|Li| formula from assignment
    float avgVehicles = calculateAverageWaitingVehicles();
    return static_cast<size_t>(std::ceil(avgVehicles));
}

float IntersectionController::calculateAverageWaitingVehicles() const {
    size_t totalVehicles = 0;
    size_t normalLaneCount = 0;

    // Only count vehicles in normal lanes (not free or priority lanes)
    for (const auto& lane : lanes) {
        if (!isFreeLane(lane->getId()) && !lane->isPriorityLane()) {
            totalVehicles += lane->getQueueSize();
            normalLaneCount++;
        }
    }

    return normalLaneCount > 0 ?
        static_cast<float>(totalVehicles) / static_cast<float>(normalLaneCount) : 0.0f;
}

float IntersectionController::calculateProcessingTime() const {
    // According to assignment formula: T = |V| * t
    // where |V| = average number of waiting vehicles
    // and t = 2 seconds per vehicle

    if (isPriorityMode) {
        // In priority mode, only process priority lane
        Lane* priorityLane = getPriorityLane();
        if (priorityLane) {
            return priorityLane->getQueueSize() * BASE_VEHICLE_PROCESS_TIME;
        }
        return 0.0f;
    }

    // In normal mode, calculate average of normal lanes
    float avgVehicles = calculateAverageWaitingVehicles();
    return avgVehicles * BASE_VEHICLE_PROCESS_TIME;
}

void IntersectionController::handleStateTransition() {
    if (isPriorityMode && shouldSwitchToNormalMode()) {
        isPriorityMode = false;
        resetStateTimers();
    }
    else if (!isPriorityMode && shouldSwitchToPriorityMode()) {
        isPriorityMode = true;
        resetStateTimers();
    }

    // Force state change if stuck too long
    if (stateTimer >= MAX_STATE_TIME) {
        isPriorityMode = !isPriorityMode;
        resetStateTimers();
    }
}

bool IntersectionController::shouldSwitchToNormalMode() const {
    if (!isPriorityMode) return false;

    Lane* priorityLane = getPriorityLane();
    return priorityLane &&
           priorityLane->getQueueSize() <= PRIORITY_RELEASE_THRESHOLD &&
           stateTimer >= MIN_STATE_TIME;
}

bool IntersectionController::shouldSwitchToPriorityMode() const {
    if (isPriorityMode) return false;

    Lane* priorityLane = getPriorityLane();
    return priorityLane &&
           priorityLane->getQueueSize() > PRIORITY_THRESHOLD &&
           stateTimer >= MIN_STATE_TIME;
}

void IntersectionController::resetStateTimers() {
    stateTimer = 0.0f;
    processingTimer = 0.0f;
    vehiclesProcessedInState = 0;
}

Lane* IntersectionController::getPriorityLane() const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [](const auto& lane) { return lane->isPriorityLane(); });
    return it != lanes.end() ? it->get() : nullptr;
}

bool IntersectionController::isFreeLane(LaneId id) const {
    return id == LaneId::AL3_FREELANE ||
           id == LaneId::BL3_FREELANE ||
           id == LaneId::CL3_FREELANE ||
           id == LaneId::DL3_FREELANE;
}

void IntersectionController::checkWaitTimes() {
    for (const auto& lane : lanes) {
        if (lane->getQueueSize() > 0 && !isFreeLane(lane->getId())) {
            // Process lanes that have been waiting too long
            if (lane->getQueueSize() >= 8) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

void IntersectionController::updateTimers(float deltaTime) {
    stateTimer += deltaTime;
    elapsedTime += deltaTime;
    processingTimer += deltaTime;
}

std::vector<IntersectionController::LaneStatus> IntersectionController::getLaneStatuses() const {
    std::vector<LaneStatus> statuses;

    for (const auto& lane : lanes) {
        LaneStatus status;
        status.id = lane->getId();
        status.queueSize = lane->getQueueSize();
        status.isActive = isPriorityMode ? lane->isPriorityLane() :
                         !isFreeLane(lane->getId());
        status.priority = calculateLanePriority(*lane);

        statuses.push_back(status);
    }

    return statuses;
}

IntersectionController::ProcessingStats IntersectionController::getStats() const {
    ProcessingStats stats;
    stats.totalVehiclesProcessed = totalVehiclesProcessed;
    stats.isPriorityMode = isPriorityMode;

    // Fill current queue sizes
    size_t laneIndex = 0;
    for (const auto& lane : lanes) {
        stats.currentQueueSizes[laneIndex++] = lane->getQueueSize();
    }

    return stats;
}


================================================================================
File: src\managers\TrafficManager.cpp
================================================================================


// src/managers/TrafficManager.cpp
#include "managers/TrafficManager.h"
#include <algorithm>
#include <iostream>

TrafficManager::TrafficManager()
    : inPriorityMode(false)
    , stateTimer(0.0f)
    , lastUpdateTime(0.0f)
    , processingTimer(0.0f)
    , totalVehiclesProcessed(0)
    , averageWaitTime(0.0f)
{
    // Initialize lanes
    lanes.push_back(std::make_unique<Lane>(LaneId::AL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::AL2_PRIORITY, true));  // Priority lane
    lanes.push_back(std::make_unique<Lane>(LaneId::AL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL3_FREELANE, false));

    // Initialize traffic lights with their controlled lanes
    trafficLights[LaneId::AL2_PRIORITY] = TrafficLight(LaneId::AL2_PRIORITY);
    trafficLights[LaneId::BL2_NORMAL] = TrafficLight(LaneId::BL2_NORMAL);
    trafficLights[LaneId::CL2_NORMAL] = TrafficLight(LaneId::CL2_NORMAL);
    trafficLights[LaneId::DL2_NORMAL] = TrafficLight(LaneId::DL2_NORMAL);

    // Initialize lane priority queue
    updateLaneQueue();
    synchronizeTrafficLights();
}

// Fix for the update method to make it safer
void TrafficManager::update(float deltaTime) {
    // Update timers first to avoid calling methods that might lock mutexes while holding a lock
    updateTimers(deltaTime);

    // These operations can be done independently with no risk of deadlock
    processNewVehicles();
    handleStateTransition(deltaTime);
    updateVehiclePositions(deltaTime);
    updateTrafficLights(deltaTime);

    // Calculate stats without modifying data
    updateStatistics(deltaTime);

    // Process vehicles based on mode
    if (processingTimer >= SimConstants::VEHICLE_PROCESS_TIME) {
        if (inPriorityMode) {
            processPriorityLane();
        } else {
            processNormalLanes(calculateVehiclesToProcess());
        }
        processFreeLanes();
        processingTimer = 0.0f;

        // Update lane queue after processing
        updateLaneQueue();
    }

    // Check wait times and clean up
    checkWaitTimes();
    cleanupFinishedVehicles();

    // Update individual lanes
    for (auto& lane : lanes) {
        lane->update(deltaTime);
    }
}

// Add this implementation to the updateLaneQueue method
void TrafficManager::updateLaneQueue() {
    // Create a temporary new queue instead of modifying the existing one in-place
    PriorityQueue<LaneId> newQueue;

    // Add lanes with calculated priorities
    for (const auto& lane : lanes) {
        if (!isFreeLane(lane->getId())) {
            int priority = 1; // Default priority

            if (lane->isPriorityLane() && lane->getQueueSize() > SimConstants::PRIORITY_THRESHOLD) {
                priority = 3; // Highest priority
            }
            else if (lane->getQueueSize() > 8) {
                priority = 2; // Medium priority
            }

            newQueue.enqueuePriority(lane->getId(), priority);
        }
    }

    // Move the new queue to replace the existing one (no mutex deadlock issue)
    laneQueue = std::move(newQueue);
}

void TrafficManager::addVehicleToLane(LaneId laneId, std::shared_ptr<Vehicle> vehicle) {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [laneId](const auto& lane) { return lane->getId() == laneId; });

    if (it != lanes.end()) {
        (*it)->addVehicle(vehicle);
        activeVehicles[vehicle->getId()] = vehicle;

        // Position vehicle based on lane
        setupVehicleTurn(vehicle);
    }
}

void TrafficManager::setupVehicleTurn(std::shared_ptr<Vehicle> vehicle) {
    using namespace SimConstants;

    // Initialize vehicle position based on lane
    LaneId laneId = vehicle->getCurrentLane();
    int roadNum = static_cast<int>(laneId) / 3; // 0-3 for W,N,E,S
    int lanePosition = static_cast<int>(laneId) % 3; // 0-2 for lane position

    // Calculate lane offset from center
    float laneOffset = (lanePosition - 1) * LANE_WIDTH;

    // Set initial position based on approach direction
    float initialX = CENTER_X;
    float initialY = CENTER_Y;
    float initialAngle = 0.0f;

    switch (roadNum) {
        case 0: // West approach (A lanes)
            initialX = -VEHICLE_WIDTH;
            initialY = CENTER_Y + laneOffset;
            initialAngle = 0.0f; // Facing east
            break;

        case 1: // North approach (B lanes)
            initialX = CENTER_X + laneOffset;
            initialY = -VEHICLE_HEIGHT;
            initialAngle = M_PI/2.0f; // Facing south
            break;

        case 2: // East approach (C lanes)
            initialX = WINDOW_WIDTH + VEHICLE_WIDTH;
            initialY = CENTER_Y - laneOffset; // Note negative offset
            initialAngle = M_PI; // Facing west
            break;

        case 3: // South approach (D lanes)
            initialX = CENTER_X - laneOffset; // Note negative offset
            initialY = WINDOW_HEIGHT + VEHICLE_HEIGHT;
            initialAngle = -M_PI/2.0f; // Facing north
            break;
    }

    // Set vehicle position and targets
    vehicle->setTargetPosition(initialX, initialY, initialAngle);

    // Calculate turn parameters if needed
    if (vehicle->getDirection() != Direction::STRAIGHT) {
        vehicle->calculateTurnParameters(ROAD_WIDTH, LANE_WIDTH, CENTER_X, CENTER_Y);
    }
}

size_t TrafficManager::getLaneSize(LaneId laneId) const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [laneId](const auto& lane) { return lane->getId() == laneId; });
    return it != lanes.end() ? (*it)->getQueueSize() : 0;
}

void TrafficManager::updateVehiclePositions(float deltaTime) {
    // Update position for each active vehicle
    for (auto& [_, vehicle] : activeVehicles) {
        if (vehicle->isInProcess()) {
            if (vehicle->isTurning()) {
                vehicle->updateTurn(deltaTime);
            } else {
                vehicle->updateMovement(deltaTime);
            }
        } else {
            // Update wait time for non-moving vehicles
            vehicle->updateWaitTime(deltaTime);
        }
    }

    // Update turning progress
    updateVehicleTurns(deltaTime);
}

void TrafficManager::updateVehicleTurns(float deltaTime) {
    for (auto& [_, vehicle] : activeVehicles) {
        if (vehicle->isInProcess() && vehicle->hasTurnStarted()) {
            vehicle->updateTurnProgress(deltaTime);

            // Check if turn is complete
            if (vehicle->getTurnProgress() >= 1.0f) {
                // Update lane based on turn direction
                LaneId currentLane = vehicle->getCurrentLane();
                Direction direction = vehicle->getDirection();

                // Determine target lane based on current lane and direction
                LaneId targetLane = currentLane;
                int roadGroup = static_cast<int>(currentLane) / 3;

                switch (direction) {
                    case Direction::LEFT:
                        // Left turns go to the next road counterclockwise
                        targetLane = static_cast<LaneId>((roadGroup + 3) % 4 * 3 + 1); // Middle lane
                        break;

                    case Direction::RIGHT:
                        // Right turns go to the next road clockwise
                        targetLane = static_cast<LaneId>((roadGroup + 1) % 4 * 3 + 1); // Middle lane
                        break;

                    default:
                        // Straight continues to opposite road
                        targetLane = static_cast<LaneId>((roadGroup + 2) % 4 * 3 + 1); // Middle lane
                        break;
                }

                vehicle->setTargetLane(targetLane);
            }
        }
    }
}

void TrafficManager::updateTrafficLights(float deltaTime) {
    // Update each light's state
    for (auto& [_, light] : trafficLights) {
        light.update(deltaTime);
    }

    if (inPriorityMode) {
        // Priority mode: AL2 gets green, others red
        trafficLights[LaneId::AL2_PRIORITY].setState(LightState::GREEN);
        trafficLights[LaneId::BL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(LightState::RED);
    } else {
        // Normal mode: Alternate between N-S and E-W traffic
        float cycleTime = 15.0f;
        bool northSouthGreen = std::fmod(stateTimer, cycleTime * 2) < cycleTime;

        trafficLights[LaneId::BL2_NORMAL].setState(northSouthGreen ? LightState::GREEN : LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(northSouthGreen ? LightState::GREEN : LightState::RED);
        trafficLights[LaneId::AL2_PRIORITY].setState(northSouthGreen ? LightState::RED : LightState::GREEN);
        trafficLights[LaneId::CL2_NORMAL].setState(northSouthGreen ? LightState::RED : LightState::GREEN);
    }
}

void TrafficManager::synchronizeTrafficLights() {
    // All traffic lights should have a consistent state
    if (inPriorityMode) {
        // In priority mode, only AL2 gets green
        for (auto& [laneId, light] : trafficLights) {
            light.setPriorityMode(true);

            if (laneId == LaneId::AL2_PRIORITY) {
                light.setState(LightState::GREEN);
            } else {
                light.setState(LightState::RED);
            }
        }
    } else {
        // In normal mode, we alternate N-S and E-W
        for (auto& [_, light] : trafficLights) {
            light.setPriorityMode(false);
        }

        // Initial setup: N-S green
        trafficLights[LaneId::BL2_NORMAL].setState(LightState::GREEN);
        trafficLights[LaneId::DL2_NORMAL].setState(LightState::GREEN);
        trafficLights[LaneId::AL2_PRIORITY].setState(LightState::RED);
        trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
    }
}

void TrafficManager::handleStateTransition(float deltaTime) {
    bool shouldBePriority = checkPriorityConditions();

    if (shouldBePriority && !inPriorityMode) {
        if (stateTimer >= SimConstants::MIN_STATE_TIME) {
            inPriorityMode = true;
            stateTimer = 0.0f;
            synchronizeTrafficLights();
            std::cout << "Switching to PRIORITY mode" << std::endl;
        }
    } else if (!shouldBePriority && inPriorityMode) {
        auto* priorityLane = getPriorityLane();
        if (priorityLane && priorityLane->getQueueSize() <= SimConstants::NORMAL_THRESHOLD &&
            stateTimer >= SimConstants::MIN_STATE_TIME) {
            inPriorityMode = false;
            stateTimer = 0.0f;
            synchronizeTrafficLights();
            std::cout << "Switching to NORMAL mode" << std::endl;
        }
    }

    // Force state change if stuck too long
    if (stateTimer >= SimConstants::MAX_WAIT_TIME) {
        inPriorityMode = !inPriorityMode;
        stateTimer = 0.0f;
        synchronizeTrafficLights();
        std::cout << "FORCED mode switch after timeout" << std::endl;
    }
}

bool TrafficManager::checkPriorityConditions() const {
    // Check if priority lane exceeds threshold
    auto* priorityLane = getPriorityLane();
    if (!priorityLane) return false;

    return priorityLane->getQueueSize() > SimConstants::PRIORITY_THRESHOLD;
}

void TrafficManager::processNewVehicles() {
    // Get new vehicles from files
    auto newVehicles = fileHandler.readNewVehicles();

    for (const auto& [laneId, vehicle] : newVehicles) {
        // Check if this is a valid lane for the vehicle's direction
        LaneId optimalLane = determineOptimalLane(vehicle->getDirection(), laneId);

        if (isValidSpawnLane(optimalLane, vehicle->getDirection())) {
            addVehicleToLane(optimalLane, vehicle);
            std::cout << "Vehicle " << vehicle->getId() << " added to lane "
                     << static_cast<int>(optimalLane) << std::endl;
        } else {
            std::cerr << "Invalid spawn configuration for vehicle " << vehicle->getId() << std::endl;
        }
    }
}

LaneId TrafficManager::determineOptimalLane(Direction direction, LaneId sourceLane) const {
    int roadGroup = static_cast<int>(sourceLane) / 3;

    switch (direction) {
        case Direction::LEFT:
            // Left turns use the 3rd lane (freelane)
            return static_cast<LaneId>(roadGroup * 3 + 2);

        case Direction::RIGHT:
            // Right turns use the 1st lane
            return static_cast<LaneId>(roadGroup * 3);

        default: // STRAIGHT
            // Check queue sizes of 1st and 2nd lanes to balance
            LaneId lane1 = static_cast<LaneId>(roadGroup * 3);     // First lane
            LaneId lane2 = static_cast<LaneId>(roadGroup * 3 + 1); // Second lane

            size_t lane1Size = getLaneSize(lane1);
            size_t lane2Size = getLaneSize(lane2);

            // Choose lane with shortest queue
            return (lane1Size <= lane2Size) ? lane1 : lane2;
    }
}

bool TrafficManager::isValidSpawnLane(LaneId laneId, Direction direction) const {
    int laneInRoad = static_cast<int>(laneId) % 3;

    switch (direction) {
        case Direction::LEFT:  return laneInRoad == 2; // Only 3rd lane for left turns
        case Direction::RIGHT: return laneInRoad == 0; // 1st lane for right turns
        default:               return laneInRoad == 0 || laneInRoad == 1; // 1st or 2nd for straight
    }
}

void TrafficManager::processPriorityLane() {
    auto* priorityLane = getPriorityLane();
    if (!priorityLane) return;

    size_t initialSize = priorityLane->getQueueSize();
    size_t processCount = 0;

    // Process until below normal threshold or max count reached
    while (priorityLane->getQueueSize() > SimConstants::NORMAL_THRESHOLD &&
           processCount < initialSize) {
        auto vehicle = priorityLane->removeVehicle();
        if (vehicle) {
            vehicle->setProcessing(true);
            processCount++;
            totalVehiclesProcessed++;
        }
    }

    std::cout << "Priority mode: Processed " << processCount << " vehicles" << std::endl;
}

void TrafficManager::processNormalLanes(size_t vehicleCount) {
    if (vehicleCount == 0) return;

    // Count of vehicles to process per normal lane
    for (auto& lane : lanes) {
        if (!lane->isPriorityLane() && !isFreeLane(lane->getId())) {
            for (size_t i = 0; i < vehicleCount && lane->getQueueSize() > 0; ++i) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehicle->setProcessing(true);
                    totalVehiclesProcessed++;
                }
            }
        }
    }

    std::cout << "Normal mode: Processed " << vehicleCount << " vehicles per lane" << std::endl;
}

void TrafficManager::processFreeLanes() {
    // Free lanes (third lane of each road) always process all their vehicles
    for (auto& lane : lanes) {
        if (isFreeLane(lane->getId())) {
            size_t initialSize = lane->getQueueSize();
            size_t processCount = 0;

            while (lane->getQueueSize() > 0) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehicle->setProcessing(true);
                    processCount++;
                    totalVehiclesProcessed++;
                }
            }

            if (processCount > 0) {
                std::cout << "Free lane " << static_cast<int>(lane->getId())
                         << ": Processed " << processCount << " vehicles" << std::endl;
            }
        }
    }
}

size_t TrafficManager::calculateVehiclesToProcess() const {
    // Formula: |V| = (1/n) * Σ|Li|
    size_t totalVehicles = 0;
    size_t normalLaneCount = 0;

    for (const auto& lane : lanes) {
        if (!lane->isPriorityLane() && !isFreeLane(lane->getId())) {
            totalVehicles += lane->getQueueSize();
            normalLaneCount++;
        }
    }

    return normalLaneCount > 0 ?
        static_cast<size_t>(std::ceil(static_cast<float>(totalVehicles) / normalLaneCount)) : 0;
}

void TrafficManager::checkWaitTimes() {
    using namespace SimConstants;

    // Check if any vehicle has been waiting too long
    for (auto& lane : lanes) {
        if (lane->getQueueSize() > 0 && !isFreeLane(lane->getId())) {
            // Process vehicles with excessive wait time
            if (lane->getAverageWaitTime() > MAX_WAIT_TIME) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehicle->setProcessing(true);
                    totalVehiclesProcessed++;
                    std::cout << "Processing vehicle with excessive wait time: "
                             << vehicle->getId() << std::endl;
                }
            }
        }
    }
}

void TrafficManager::updateTimers(float deltaTime) {
    stateTimer += deltaTime;
    processingTimer += deltaTime;
    lastUpdateTime += deltaTime;
}

void TrafficManager::updateStatistics(float deltaTime) {
    // Update average wait time for vehicles
    float totalWaitTime = 0.0f;
    size_t waitingVehicles = 0;

    for (const auto& [_, vehicle] : activeVehicles) {
        if (!vehicle->isInProcess()) {
            totalWaitTime += vehicle->getWaitTime();
            waitingVehicles++;
        }
    }

    if (waitingVehicles > 0) {
        averageWaitTime = totalWaitTime / static_cast<float>(waitingVehicles);
    }
}

float TrafficManager::getAverageWaitingTime() const {
    return averageWaitTime;
}

bool TrafficManager::isFreeLane(LaneId laneId) const {
    return laneId == LaneId::AL3_FREELANE ||
           laneId == LaneId::BL3_FREELANE ||
           laneId == LaneId::CL3_FREELANE ||
           laneId == LaneId::DL3_FREELANE;
}

Lane* TrafficManager::getPriorityLane() const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [](const auto& lane) { return lane->isPriorityLane(); });
    return it != lanes.end() ? it->get() : nullptr;
}

void TrafficManager::cleanupFinishedVehicles() {
    // Remove vehicles that have left the scene
    std::vector<uint32_t> toRemove;

    for (const auto& [id, vehicle] : activeVehicles) {
        // Check if vehicle has exited the screen bounds
        float x = vehicle->getX();
        float y = vehicle->getY();

        bool outOfBounds = (
            x < -SimConstants::VEHICLE_WIDTH * 2 ||
            x > SimConstants::WINDOW_WIDTH + SimConstants::VEHICLE_WIDTH * 2 ||
            y < -SimConstants::VEHICLE_HEIGHT * 2 ||
            y > SimConstants::WINDOW_HEIGHT + SimConstants::VEHICLE_HEIGHT * 2
        );

        if (outOfBounds) {
            toRemove.push_back(id);
        }
    }

    // Remove the vehicles marked for removal
    for (uint32_t id : toRemove) {
        removeVehicle(id);
    }
}

void TrafficManager::removeVehicle(uint32_t vehicleId) {
    activeVehicles.erase(vehicleId);
}

bool TrafficManager::checkCollision(const std::shared_ptr<Vehicle>& vehicle, float newX, float newY) const {
    using namespace SimConstants;

    const float MIN_DISTANCE = VEHICLE_WIDTH * 1.5f;

    for (const auto& [otherId, otherVehicle] : activeVehicles) {
        if (otherId != vehicle->getId()) {
            float dx = newX - otherVehicle->getX();
            float dy = newY - otherVehicle->getY();
            float distance = std::sqrt(dx * dx + dy * dy);

            if (distance < MIN_DISTANCE) {
                return true;
            }
        }
    }

    return false;
}


================================================================================
File: src\traffic_generator.cpp
================================================================================

// src/traffic_generator.cpp
#include "traffic_generator.h"
#include <thread>
#include <fstream>
#include <iostream>
#include <sstream>
#include <ctime>

Generator::Generator()
    : nextVehicleId(1000)
{
    // Seed the random number generator
    std::random_device rd;
    rng = std::mt19937(rd());

    // Initialize lane files system
    initializeLaneFiles();

    // Setup configurations for each lane
    setupLaneConfigs();
}

void Generator::initializeLaneFiles() {
    // Create data directory
    dataDir = std::filesystem::current_path() / "data" / "lanes";
    if (!std::filesystem::exists(dataDir)) {
        std::filesystem::create_directories(dataDir);
    }

    // Initialize the individual lane files
    laneFiles[Constants::LaneId::AL1_INCOMING] = dataDir / "lane_a1.txt";
    laneFiles[Constants::LaneId::AL2_PRIORITY] = dataDir / "lane_a2.txt";
    laneFiles[Constants::LaneId::AL3_FREELANE] = dataDir / "lane_a3.txt";
    laneFiles[Constants::LaneId::BL1_INCOMING] = dataDir / "lane_b1.txt";
    laneFiles[Constants::LaneId::BL2_NORMAL] = dataDir / "lane_b2.txt";
    laneFiles[Constants::LaneId::BL3_FREELANE] = dataDir / "lane_b3.txt";
    laneFiles[Constants::LaneId::CL1_INCOMING] = dataDir / "lane_c1.txt";
    laneFiles[Constants::LaneId::CL2_NORMAL] = dataDir / "lane_c2.txt";
    laneFiles[Constants::LaneId::CL3_FREELANE] = dataDir / "lane_c3.txt";
    laneFiles[Constants::LaneId::DL1_INCOMING] = dataDir / "lane_d1.txt";
    laneFiles[Constants::LaneId::DL2_NORMAL] = dataDir / "lane_d2.txt";
    laneFiles[Constants::LaneId::DL3_FREELANE] = dataDir / "lane_d3.txt";

    // Create/clear all files
    clearAllFiles();

    // Also create a common vehicle data file for compatibility with C implementation
    std::ofstream combinedFile("vehicles.data", std::ios::trunc);
    if (!combinedFile) {
        std::cerr << "Failed to create vehicles.data file" << std::endl;
    }
}

void Generator::setupLaneConfigs() {
    // Set up spawn rates and lane configurations

    // Road A (West) configs
    laneConfigs[Constants::LaneId::AL1_INCOMING] = {0.6, 10, true, false, true};   // A1: Right/Straight
    laneConfigs[Constants::LaneId::AL2_PRIORITY] = {0.7, 15, true, false, false};  // A2: Straight only (priority)
    laneConfigs[Constants::LaneId::AL3_FREELANE] = {0.5, 8, false, true, false};   // A3: Left only

    // Road B (North) configs
    laneConfigs[Constants::LaneId::BL1_INCOMING] = {0.55, 10, true, false, true};  // B1: Right/Straight
    laneConfigs[Constants::LaneId::BL2_NORMAL] = {0.6, 12, true, false, false};    // B2: Straight only
    laneConfigs[Constants::LaneId::BL3_FREELANE] = {0.5, 8, false, true, false};   // B3: Left only

    // Road C (East) configs
    laneConfigs[Constants::LaneId::CL1_INCOMING] = {0.6, 10, true, false, true};   // C1: Right/Straight
    laneConfigs[Constants::LaneId::CL2_NORMAL] = {0.65, 12, true, false, false};   // C2: Straight only
    laneConfigs[Constants::LaneId::CL3_FREELANE] = {0.5, 8, false, true, false};   // C3: Left only

    // Road D (South) configs
    laneConfigs[Constants::LaneId::DL1_INCOMING] = {0.6, 10, true, false, true};   // D1: Right/Straight
    laneConfigs[Constants::LaneId::DL2_NORMAL] = {0.6, 12, true, false, false};    // D2: Straight only
    laneConfigs[Constants::LaneId::DL3_FREELANE] = {0.5, 8, false, true, false};   // D3: Left only
}

void Generator::generateTraffic() {
    // Try to generate traffic for each lane
    for (const auto& [laneId, config] : laneConfigs) {
        // Get current vehicle count
        size_t currentCount = countVehiclesInFile(laneFiles[laneId]);

        // Check if we should generate a new vehicle
        if (shouldGenerateVehicle(config, currentCount)) {
            // Determine direction based on lane rules
            Constants::Direction dir = getRandomDirection(config);

            // Create new vehicle ID and write to file
            uint32_t vehicleId = nextVehicleId++;
            writeVehicleToFile(laneFiles[laneId], vehicleId, dir);

            // Also write to combined file for C code compatibility
            writeVehicleToCombinedFile(laneId, vehicleId);

            // Log the generation
            logGeneration(laneId, vehicleId, dir, currentCount + 1, config.maxVehicles);
        }
    }
}

void Generator::writeVehicleToCombinedFile(Constants::LaneId lane, uint32_t id) {
    std::lock_guard<std::mutex> lock(fileMutex);

    // Determine which road this lane belongs to (A, B, C, D)
    char roadId;
    int laneNum;

    switch (static_cast<int>(lane) / 3) {
        case 0: roadId = 'A'; break;
        case 1: roadId = 'B'; break;
        case 2: roadId = 'C'; break;
        case 3: roadId = 'D'; break;
        default: roadId = 'X'; break;
    }

    // Determine lane number within the road (1, 2, 3)
    laneNum = static_cast<int>(lane) % 3 + 1;

    try {
        std::ofstream file("vehicles.data", std::ios::app);
        if (file) {
            // Format: "VEH1234_L2:A" for vehicle 1234 in lane 2 of road A
            file << "VEH" << id << "_L" << laneNum << ":" << roadId << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "Error writing to combined file: " << e.what() << std::endl;
    }
}

Constants::Direction Generator::getRandomDirection(const LaneConfig& config) {
    std::vector<Constants::Direction> possibleDirections;

    // Add possible directions based on configuration
    if (config.canGoStraight) possibleDirections.push_back(Constants::Direction::STRAIGHT);
    if (config.canGoLeft) possibleDirections.push_back(Constants::Direction::LEFT);
    if (config.canGoRight) possibleDirections.push_back(Constants::Direction::RIGHT);

    // If no directions allowed (shouldn't happen), default to straight
    if (possibleDirections.empty()) {
        return Constants::Direction::STRAIGHT;
    }

    // Select random direction from allowed set
    std::uniform_int_distribution<> dirDist(0, possibleDirections.size() - 1);
    return possibleDirections[dirDist(rng)];
}

size_t Generator::countVehiclesInFile(const std::filesystem::path& filepath) const {
    try {
        if (!std::filesystem::exists(filepath)) return 0;

        std::ifstream file(filepath);
        if (!file) return 0;

        size_t count = 0;
        std::string line;
        while (std::getline(file, line)) {
            if (!line.empty()) count++;
        }

        return count;
    } catch (const std::exception& e) {
        std::cerr << "Error counting vehicles: " << e.what() << std::endl;
        return 0;
    }
}

void Generator::writeVehicleToFile(const std::filesystem::path& filepath, uint32_t id,
                               Constants::Direction dir) {
    std::lock_guard<std::mutex> lock(fileMutex);

    try {
        std::ofstream file(filepath, std::ios::app);
        if (file) {
            char dirChar;
            switch (dir) {
                case Constants::Direction::STRAIGHT: dirChar = 'S'; break;
                case Constants::Direction::LEFT: dirChar = 'L'; break;
                case Constants::Direction::RIGHT: dirChar = 'R'; break;
                default: dirChar = 'S'; break;
            }

            // Format: "ID,DIRECTION;TIMESTAMP"
            file << id << "," << dirChar << ";" << std::time(nullptr) << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "Error writing to file: " << e.what() << std::endl;
    }
}

bool Generator::shouldGenerateVehicle(const LaneConfig& config, size_t currentCount) {
    // Check if lane is at capacity
    if (currentCount >= config.maxVehicles) {
        return false;
    }

    // Probability-based generation
    std::uniform_real_distribution<> dist(0.0, 1.0);
    return dist(rng) < config.spawnRate / (currentCount + 1); // Decreases as queue grows
}

void Generator::clearAllFiles() {
    std::lock_guard<std::mutex> lock(fileMutex);

    for (const auto& [_, filepath] : laneFiles) {
        try {
            std::ofstream file(filepath, std::ios::trunc);
        } catch (const std::exception& e) {
            std::cerr << "Error clearing file " << filepath << ": " << e.what() << std::endl;
        }
    }

    // Clear combined file too
    try {
        std::ofstream file("vehicles.data", std::ios::trunc);
    } catch (const std::exception& e) {
        std::cerr << "Error clearing vehicles.data: " << e.what() << std::endl;
    }
}

void Generator::logGeneration(Constants::LaneId lane, uint32_t vehicleId, Constants::Direction dir,
                          size_t currentCount, int maxCount) {
    std::cout << "Generated vehicle " << vehicleId << " in lane "
              << static_cast<int>(lane) << " (";

    // Print road/lane identifier
    char roadId;
    int laneNum = static_cast<int>(lane) % 3 + 1;

    switch (static_cast<int>(lane) / 3) {
        case 0: roadId = 'A'; break;
        case 1: roadId = 'B'; break;
        case 2: roadId = 'C'; break;
        case 3: roadId = 'D'; break;
        default: roadId = 'X'; break;
    }

    std::cout << roadId << laneNum << ") with direction ";

    switch (dir) {
        case Constants::Direction::STRAIGHT: std::cout << "STRAIGHT"; break;
        case Constants::Direction::LEFT: std::cout << "LEFT"; break;
        case Constants::Direction::RIGHT: std::cout << "RIGHT"; break;
    }

    std::cout << " [" << currentCount << "/" << maxCount << "]" << std::endl;
}

void Generator::displayStatus() const {
    // Clear console
    std::cout << "\033[2J\033[1;1H";

    std::cout << "=== Traffic Generator Status ===" << std::endl;
    std::cout << "Next Vehicle ID: " << nextVehicleId << std::endl;
    std::cout << std::endl;

    // Display lane statistics
    std::cout << "Lane Statistics:" << std::endl;
    std::cout << "----------------" << std::endl;

    for (const auto& [laneId, filepath] : laneFiles) {
        size_t count = countVehiclesInFile(filepath);
        const auto& config = laneConfigs.at(laneId);

        // Get lane name
        char roadId;
        int laneNum = static_cast<int>(laneId) % 3 + 1;

        switch (static_cast<int>(laneId) / 3) {
            case 0: roadId = 'A'; break;
            case 1: roadId = 'B'; break;
            case 2: roadId = 'C'; break;
            case 3: roadId = 'D'; break;
            default: roadId = 'X'; break;
        }

        std::cout << "Lane " << roadId << laneNum << ": ";

        // Special indicators
        if (laneNum == 2 && roadId == 'A') std::cout << "[PRIORITY] ";
        if (laneNum == 3) std::cout << "[FREE] ";

        // Display count and capacity
        std::cout << count << "/" << config.maxVehicles;

        // Directions allowed
        std::cout << " Directions: ";
        if (config.canGoStraight) std::cout << "S";
        if (config.canGoLeft) std::cout << "L";
        if (config.canGoRight) std::cout << "R";

        std::cout << std::endl;
    }
}

int main() {
    Generator generator;

    std::cout << "Traffic Generator Started" << std::endl;
    std::cout << "Press Ctrl+C to exit" << std::endl;

    while (true) {
        generator.generateTraffic();
        generator.displayStatus();
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    }

    return 0;
}


================================================================================
File: src\utils\Queue.cpp
================================================================================

// include/utils/Queue.hpp
#pragma once
#include <memory>
#include <stdexcept>

template<typename T>
class Queue {
protected:
    struct Node {
        T data;
        std::shared_ptr<Node> next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::shared_ptr<Node> front;
    std::shared_ptr<Node> rear;
    size_t size;

public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}

    virtual ~Queue() = default;

    void enqueue(const T& value) {
        auto newNode = std::make_shared<Node>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    T dequeue() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    bool isEmpty() const {
        return front == nullptr;
    }

    size_t getSize() const {
        return size;
    }

    T peek() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return front->data;
    }
};


================================================================================
File: src\utils\vector2d.h
================================================================================



================================================================================
File: src\visualization\DebugOverlay.cpp
================================================================================

// src/visualization/DebugOverlay.cpp
#include <cmath>
#include "visualization/DebugOverlay.h"

void DebugOverlay::render(SDL_Renderer* renderer, const TrafficManager& trafficManager) {
    // Draw background for debug panel
    SDL_FRect debugPanel = {10.0f, 10.0f, 200.0f, 300.0f};
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200);
    SDL_RenderFillRect(renderer, &debugPanel);

    // Priority mode indicator
    if (trafficManager.isInPriorityMode()) {
        SDL_FRect priorityIndicator = {20.0f, 20.0f, 20.0f, 20.0f};
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderFillRect(renderer, &priorityIndicator);
    }

    // Queue lengths visualization
    int yOffset = 50;
    for (const auto& lane : trafficManager.getLanes()) {
        SDL_FRect queueBar = {
            20.0f,
            static_cast<float>(yOffset),
            static_cast<float>(lane->getQueueSize() * 5),
            15.0f
        };

        // Color based on lane type
        if (lane->isPriorityLane()) {
            SDL_SetRenderDrawColor(renderer, 255, 100, 100, 255);
        } else if (lane->getId() == LaneId::AL3_FREELANE ||
                   lane->getId() == LaneId::BL3_FREELANE ||
                   lane->getId() == LaneId::CL3_FREELANE ||
                   lane->getId() == LaneId::DL3_FREELANE) {
            SDL_SetRenderDrawColor(renderer, 100, 255, 100, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 100, 150, 255, 255);
        }

        SDL_RenderFillRect(renderer, &queueBar);
        yOffset += 20;
    }
}

void DebugOverlay::updateStatistics(const TrafficManager& trafficManager) {
    for (const auto& lane : trafficManager.getLanes()) {
        LaneStatistics& laneStat = stats[lane->getId()];
        laneStat.vehicleCount = static_cast<int>(lane->getQueueSize());
    }
}

void DebugOverlay::renderQueueStats(SDL_Renderer* renderer, int x, int y) {
    int yOffset = y;
    for (const auto& [laneId, stat] : stats) {
        SDL_FRect bar = {
            static_cast<float>(x + 10),
            static_cast<float>(yOffset),
            static_cast<float>(stat.vehicleCount * 5),
            15.0f
        };

        if (stat.vehicleCount > 10) {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        } else if (stat.vehicleCount > 5) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        }

        SDL_RenderFillRect(renderer, &bar);
        yOffset += 20;
    }
}

void DebugOverlay::renderLaneLoadIndicator(SDL_Renderer* renderer, int x, int y) {
    const float RADIUS = 50.0f;
    const int SEGMENTS = 12;
    const float TWO_PI = static_cast<float>(2.0 * M_PI);

    for (int i = 0; i < SEGMENTS; i++) {
        float startAngle = (TWO_PI * i) / SEGMENTS;
        float endAngle = (TWO_PI * (i + 1)) / SEGMENTS;

        float startX = x + RADIUS * cosf(startAngle);
        float startY = y + RADIUS * sinf(startAngle);
        float endX = x + RADIUS * cosf(endAngle);
        float endY = y + RADIUS * sinf(endAngle);

        // Color based on load
        int laneIndex = i % 4;
        LaneId laneId = static_cast<LaneId>(laneIndex);
        int load = stats[laneId].vehicleCount;

        if (load > 10) {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        } else if (load > 5) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        }

        SDL_RenderLine(renderer, startX, startY, endX, endY);
    }
}

void DebugOverlay::renderSystemStatus(SDL_Renderer* renderer, int x, int y) {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    // TODO: Add text rendering for system status when needed
}


================================================================================
File: src\visualization\Renderer.cpp
================================================================================

// src/visualization/Renderer.cpp
#include "visualization/Renderer.h"
#include <iostream>
#include <cmath>

// Constructor
Renderer::Renderer()
    : window(nullptr)
    , renderer(nullptr)
    , debugMode(false)
    , showGrid(false) {
}

// Destructor
Renderer::~Renderer() {
    cleanup();
}

bool Renderer::initialize() {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        std::cerr << "Failed to initialize SDL: " << SDL_GetError() << std::endl;
        return false;
    }

    window = SDL_CreateWindow(
        "Traffic Junction Simulator",
        SimConstants::WINDOW_WIDTH,
        SimConstants::WINDOW_HEIGHT,
        SDL_WINDOW_RESIZABLE
    );

    if (!window) {
        std::cerr << "Window creation failed: " << SDL_GetError() << std::endl;
        return false;
    }

    renderer = SDL_CreateRenderer(window, nullptr);
    if (!renderer) {
        std::cerr << "Renderer creation failed: " << SDL_GetError() << std::endl;
        return false;
    }

    return true;
}

void Renderer::cleanup() {
    if (renderer) {
        SDL_DestroyRenderer(renderer);
        renderer = nullptr;
    }
    if (window) {
        SDL_DestroyWindow(window);
        window = nullptr;
    }
    SDL_Quit();
}

void Renderer::render(const TrafficManager& trafficManager) {
    // Clear screen with black background
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    // Core rendering
    renderBackground();
    renderRoads();
    renderLanes();
    renderIntersection();
    renderCrosswalks();
    renderStopLines();
    renderDirectionalArrows();

    // Traffic elements
    renderTrafficLights(trafficManager.getTrafficLights());
    renderVehicles(trafficManager.getActiveVehicles());

    // Priority mode indicators
    if (trafficManager.isInPriorityMode()) {
        renderPriorityLaneIndicator();
    }

    // Debug visualization
    if (debugMode) {
        if (showGrid) {
            drawDebugGrid();
        }
        renderLaneIdentifiers();
        renderVehicleCount(trafficManager);
    }

    SDL_RenderPresent(renderer);
}

void Renderer::renderBackground() {
    // Create a gradient sky effect
    for (int y = 0; y < SimConstants::WINDOW_HEIGHT; ++y) {
        float t = static_cast<float>(y) / SimConstants::WINDOW_HEIGHT;
        uint8_t skyR = static_cast<uint8_t>(135 * (1 - t) + 30 * t);
        uint8_t skyG = static_cast<uint8_t>(206 * (1 - t) + 30 * t);
        uint8_t skyB = static_cast<uint8_t>(235 * (1 - t) + 30 * t);

        SDL_SetRenderDrawColor(renderer, skyR, skyG, skyB, 255);
        SDL_RenderLine(renderer, 0, y, SimConstants::WINDOW_WIDTH, y);
    }

    // Render grass areas with texture
    renderGrassAreas();
}

void Renderer::renderGrassAreas() {
    using namespace SimConstants;
    SDL_SetRenderDrawColor(renderer, 34, 139, 34, 255); // Base grass color

    // Define the four corner grass areas around the intersection
    SDL_FRect grassAreas[] = {
        // Top-left quadrant
        {0, 0, CENTER_X - ROAD_WIDTH/2.0f, CENTER_Y - ROAD_WIDTH/2.0f},
        // Top-right quadrant
        {CENTER_X + ROAD_WIDTH/2.0f, 0,
         static_cast<float>(WINDOW_WIDTH) - (CENTER_X + ROAD_WIDTH/2.0f),
         CENTER_Y - ROAD_WIDTH/2.0f},
        // Bottom-left quadrant
        {0, CENTER_Y + ROAD_WIDTH/2.0f,
         CENTER_X - ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_HEIGHT) - (CENTER_Y + ROAD_WIDTH/2.0f)},
        // Bottom-right quadrant
        {CENTER_X + ROAD_WIDTH/2.0f, CENTER_Y + ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_WIDTH) - (CENTER_X + ROAD_WIDTH/2.0f),
         static_cast<float>(WINDOW_HEIGHT) - (CENTER_Y + ROAD_WIDTH/2.0f)}
    };

    // Fill base grass areas
    for (const auto& area : grassAreas) {
        SDL_RenderFillRect(renderer, &area);
    }

    // Add grass texture variation using random dots
    SDL_SetRenderDrawColor(renderer, 28, 120, 28, 255);
    for (int i = 0; i < 2000; i++) {
        int x = rand() % WINDOW_WIDTH;
        int y = rand() % WINDOW_HEIGHT;

        // Check if point is in grass area (not on road)
        bool inRoad = (x > CENTER_X - ROAD_WIDTH/2 && x < CENTER_X + ROAD_WIDTH/2) ||
                     (y > CENTER_Y - ROAD_WIDTH/2 && y < CENTER_Y + ROAD_WIDTH/2);

        if (!inRoad) {
            SDL_RenderPoint(renderer, x, y);
        }
    }
}

void Renderer::renderRoads() {
    using namespace SimConstants;

    // Main road surface with asphalt texture
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);

    // Draw horizontal road
    SDL_FRect horizontalRoad = {
        0, CENTER_Y - ROAD_WIDTH/2.0f,
        static_cast<float>(WINDOW_WIDTH),
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &horizontalRoad);

    // Draw vertical road
    SDL_FRect verticalRoad = {
        CENTER_X - ROAD_WIDTH/2.0f, 0,
        static_cast<float>(ROAD_WIDTH),
        static_cast<float>(WINDOW_HEIGHT)
    };
    SDL_RenderFillRect(renderer, &verticalRoad);

    // Add road edges and curbs
    renderRoadEdges();
}

void Renderer::renderRoadEdges() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 150, 150, 150, 255);
    const float CURB_WIDTH = 4.0f;

    // Render curbs for all road edges
    SDL_FRect curbs[] = {
        // Horizontal road curbs
        {0, CENTER_Y - ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_WIDTH), CURB_WIDTH},
        {0, CENTER_Y + ROAD_WIDTH/2.0f - CURB_WIDTH,
         static_cast<float>(WINDOW_WIDTH), CURB_WIDTH},

        // Vertical road curbs
        {CENTER_X - ROAD_WIDTH/2.0f, 0,
         CURB_WIDTH, static_cast<float>(WINDOW_HEIGHT)},
        {CENTER_X + ROAD_WIDTH/2.0f - CURB_WIDTH, 0,
         CURB_WIDTH, static_cast<float>(WINDOW_HEIGHT)}
    };

    for (const auto& curb : curbs) {
        SDL_RenderFillRect(renderer, &curb);
    }
}

void Renderer::renderLanes() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    float laneWidth = ROAD_WIDTH / 3.0f;

    // Draw horizontal lane dividers
    for (int i = 1; i < 3; i++) {
        float y = CENTER_Y - ROAD_WIDTH/2.0f + i * laneWidth;
        renderDashedLine(0, y, WINDOW_WIDTH, y);
    }

    // Draw vertical lane dividers
    for (int i = 1; i < 3; i++) {
        float x = CENTER_X - ROAD_WIDTH/2.0f + i * laneWidth;
        renderDashedLine(x, 0, x, WINDOW_HEIGHT);
    }

    // Render special lane markings
    renderPriorityLane();
}

void Renderer::renderPriorityLane() {
    using namespace SimConstants;

    // Highlight AL2 priority lane with semi-transparent orange
    SDL_SetRenderDrawColor(renderer, 255, 165, 0, 100);
    float laneWidth = ROAD_WIDTH / 3.0f;

    SDL_FRect priorityLane = {
        0,
        CENTER_Y - laneWidth/2.0f,
        static_cast<float>(CENTER_X - ROAD_WIDTH/2.0f),
        laneWidth
    };

    SDL_RenderFillRect(renderer, &priorityLane);
}

void Renderer::renderTrafficLight(float x, float y, float rotation, LightState state) {
    // Constants for traffic light dimensions
    const float LIGHT_SPACING = 15.0f;        // Space between each light
    const float LIGHT_RADIUS = LIGHT_SIZE/2.0f;

    // Calculate oriented position for the traffic light housing
    float orientedX = x;
    float orientedY = y;

    // Apply rotation if needed to orient the traffic light correctly
    if (rotation != 0.0f) {
        SDL_FPoint rotated = rotatePoint(x, y,
            static_cast<float>(SimConstants::CENTER_X),
            static_cast<float>(SimConstants::CENTER_Y),
            rotation
        );
        orientedX = rotated.x;
        orientedY = rotated.y;
    }

    // Draw the traffic light housing (black background box)
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 255);  // Dark gray color
    SDL_FRect housing = {
        orientedX - HOUSING_PADDING,
        orientedY - HOUSING_PADDING,
        LIGHT_SIZE + (HOUSING_PADDING * 2.0f),
        (LIGHT_SIZE * 3.0f) + (HOUSING_PADDING * 4.0f)  // Room for three lights
    };
    SDL_RenderFillRect(renderer, &housing);

    // Draw outline for the housing
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);  // Lighter gray for border
    SDL_RenderRect(renderer, &housing);

    // Calculate positions for each light
    float centerX = orientedX + LIGHT_SIZE/2.0f;
    float redY = orientedY + LIGHT_SIZE/2.0f;
    float yellowY = redY + LIGHT_SIZE + LIGHT_SPACING;
    float greenY = yellowY + LIGHT_SIZE + LIGHT_SPACING;

    // Draw red light
    SDL_SetRenderDrawColor(renderer,
        state == LightState::RED ? 255 : 64,  // Bright red when active, dim when inactive
        0, 0, 255);
    renderCircle(centerX, redY, LIGHT_RADIUS);

    // Draw yellow light (always dim in two-state system)
    SDL_SetRenderDrawColor(renderer, 64, 64, 0, 255);
    renderCircle(centerX, yellowY, LIGHT_RADIUS);

    // Draw green light
    SDL_SetRenderDrawColor(renderer, 0,
        state == LightState::GREEN ? 255 : 64,  // Bright green when active, dim when inactive
        0, 255);
    renderCircle(centerX, greenY, LIGHT_RADIUS);
}

void Renderer::renderTrafficLights(const std::map<LaneId, TrafficLight>& lights) {
    using namespace SimConstants;

    // Define the standard positions for traffic lights
    struct LightPosition {
        float x;
        float y;
        float rotation;
        LaneId laneId;
    };

    // Define fixed positions for each traffic light
    const LightPosition positions[] = {
        // West approach (AL2 - Priority lane)
        {
            static_cast<float>(CENTER_X - ROAD_WIDTH/2.0f - 50.0f),
            static_cast<float>(CENTER_Y - LIGHT_SIZE * 3.0f),
            0.0f,
            LaneId::AL2_PRIORITY
        },
        // North approach (BL2)
        {
            static_cast<float>(CENTER_X - LIGHT_SIZE * 3.0f),
            static_cast<float>(CENTER_Y - ROAD_WIDTH/2.0f - 50.0f),
            90.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::BL2_NORMAL
        },
        // East approach (CL2)
        {
            static_cast<float>(CENTER_X + ROAD_WIDTH/2.0f + 50.0f),
            static_cast<float>(CENTER_Y - LIGHT_SIZE * 3.0f),
            180.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::CL2_NORMAL
        },
        // South approach (DL2)
        {
            static_cast<float>(CENTER_X - LIGHT_SIZE * 3.0f),
            static_cast<float>(CENTER_Y + ROAD_WIDTH/2.0f + 50.0f),
            270.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::DL2_NORMAL
        }
    };

    // Render each traffic light
    for (const auto& position : positions) {
        auto it = lights.find(position.laneId);
        if (it != lights.end()) {
            renderTrafficLight(
                position.x,
                position.y,
                position.rotation,
                it->second.getState()
            );
        }
    }
}

void Renderer::renderVehicles(const std::map<uint32_t, std::shared_ptr<Vehicle>>& vehicles) {
    for (const auto& [id, vehicle] : vehicles) {
        // Get vehicle data for rendering
        float x = vehicle->getX();
        float y = vehicle->getY();
        Direction dir = vehicle->getDirection();
        bool isPriority = vehicle->getCurrentLane() == LaneId::AL2_PRIORITY;
        float angle = vehicle->getAngle();
        bool isMoving = vehicle->isInProcess();

        // Render the vehicle
        renderVehicle(x, y, dir, isPriority, angle, isMoving);
    }
}

void Renderer::renderVehicle(float x, float y, Direction dir, bool isPriority, float angle, bool isMoving) {
    const float halfWidth = VEHICLE_WIDTH / 2.0f;
    const float halfHeight = VEHICLE_HEIGHT / 2.0f;

    // Create a smoother vehicle shape
    SDL_FPoint vertices[8] = {
        // Front
        {x + (halfWidth * 0.8f) * cosf(angle), y + (halfWidth * 0.8f) * sinf(angle)},
        // Front right
        {x + halfWidth * cosf(angle + 0.4f), y + halfWidth * sinf(angle + 0.4f)},
        // Right
        {x + halfWidth * cosf(angle + M_PI/2), y + halfWidth * sinf(angle + M_PI/2)},
        // Back right
        {x + halfWidth * cosf(angle + M_PI - 0.4f), y + halfWidth * sinf(angle + M_PI - 0.4f)},
        // Back
        {x - (halfWidth * 0.8f) * cosf(angle), y - (halfWidth * 0.8f) * sinf(angle)},
        // Back left
        {x + halfWidth * cosf(angle + M_PI + 0.4f), y + halfWidth * sinf(angle + M_PI + 0.4f)},
        // Left
        {x + halfWidth * cosf(angle - M_PI/2), y + halfWidth * sinf(angle - M_PI/2)},
        // Front left
        {x + halfWidth * cosf(angle - 0.4f), y + halfWidth * sinf(angle - 0.4f)}
    };

    // Draw shadow
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 100);
    for (int i = 0; i < 8; i++) {
        SDL_RenderLine(renderer,
            vertices[i].x + 2, vertices[i].y + 2,
            vertices[(i + 1) % 8].x + 2, vertices[(i + 1) % 8].y + 2);
    }

    // Vehicle body color
    if (isPriority) {
        SDL_SetRenderDrawColor(renderer, 255, 140, 0, 255); // Orange for priority
    } else {
        SDL_SetRenderDrawColor(renderer, 30, 144, 255, 255); // Blue for normal
    }

    // Draw vehicle body
    for (int i = 0; i < 8; i++) {
        SDL_RenderLine(renderer,
            vertices[i].x, vertices[i].y,
            vertices[(i + 1) % 8].x, vertices[(i + 1) % 8].y);
    }

    // Draw headlights
    SDL_SetRenderDrawColor(renderer, 255, 255, 200, 255);
    renderCircle(vertices[0].x - 5 * cosf(angle + 0.2f),
                vertices[0].y - 5 * sinf(angle + 0.2f), 3);
    renderCircle(vertices[0].x - 5 * cosf(angle - 0.2f),
                vertices[0].y - 5 * sinf(angle - 0.2f), 3);

    // Direction indicators
    if (dir != Direction::STRAIGHT) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 0, 200);
        if (dir == Direction::LEFT) {
            renderCircle(vertices[6].x, vertices[6].y, 4);
        } else {
            renderCircle(vertices[2].x, vertices[2].y, 4);
        }
    }

    // Movement trail
    if (isMoving) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 50);
        float t = static_cast<float>(SDL_GetTicks()) / 1000.0f;
        for (int i = 1; i <= 3; i++) {
            float offset = i * (5.0f + sinf(t * 4.0f) * 2.0f);
            float trailX = x - offset * cosf(angle);
            float trailY = y - offset * sinf(angle);
            renderCircle(trailX, trailY, 2);
        }
    }
}

void Renderer::renderIntersection() {
    using namespace SimConstants;

    // Draw intersection box with slightly darker asphalt
    SDL_SetRenderDrawColor(renderer, 45, 45, 45, 255);
    SDL_FRect intersection = {
        CENTER_X - ROAD_WIDTH/2.0f,
        CENTER_Y - ROAD_WIDTH/2.0f,
        static_cast<float>(ROAD_WIDTH),
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &intersection);

    // Draw intersection guidelines
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 100);

    // Center cross guidelines
    renderDashedLine(
        CENTER_X - ROAD_WIDTH/2.0f, CENTER_Y,
        CENTER_X + ROAD_WIDTH/2.0f, CENTER_Y
    );
    renderDashedLine(
        CENTER_X, CENTER_Y - ROAD_WIDTH/2.0f,
        CENTER_X, CENTER_Y + ROAD_WIDTH/2.0f
    );

    // Draw turning guide arcs
    renderTurningGuides();
}

void Renderer::renderTurningGuides() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 50);
    const int SEGMENTS = 32;
    const float TURN_RADIUS = ROAD_WIDTH / 2.0f;

    // Draw turning guide arcs for each corner
    for (int corner = 0; corner < 4; corner++) {
        float centerX = CENTER_X + ((corner & 1) ? ROAD_WIDTH/4.0f : -ROAD_WIDTH/4.0f);
        float centerY = CENTER_Y + ((corner & 2) ? ROAD_WIDTH/4.0f : -ROAD_WIDTH/4.0f);

        for (int i = 0; i < SEGMENTS; i++) {
            float startAngle = (corner * 90 + i * 90.0f / SEGMENTS) * M_PI / 180.0f;
            float endAngle = (corner * 90 + (i + 1) * 90.0f / SEGMENTS) * M_PI / 180.0f;

            float x1 = centerX + TURN_RADIUS * cosf(startAngle);
            float y1 = centerY + TURN_RADIUS * sinf(startAngle);
            float x2 = centerX + TURN_RADIUS * cosf(endAngle);
            float y2 = centerY + TURN_RADIUS * sinf(endAngle);

            SDL_RenderLine(renderer, x1, y1, x2, y2);
        }
    }
}

void Renderer::renderStopLines() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float STOP_LINE_WIDTH = 8.0f;
    const float OFFSET = ROAD_WIDTH/2.0f - 20.0f;

    // Draw stop lines at each intersection approach
    SDL_FRect stopLines[] = {
        // West approach
        {CENTER_X - OFFSET - STOP_LINE_WIDTH,
         CENTER_Y - LANE_WIDTH,
         STOP_LINE_WIDTH,
         LANE_WIDTH * 2},

        // North approach
        {CENTER_X - LANE_WIDTH,
         CENTER_Y - OFFSET - STOP_LINE_WIDTH,
         LANE_WIDTH * 2,
         STOP_LINE_WIDTH},

        // East approach
        {CENTER_X + OFFSET,
         CENTER_Y - LANE_WIDTH,
         STOP_LINE_WIDTH,
         LANE_WIDTH * 2},

        // South approach
        {CENTER_X - LANE_WIDTH,
         CENTER_Y + OFFSET,
         LANE_WIDTH * 2,
         STOP_LINE_WIDTH}
    };

    for (const auto& line : stopLines) {
        SDL_RenderFillRect(renderer, &line);
    }
}

void Renderer::renderDirectionalArrows() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 128);
    const float ARROW_DISTANCE = 150.0f;

    // Draw direction arrows for each lane
    for (int lane = -1; lane <= 1; lane++) {
        float laneOffset = static_cast<float>(lane * LANE_WIDTH);

        // West approach (right-side driving)
        drawArrow(CENTER_X - ARROW_DISTANCE, CENTER_Y + laneOffset,
                 0.0f, Direction::STRAIGHT);

        // North approach
        drawArrow(CENTER_X + laneOffset, CENTER_Y - ARROW_DISTANCE,
                 static_cast<float>(M_PI / 2), Direction::STRAIGHT);

        // East approach
        drawArrow(CENTER_X + ARROW_DISTANCE, CENTER_Y + laneOffset,
                 static_cast<float>(M_PI), Direction::STRAIGHT);

        // South approach
        drawArrow(CENTER_X + laneOffset, CENTER_Y + ARROW_DISTANCE,
                 static_cast<float>(-M_PI / 2), Direction::STRAIGHT);
    }

    // Add left turn arrows for free lanes
    drawArrow(CENTER_X - ARROW_DISTANCE, CENTER_Y + LANE_WIDTH,
             0.0f, Direction::LEFT);
    drawArrow(CENTER_X + LANE_WIDTH, CENTER_Y - ARROW_DISTANCE,
             static_cast<float>(M_PI / 2), Direction::LEFT);
    drawArrow(CENTER_X + ARROW_DISTANCE, CENTER_Y + LANE_WIDTH,
             static_cast<float>(M_PI), Direction::LEFT);
    drawArrow(CENTER_X + LANE_WIDTH, CENTER_Y + ARROW_DISTANCE,
             static_cast<float>(-M_PI / 2), Direction::LEFT);
}

void Renderer::drawArrow(float x, float y, float angle, Direction dir) {
    const float ARROW_LENGTH = 30.0f;
    const float HEAD_SIZE = 10.0f;
    const float HEAD_ANGLE = static_cast<float>(M_PI / 6);

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    // Draw arrow shaft
    float endX = x + ARROW_LENGTH * cosA;
    float endY = y + ARROW_LENGTH * sinA;
    SDL_RenderLine(renderer, x, y, endX, endY);

    // Draw arrow head
    float leftX = endX - HEAD_SIZE * cosf(angle + HEAD_ANGLE);
    float leftY = endY - HEAD_SIZE * sinf(angle + HEAD_ANGLE);
    float rightX = endX - HEAD_SIZE * cosf(angle - HEAD_ANGLE);
    float rightY = endY - HEAD_SIZE * sinf(angle - HEAD_ANGLE);

    SDL_RenderLine(renderer, endX, endY, leftX, leftY);
    SDL_RenderLine(renderer, endX, endY, rightX, rightY);

    // Add curved arrow for left turns
    if (dir == Direction::LEFT) {
        const float CURVE_RADIUS = 15.0f;
        const int SEGMENTS = 8;

        for (int i = 0; i < SEGMENTS; i++) {
            float startAngle = angle - M_PI/2 + (i * M_PI/2) / SEGMENTS;
            float endAngle = angle - M_PI/2 + ((i + 1) * M_PI/2) / SEGMENTS;

            float x1 = x + CURVE_RADIUS * cosf(startAngle);
            float y1 = y + CURVE_RADIUS * sinf(startAngle);
            float x2 = x + CURVE_RADIUS * cosf(endAngle);
            float y2 = y + CURVE_RADIUS * sinf(endAngle);

            SDL_RenderLine(renderer, x1, y1, x2, y2);
        }
    }
}

void Renderer::renderCircle(float x, float y, float radius) {
    const int SEGMENTS = 16;
    for (int i = 0; i < SEGMENTS; i++) {
        float angle1 = 2.0f * M_PI * i / SEGMENTS;
        float angle2 = 2.0f * M_PI * (i + 1) / SEGMENTS;

        SDL_RenderLine(renderer,
            x + radius * cosf(angle1),
            y + radius * sinf(angle1),
            x + radius * cosf(angle2),
            y + radius * sinf(angle2)
        );
    }
}

void Renderer::renderDashedLine(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    float length = std::sqrt(dx * dx + dy * dy);
    float nx = dx / length;
    float ny = dy / length;

    float x = x1;
    float y = y1;
    bool drawing = true;
    float remainingLength = length;

    while (remainingLength > 0) {
        float segmentLength = std::min(drawing ? DASH_LENGTH : GAP_LENGTH, remainingLength);

        if (drawing) {
            float endX = x + nx * segmentLength;
            float endY = y + ny * segmentLength;
            SDL_RenderLine(renderer, x, y, endX, endY);
        }

        x += nx * segmentLength;
        y += ny * segmentLength;
        remainingLength -= segmentLength;
        drawing = !drawing;
    }
}

void Renderer::renderCrosswalks() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float STRIPE_WIDTH = 5.0f;
    const float STRIPE_LENGTH = 30.0f;
    const float STRIPE_GAP = 5.0f;
    const float CROSSWALK_WIDTH = 20.0f;

    // Render crosswalks on all four sides of the intersection
    for (int i = 0; i < 4; ++i) {
        float angle = static_cast<float>(i * 90) * static_cast<float>(M_PI) / 180.0f;
        float baseX = CENTER_X + cosf(angle) * (ROAD_WIDTH / 2.0f - CROSSWALK_WIDTH);
        float baseY = CENTER_Y + sinf(angle) * (ROAD_WIDTH / 2.0f - CROSSWALK_WIDTH);

        // Draw zebra stripes
        for (float offset = 0; offset < ROAD_WIDTH; offset += STRIPE_WIDTH + STRIPE_GAP) {
            SDL_FPoint p1 = rotatePoint(baseX, baseY + offset, CENTER_X, CENTER_Y, angle);
            SDL_FPoint p2 = rotatePoint(baseX + STRIPE_LENGTH, baseY + offset, CENTER_X, CENTER_Y, angle);

            SDL_FRect stripe = {
                p1.x, p1.y,
                STRIPE_WIDTH,
                p2.y - p1.y
            };
            SDL_RenderFillRect(renderer, &stripe);
        }
    }
}

void Renderer::renderPriorityLaneIndicator() {
    using namespace SimConstants;

    // Draw priority mode indicator in top-left corner
    const float INDICATOR_SIZE = 30.0f;
    const float PADDING = 10.0f;

    SDL_SetRenderDrawColor(renderer, 255, 69, 0, 255); // Orange for priority
    SDL_FRect indicator = {
        PADDING,
        PADDING,
        INDICATOR_SIZE,
        INDICATOR_SIZE
    };
    SDL_RenderFillRect(renderer, &indicator);

    // Add pulsing effect
    float t = static_cast<float>(SDL_GetTicks()) / 1000.0f;
    uint8_t alpha = static_cast<uint8_t>(128 + 127 * sinf(t * 2.0f));
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, alpha);
    SDL_RenderRect(renderer, &indicator);
}

void Renderer::renderLaneIdentifiers() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float OFFSET = ROAD_WIDTH / 2.0f + 30.0f;

    // Define lane positions and labels
    struct LaneLabel {
        float x, y;
        LaneId id;
    };

    LaneLabel labels[] = {
        {CENTER_X - OFFSET, CENTER_Y - LANE_WIDTH, LaneId::AL1_INCOMING},
        {CENTER_X - OFFSET, CENTER_Y, LaneId::AL2_PRIORITY},
        {CENTER_X - OFFSET, CENTER_Y + LANE_WIDTH, LaneId::AL3_FREELANE},

        {CENTER_X - LANE_WIDTH, CENTER_Y - OFFSET, LaneId::BL1_INCOMING},
        {CENTER_X, CENTER_Y - OFFSET, LaneId::BL2_NORMAL},
        {CENTER_X + LANE_WIDTH, CENTER_Y - OFFSET, LaneId::BL3_FREELANE},

        {CENTER_X + OFFSET, CENTER_Y - LANE_WIDTH, LaneId::CL1_INCOMING},
        {CENTER_X + OFFSET, CENTER_Y, LaneId::CL2_NORMAL},
        {CENTER_X + OFFSET, CENTER_Y + LANE_WIDTH, LaneId::CL3_FREELANE},

        {CENTER_X - LANE_WIDTH, CENTER_Y + OFFSET, LaneId::DL1_INCOMING},
        {CENTER_X, CENTER_Y + OFFSET, LaneId::DL2_NORMAL},
        {CENTER_X + LANE_WIDTH, CENTER_Y + OFFSET, LaneId::DL3_FREELANE}
    };

    // Draw background rectangles for labels
    for (const auto& label : labels) {
        SDL_FRect bg = {
            label.x - 25.0f,
            label.y - 12.0f,
            50.0f,
            24.0f
        };

        // Different colors for different lane types
        if (label.id == LaneId::AL2_PRIORITY) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 128); // Orange for priority
        } else if (static_cast<int>(label.id) % 3 == 2) {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 128); // Green for free lanes
        } else {
            SDL_SetRenderDrawColor(renderer, 100, 100, 100, 128); // Gray for normal lanes
        }

        SDL_RenderFillRect(renderer, &bg);
    }
}

void Renderer::renderVehicleCount(const TrafficManager& trafficManager) {
    using namespace SimConstants;

    const float PADDING = 10.0f;
    const float BOX_WIDTH = 150.0f;
    const float BOX_HEIGHT = 80.0f;

    // Draw background panel
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200);
    SDL_FRect countBox = {
        PADDING,
        WINDOW_HEIGHT - BOX_HEIGHT - PADDING,
        BOX_WIDTH,
        BOX_HEIGHT
    };
    SDL_RenderFillRect(renderer, &countBox);

    // Draw separator lines
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 128);
    SDL_RenderLine(renderer,
        countBox.x,
        countBox.y + BOX_HEIGHT / 2.0f,
        countBox.x + BOX_WIDTH,
        countBox.y + BOX_HEIGHT / 2.0f
    );
}

void Renderer::drawDebugGrid() {
    SDL_SetRenderDrawColor(renderer, 128, 128, 128, 64);

    // Draw vertical grid lines
    for (float x = 0.0f; x < static_cast<float>(SimConstants::WINDOW_WIDTH); x += 50.0f) {
        SDL_RenderLine(renderer,
            static_cast<int>(x), 0,
            static_cast<int>(x), SimConstants::WINDOW_HEIGHT
        );
    }

    // Draw horizontal grid lines
    for (float y = 0.0f; y < static_cast<float>(SimConstants::WINDOW_HEIGHT); y += 50.0f) {
        SDL_RenderLine(renderer,
            0, static_cast<int>(y),
            SimConstants::WINDOW_WIDTH, static_cast<int>(y)
        );
    }
}

SDL_FPoint Renderer::rotatePoint(float x, float y, float cx, float cy, float angle) {
    // First, translate point back to origin by subtracting center coordinates
    float translatedX = x - cx;
    float translatedY = y - cy;

    // Perform the rotation using the rotation matrix:
    // | cos(θ) -sin(θ) |
    // | sin(θ)  cos(θ) |
    float rotatedX = translatedX * cosf(angle) - translatedY * sinf(angle);
    float rotatedY = translatedX * sinf(angle) + translatedY * cosf(angle);

    // Translate back to original position by adding center coordinates
    SDL_FPoint result = {
        rotatedX + cx,
        rotatedY + cy
    };

    return result;
}

float Renderer::calculateTurningAngle(float targetX, float targetY, float currentX, float currentY) const {
    float dx = targetX - currentX;
    float dy = targetY - currentY;
    return std::atan2f(dy, dx);
}

SDL_Color Renderer::getLaneColor(LaneId laneId, bool isActive) const {
    if (isActive) {
        if (laneId == LaneId::AL2_PRIORITY) {
            return {255, 165, 0, 255}; // Orange for active priority lane
        }
        return {0, 255, 0, 255}; // Green for active normal lanes
    }

    if (laneId == LaneId::AL2_PRIORITY) {
        return {255, 165, 0, 128}; // Semi-transparent orange for inactive priority lane
    }
    return {255, 255, 255, 128}; // Semi-transparent white for inactive normal lanes
}

void Renderer::updateWindowSize(int width, int height) {
    // Resize the window if needed
    if (window) {
        SDL_SetWindowSize(window, width, height);
    }
}

