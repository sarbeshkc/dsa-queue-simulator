
================================================================================
File: include\core\Constants.h
================================================================================

// include/core/Constants.h
#pragma once
#include <cstdint>

enum class LaneId {
    AL1_INCOMING,
    AL2_PRIORITY,
    AL3_FREELANE,
    BL1_INCOMING,
    BL2_NORMAL,
    BL3_FREELANE,
    CL1_INCOMING,
    CL2_NORMAL,
    CL3_FREELANE,
    DL1_INCOMING,
    DL2_NORMAL,
    DL3_FREELANE
};

enum class Direction {
    STRAIGHT,
    LEFT,
    RIGHT
};

enum class LightState {
    RED,
    GREEN
};

// Add operator== for LightState
inline bool operator==(LightState lhs, LightState rhs) {
    return static_cast<int>(lhs) == static_cast<int>(rhs);
}


================================================================================
File: include\core\Lane.h
================================================================================

// Lane.h
#pragma once
#include "Vehicle.h"
#include "utils/Queue.h"
#include <memory>
#include <string>

class Lane {
private:
    LaneId id;
    Queue<std::shared_ptr<Vehicle>> vehicleQueue;
    bool isPriority;
    std::string dataFile;

public:
    Lane(LaneId id, bool isPriority);

    void addVehicle(std::shared_ptr<Vehicle> vehicle);
    std::shared_ptr<Vehicle> removeVehicle();
    Direction getVehicleDirection(size_t index) const;  // Add this method
    size_t getQueueSize() const;
    bool isPriorityLane() const;
    LaneId getId() const;
    const std::string& getDataFile() const;
    void update();
};


================================================================================
File: include\core\TrafficLight.h
================================================================================

// TrafficLight.h
#pragma once
#include <SDL3/SDL.h>
#include "Constants.h"
#include <cstdint>

class TrafficLight {
private:
    LightState state;
    LightState nextState;
    float transitionProgress;
    float transitionDuration;
    float stateTimer;
    bool isTransitioning;

public:
    TrafficLight();  // Just declare the constructor here
    void update(float deltaTime);
    void setState(LightState newState);
    LightState getState() const;
    void render(SDL_Renderer* renderer, float x, float y) const;
};


================================================================================
File: include\core\Vehicle.h
================================================================================

// include/core/Vehicle.hpp
#pragma once
#include "Constants.h"
#include <cstdint>

class Vehicle {
private:
    uint32_t id;
    Direction direction;
    LaneId currentLane;

public:
    Vehicle(uint32_t id, Direction dir, LaneId lane);
    uint32_t getId() const;
    Direction getDirection() const;
    LaneId getCurrentLane() const;
};


================================================================================
File: include\managers\FileHandler.h
================================================================================

// include/managers/FileHandler.hpp
#pragma once
#include "core/Vehicle.h"
#include <memory>
#include <vector>
#include <string>
#include <map>
#include <filesystem>
#include <fstream>

class FileHandler {
private:
    std::map<LaneId, std::filesystem::path> laneFiles;
    std::map<std::filesystem::path, int64_t> lastReadPositions;
    std::filesystem::path dataDir;

public:
    FileHandler();  // Declaration only, definition will be in cpp file

    std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> readNewVehicles();
    void clearLaneFiles();

private:
    std::vector<std::shared_ptr<Vehicle>> parseVehicleData(const std::string& data, LaneId laneId);
};


================================================================================
File: include\managers\IntersectionController.h
================================================================================



================================================================================
File: include\managers\TrafficManager.h
================================================================================

// include/managers/TrafficManager.h
#pragma once
#include <vector>
#include <memory>
#include <map>
#include "core/Constants.h"
#include "core/Lane.h"
#include "core/TrafficLight.h"
#include "core/Vehicle.h"

struct VehicleState {
    std::shared_ptr<Vehicle> vehicle;
    float x, y;             // Current position
    float targetX, targetY; // Target position
    float speed;            // Movement speed
    bool isMoving;
    Direction direction;
};

class TrafficManager {
private:
    std::vector<std::unique_ptr<Lane>> lanes;
    std::map<LaneId, TrafficLight> trafficLights;
    std::map<uint32_t, VehicleState> activeVehicles;
    bool inPriorityMode;

    // Helper methods
    size_t calculateVehiclesToProcess() const;
    bool checkPriorityConditions() const;
    void processNormalLanes(size_t vehicleCount);
    void processPriorityLane();
    void updateVehiclePositions(float deltaTime);
    void addNewVehicleToState(std::shared_ptr<Vehicle> vehicle, LaneId laneId);

public:
    TrafficManager();
    void update(float deltaTime);
    void addVehicleToLane(LaneId laneId, std::shared_ptr<Vehicle> vehicle);
    size_t getLaneSize(LaneId laneId) const;
    bool isInPriorityMode() const { return inPriorityMode; }
    const std::vector<std::unique_ptr<Lane>>& getLanes() const { return lanes; }
    const std::map<LaneId, TrafficLight>& getTrafficLights() const { return trafficLights; }
    const std::map<uint32_t, VehicleState>& getActiveVehicles() const { return activeVehicles; }
};


================================================================================
File: include\utils\PriorityQueue.h
================================================================================

// include/utils/PriorityQueue.hpp
#pragma once
#include "Queue.h"

template <typename T> class PriorityQueue : public Queue<T> {
  struct PriorityNode : public Queue<T>::Node {
    int priority;
    PriorityNode(const T &value, int p) : Queue<T>::Node(value), priority(p) {}
  };

public:
  void enqueuePriority(const T &value, int priority) {
    auto newNode = std::make_shared<PriorityNode>(value, priority);

    if (this->isEmpty() ||
        static_cast<PriorityNode *>(this->front.get())->priority < priority) {
      newNode->next = this->front;
      this->front = newNode;
    } else {
      auto current = this->front;
      while (current->next &&
             static_cast<PriorityNode *>(current->next.get())->priority >=
                 priority) {
        current = current->next;
      }
      newNode->next = current->next;
      current->next = newNode;
    }
    this->size++;
  }
};


================================================================================
File: include\utils\Queue.h
================================================================================

// include/utils/Queue.h
#pragma once
#include <memory>
#include <stdexcept>

template<typename T>
class Queue {
protected:
    struct Node {
        T data;
        std::shared_ptr<Node> next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::shared_ptr<Node> front;
    std::shared_ptr<Node> rear;
    size_t size;

public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}

    virtual ~Queue() = default;

    void enqueue(const T& value) {
        auto newNode = std::make_shared<Node>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    T dequeue() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    bool isEmpty() const {
        return front == nullptr;
    }

    size_t getSize() const {
        return size;
    }

    T peek() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return front->data;
    }

    // Add index-based peek
    T peek(size_t index) const {
        if (index >= size) {
            throw std::out_of_range("Index out of bounds");
        }

        auto current = front;
        for (size_t i = 0; i < index; i++) {
            current = current->next;
        }
        return current->data;
    }
};


================================================================================
File: include\visualization\DebugOverlay.h
================================================================================

// include/visualization/DebugOverlay.h
#pragma once
#define _USE_MATH_DEFINES
#include <cmath>
#include <SDL3/SDL.h>
#include "managers/TrafficManager.h"
#include <map>

class DebugOverlay {
private:
    struct LaneStatistics {
        int vehicleCount;
        float avgWaitTime;
        int processedCount;
    };

    std::map<LaneId, LaneStatistics> stats;
    void updateStatistics(const TrafficManager& trafficManager);
    void renderQueueStats(SDL_Renderer* renderer, int x, int y);
    void renderLaneLoadIndicator(SDL_Renderer* renderer, int x, int y);
    void renderSystemStatus(SDL_Renderer* renderer, int x, int y);

public:
    DebugOverlay() = default;
    void render(SDL_Renderer* renderer, const TrafficManager& trafficManager);
};


================================================================================
File: include\visualization\Renderer.h
================================================================================

// include/visualization/Rend#pragma once
#include <SDL3/SDL.h>
#include "managers/TrafficManager.h"
#include "visualization/DebugOverlay.h"
#include <memory>
#include <map>
#include <cmath>

class Renderer {
private:
    SDL_Window* window;
    SDL_Renderer* renderer;
    DebugOverlay debugOverlay;

    // Constants for visualization
    static constexpr int WINDOW_WIDTH = 800;
    static constexpr int WINDOW_HEIGHT = 600;
    static constexpr int ROAD_WIDTH = 180;
    static constexpr int LANE_WIDTH = 60;
    static constexpr int CENTER_X = WINDOW_WIDTH / 2;
    static constexpr int CENTER_Y = WINDOW_HEIGHT / 2;

    static constexpr float VEHICLE_WIDTH = 30.0f;
    static constexpr float VEHICLE_HEIGHT = 20.0f;
    static constexpr float VEHICLE_SPACING = 45.0f;

    // Helper functions
    void renderRoads();
    void renderLanes(const std::vector<std::unique_ptr<Lane>>& lanes);
    void renderTrafficLights(const std::map<LaneId, TrafficLight>& lights);
    void renderVehicles(const std::vector<std::unique_ptr<Lane>>& lanes);
    void renderDirectionArrows();
    void renderVehicle(float x, float y, Direction dir, bool isPriority, float angle);
    float calculateVehicleAngle(LaneId laneId) const;

public:
    Renderer();
    ~Renderer();

    bool initialize();
    void render(const TrafficManager& trafficManager);
    void cleanup();
};


================================================================================
File: src\common\types.h
================================================================================

// src/common/types.h
#pragma once
#include <cstdint>
#include <string>

enum class LaneId {
    AL1_INCOMING,
    AL2_PRIORITY,
    AL3_FREELANE,
    BL1_INCOMING,
    BL2_NORMAL,
    BL3_FREELANE,
    CL1_INCOMING,
    CL2_NORMAL,
    CL3_FREELANE,
    DL1_INCOMING,
    DL2_NORMAL,
    DL3_FREELANE
};

enum class LightState {
    RED,
    GREEN
};

;


================================================================================
File: src\common\vector2d.h
================================================================================

// src/utils/vector2d.h
#pragma once

struct Vector2D {
    float x;
    float y;

    Vector2D() : x(0.0f), y(0.0f) {}
    Vector2D(float x, float y) : x(x), y(y) {}

    Vector2D operator+(const Vector2D& other) const {
        return Vector2D(x + other.x, y + other.y);
    }

    Vector2D operator*(float scalar) const {
        return Vector2D(x * scalar, y * scalar);
    }
};



================================================================================
File: src\core\Lane.cpp
================================================================================

// src/core/Lane.cpp
#include "core/Lane.h"
#include <filesystem>

Lane::Lane(LaneId id, bool isPriority)
    : id(id), isPriority(isPriority) {
    // Set up data file path based on lane ID
    std::string lanePrefix;
    switch(id) {
        case LaneId::AL1_INCOMING: lanePrefix = "a1"; break;
        case LaneId::AL2_PRIORITY: lanePrefix = "a2"; break;
        case LaneId::AL3_FREELANE: lanePrefix = "a3"; break;
        // ... add other cases
        default: lanePrefix = "unknown";
    }
    dataFile = "data/lanes/lane_" + lanePrefix + ".txt";
}


Direction Lane::getVehicleDirection(size_t index) const {
    if (index >= vehicleQueue.getSize()) {
        return Direction::STRAIGHT;  // Default direction
    }

    // This assumes you maintain the vehicles in order in your queue
    // You might need to adjust this based on your Queue implementation
    auto vehicle = vehicleQueue.peek(index);
    return vehicle ? vehicle->getDirection() : Direction::STRAIGHT;
}

void Lane::addVehicle(std::shared_ptr<Vehicle> vehicle) {
    vehicleQueue.enqueue(vehicle);
}

std::shared_ptr<Vehicle> Lane::removeVehicle() {
    if (vehicleQueue.isEmpty()) return nullptr;
    return vehicleQueue.dequeue();
}

size_t Lane::getQueueSize() const {
    return vehicleQueue.getSize();
}

bool Lane::isPriorityLane() const {
    return isPriority;
}

LaneId Lane::getId() const {
    return id;
}

const std::string& Lane::getDataFile() const {
    return dataFile;
}

void Lane::update() {
    // Update logic for free lanes
    if (id == LaneId::AL3_FREELANE ||
        id == LaneId::BL3_FREELANE ||
        id == LaneId::CL3_FREELANE ||
        id == LaneId::DL3_FREELANE) {
        // Free lanes process vehicles immediately
        while (!vehicleQueue.isEmpty()) {
            removeVehicle();
        }
    }
}


================================================================================
File: src\core\TrafficLight.cpp
================================================================================

// src/core/TrafficLight.cpp
#include "core/TrafficLight.h"

TrafficLight::TrafficLight()
    : state(LightState::RED)
    , nextState(LightState::RED)
    , transitionProgress(0.0f)
    , transitionDuration(1.0f)
    , stateTimer(0.0f)
    , isTransitioning(false) {}

void TrafficLight::update(float deltaTime) {
    stateTimer += deltaTime;

    if (isTransitioning) {
        transitionProgress += deltaTime / transitionDuration;
        if (transitionProgress >= 1.0f) {
            transitionProgress = 0.0f;
            isTransitioning = false;
            state = nextState;
        }
    }
    else if (stateTimer >= 5.0f) {  // 5 seconds per state
        stateTimer = 0.0f;
        isTransitioning = true;
        nextState = (state == LightState::RED) ? LightState::GREEN : LightState::RED;
    }
}

void TrafficLight::setState(LightState newState) {
    state = newState;
    stateTimer = 0.0f;
}

LightState TrafficLight::getState() const {
    return state;
}

void TrafficLight::render(SDL_Renderer* renderer, float x, float y) const {
    const float SIZE = 30.0f;
    const float SPACING = 40.0f;

    // Draw light housing
    SDL_FRect housing = {x - 5, y - 5, SIZE + 10, (SIZE * 2) + SPACING + 10};
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);
    SDL_RenderFillRect(renderer, &housing);

    // Draw red light
    SDL_FRect redLight = {x, y, SIZE, SIZE};
    float redIntensity = (state == LightState::RED) ?
        (isTransitioning ? 1.0f - transitionProgress : 1.0f) :
        (isTransitioning ? transitionProgress : 0.0f);
    SDL_SetRenderDrawColor(renderer,
        static_cast<uint8_t>(255 * redIntensity),
        0,
        0,
        255);
    SDL_RenderFillRect(renderer, &redLight);

    // Draw green light
    SDL_FRect greenLight = {x, y + SIZE + SPACING, SIZE, SIZE};
    float greenIntensity = (state == LightState::GREEN) ?
        (isTransitioning ? 1.0f - transitionProgress : 1.0f) :
        (isTransitioning ? transitionProgress : 0.0f);
    SDL_SetRenderDrawColor(renderer,
        0,
        static_cast<uint8_t>(255 * greenIntensity),
        0,
        255);
    SDL_RenderFillRect(renderer, &greenLight);

    // Draw borders
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}


================================================================================
File: src\core\Vehicle.cpp
================================================================================

// include/cor

// src/core/Vehicle.cpp
#include "core/Vehicle.h"

Vehicle::Vehicle(uint32_t id, Direction dir, LaneId lane)
    : id(id), direction(dir), currentLane(lane) {}

uint32_t Vehicle::getId() const { return id; }
Direction Vehicle::getDirection() const { return direction; }
LaneId Vehicle::getCurrentLane() const { return currentLane; }



================================================================================
File: src\main.cpp
================================================================================

// src/main.cpp
#include <SDL3/SDL.h>
#include "managers/TrafficManager.h"
#include "managers/FileHandler.h"
#include "visualization/Renderer.h"
#include <iostream>
#include <chrono>

class Simulator {
private:
    TrafficManager trafficManager;
    Renderer renderer;
    bool running;

    void processInput() {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
                case SDL_EVENT_QUIT:
                    running = false;
                    break;
                case SDL_EVENT_KEY_DOWN:
                    // For SDL3, we use scancode instead of keysym
                    if (event.key.scancode == SDL_SCANCODE_ESCAPE) {
                        running = false;
                    }
                    break;
            }
        }
    }

    void update(float deltaTime) {
        trafficManager.update(deltaTime);
    }

    void render() {
        renderer.render(trafficManager);
    }

public:
    Simulator() : running(false) {}

    bool initialize() {
        if (!renderer.initialize()) {
            std::cerr << "Failed to initialize renderer" << std::endl;
            return false;
        }

        // Clear any existing vehicle data
        FileHandler fileHandler;
        fileHandler.clearLaneFiles();

        running = true;
        return true;
    }

    void run() {
        auto lastUpdateTime = std::chrono::high_resolution_clock::now();

        while (running) {
            auto currentTime = std::chrono::high_resolution_clock::now();
            float deltaTime = std::chrono::duration<float>(currentTime - lastUpdateTime).count();
            lastUpdateTime = currentTime;

            processInput();
            update(deltaTime);
            render();

            // Cap frame rate at ~60 FPS
            if (deltaTime < 0.016f) {
                SDL_Delay(static_cast<uint32_t>((0.016f - deltaTime) * 1000));
            }
        }
    }

    void cleanup() {
        renderer.cleanup();
    }
};

int main(int argc, char* argv[]) {
    (void)argc; // Suppress unused parameter warning
    (void)argv; // Suppress unused parameter warning

    Simulator simulator;

    if (!simulator.initialize()) {
        std::cerr << "Failed to initialize simulator" << std::endl;
        return 1;
    }

    std::cout << "Traffic Simulator Started\n";
    std::cout << "Press ESC to exit\n";

    simulator.run();
    simulator.cleanup();

    return 0;
}


================================================================================
File: src\managers\FileHandler.cpp
================================================================================

#include "managers/FileHandler.h"
#include <fstream>
#include <sstream>
#include <filesystem>
#include <iostream>

FileHandler::FileHandler() {
    // Get the executable path and set up data directory
    dataDir = std::filesystem::current_path() / "data" / "lanes";
    std::filesystem::create_directories(dataDir);

    // Initialize lane file mappings with absolute paths
    laneFiles = {
        {LaneId::AL1_INCOMING, dataDir / "lane_a1.txt"},
        {LaneId::AL2_PRIORITY, dataDir / "lane_a2.txt"},
        {LaneId::AL3_FREELANE, dataDir / "lane_a3.txt"},
        {LaneId::BL1_INCOMING, dataDir / "lane_b1.txt"},
        {LaneId::BL2_NORMAL, dataDir / "lane_b2.txt"},
        {LaneId::BL3_FREELANE, dataDir / "lane_b3.txt"},
        {LaneId::CL1_INCOMING, dataDir / "lane_c1.txt"},
        {LaneId::CL2_NORMAL, dataDir / "lane_c2.txt"},
        {LaneId::CL3_FREELANE, dataDir / "lane_c3.txt"},
        {LaneId::DL1_INCOMING, dataDir / "lane_d1.txt"},
        {LaneId::DL2_NORMAL, dataDir / "lane_d2.txt"},
        {LaneId::DL3_FREELANE, dataDir / "lane_d3.txt"}
    };

    // Create empty files and initialize read positions
    for (const auto& [_, filepath] : laneFiles) {
        std::ofstream file(filepath.string());
        lastReadPositions[filepath] = 0;
    }
}

// src/managers/FileHandler.cpp
std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> FileHandler::readNewVehicles() {
    std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> newVehicles;

    for (const auto& [laneId, filepath] : laneFiles) {
        std::ifstream file(filepath.string(), std::ios::in);
        if (!file) continue;

        // Get file size
        file.seekg(0, std::ios::end);
        int64_t fileSize = file.tellg();

        // If there's new data
        if (fileSize > lastReadPositions[filepath]) {
            file.seekg(lastReadPositions[filepath]);
            std::string line;

            while (std::getline(file, line)) {
                if (line.empty()) continue;

                size_t commaPos = line.find(',');
                size_t semicolonPos = line.find(';');

                if (commaPos != std::string::npos && semicolonPos != std::string::npos) {
                    try {
                        uint32_t id = std::stoul(line.substr(0, commaPos));
                        char dirChar = line[commaPos + 1];

                        Direction dir;
                        switch (dirChar) {
                            case 'S': dir = Direction::STRAIGHT; break;
                            case 'L': dir = Direction::LEFT; break;
                            case 'R': dir = Direction::RIGHT; break;
                            default: continue;
                        }

                        auto vehicle = std::make_shared<Vehicle>(id, dir, laneId);
                        newVehicles.emplace_back(laneId, vehicle);

                        std::cout << "Read vehicle " << id << " from lane "
                                 << static_cast<int>(laneId) << std::endl;
                    } catch (...) {
                        std::cerr << "Error parsing line: " << line << std::endl;
                    }
                }
            }

            lastReadPositions[filepath] = file.tellg();
        }
    }

    return newVehicles;
}

std::vector<std::shared_ptr<Vehicle>> FileHandler::parseVehicleData(
    const std::string& data, LaneId laneId) {
    std::vector<std::shared_ptr<Vehicle>> vehicles;
    std::stringstream ss(data);
    std::string vehicleData;

    while (std::getline(ss, vehicleData, ';')) {
        if (vehicleData.empty()) continue;

        // Expected format: "id,direction"
        std::stringstream vehicleSS(vehicleData);
        std::string idStr, dirStr;

        if (std::getline(vehicleSS, idStr, ',') &&
            std::getline(vehicleSS, dirStr, ',')) {
            try {
                uint32_t id = std::stoul(idStr);
                Direction dir;

                if (dirStr == "S") dir = Direction::STRAIGHT;
                else if (dirStr == "L") dir = Direction::LEFT;
                else if (dirStr == "R") dir = Direction::RIGHT;
                else continue;

                vehicles.push_back(std::make_shared<Vehicle>(id, dir, laneId));
            } catch (...) {
                // Skip invalid data
                continue;
            }
        }
    }

    return vehicles;
}

void FileHandler::clearLaneFiles() {
    for (const auto& [_, filename] : laneFiles) {
        std::ofstream file(filename, std::ios::trunc);
        lastReadPositions[filename] = 0;
    }
}


================================================================================
File: src\managers\IntersectionController.cpp
================================================================================



================================================================================
File: src\managers\TrafficManager.cpp
================================================================================

// src/managers/TrafficManager.cpp
#include "managers/TrafficManager.h"
#include "managers/FileHandler.h"
#include <algorithm>
#include <cmath>

TrafficManager::TrafficManager() : inPriorityMode(false) {
    // Initialize lanes
    lanes.push_back(std::make_unique<Lane>(LaneId::AL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::AL2_PRIORITY, true));
    lanes.push_back(std::make_unique<Lane>(LaneId::AL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL3_FREELANE, false));

    // Initialize traffic lights
    trafficLights[LaneId::AL2_PRIORITY] = TrafficLight();
    trafficLights[LaneId::BL2_NORMAL] = TrafficLight();
    trafficLights[LaneId::CL2_NORMAL] = TrafficLight();
    trafficLights[LaneId::DL2_NORMAL] = TrafficLight();
}

void TrafficManager::update(float deltaTime) {
    // Update traffic lights
    for (auto& [_, light] : trafficLights) {
        light.update(deltaTime);
    }

    // Read new vehicles from files
    FileHandler fileHandler;
    auto newVehicles = fileHandler.readNewVehicles();
    for (const auto& [laneId, vehicle] : newVehicles) {
        addVehicleToLane(laneId, vehicle);
        addNewVehicleToState(vehicle, laneId);
    }

    // Update vehicle positions
    updateVehiclePositions(deltaTime);

    // Process lanes based on traffic rules
    if (checkPriorityConditions()) {
        inPriorityMode = true;
        processPriorityLane();
    } else if (!inPriorityMode) {
        size_t vehiclesToProcess = calculateVehiclesToProcess();
        processNormalLanes(vehiclesToProcess);
    }
}

void TrafficManager::updateVehiclePositions(float deltaTime) {
    auto it = activeVehicles.begin();
    while (it != activeVehicles.end()) {
        auto& state = it->second;
        if (state.isMoving) {
            float dx = state.targetX - state.x;
            float dy = state.targetY - state.y;
            float distance = std::sqrt(dx*dx + dy*dy);

            if (distance < 1.0f) {
                it = activeVehicles.erase(it);
                continue;
            }

            float moveX = (dx / distance) * state.speed * deltaTime;
            float moveY = (dy / distance) * state.speed * deltaTime;

            state.x += moveX;
            state.y += moveY;
        }
        ++it;
    }
}

size_t TrafficManager::calculateVehiclesToProcess() const {
    size_t totalVehicles = 0;
    size_t normalLaneCount = 0;

    for (const auto& lane : lanes) {
        if (!lane->isPriorityLane() &&
            lane->getId() != LaneId::AL3_FREELANE &&
            lane->getId() != LaneId::BL3_FREELANE &&
            lane->getId() != LaneId::CL3_FREELANE &&
            lane->getId() != LaneId::DL3_FREELANE) {
            totalVehicles += lane->getQueueSize();
            normalLaneCount++;
        }
    }

    if (normalLaneCount == 0) return 0;
    return static_cast<size_t>(std::ceil(static_cast<double>(totalVehicles) / static_cast<double>(normalLaneCount)));
}

bool TrafficManager::checkPriorityConditions() const {
    for (const auto& lane : lanes) {
        if (lane->isPriorityLane() && lane->getQueueSize() > 10) {
            return true;
        }
    }
    return false;
}

void TrafficManager::processNormalLanes(size_t vehicleCount) {
    for (auto& lane : lanes) {
        if (!lane->isPriorityLane()) {
            for (size_t i = 0; i < vehicleCount && lane->getQueueSize() > 0; ++i) {
                lane->removeVehicle();
            }
        }
    }
}

void TrafficManager::processPriorityLane() {
    for (auto& lane : lanes) {
        if (lane->isPriorityLane()) {
            while (lane->getQueueSize() > 5) {
                lane->removeVehicle();
            }
            if (lane->getQueueSize() <= 5) {
                inPriorityMode = false;
            }
        }
    }
}

void TrafficManager::addVehicleToLane(LaneId laneId, std::shared_ptr<Vehicle> vehicle) {
    auto it = std::find_if(lanes.begin(), lanes.end(),
                          [laneId](const auto& lane) { return lane->getId() == laneId; });
    if (it != lanes.end()) {
        (*it)->addVehicle(vehicle);
    }
}

size_t TrafficManager::getLaneSize(LaneId laneId) const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
                          [laneId](const auto& lane) { return lane->getId() == laneId; });
    if (it != lanes.end()) {
        return (*it)->getQueueSize();
    }
    return 0;
}


// Add this implementation to src/managers/TrafficManager.cpp

void TrafficManager::addNewVehicleToState(std::shared_ptr<Vehicle> vehicle, LaneId laneId) {
    VehicleState state;
    state.vehicle = vehicle;
    state.speed = 100.0f;
    state.isMoving = true;
    state.direction = vehicle->getDirection();

    const int LANE_OFFSET = 60;
    const int CENTER_X = 400;
    const int CENTER_Y = 300;

    switch (laneId) {
        // Left lanes (A)
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE: {
            int laneIndex = static_cast<int>(laneId) - static_cast<int>(LaneId::AL1_INCOMING);
            state.x = -30.0f;
            state.y = static_cast<float>(CENTER_Y + (laneIndex * LANE_OFFSET) - LANE_OFFSET);

            if (state.direction == Direction::STRAIGHT) {
                state.targetX = 830.0f;
                state.targetY = state.y;
            } else if (state.direction == Direction::RIGHT) {
                state.targetX = static_cast<float>(static_cast<int>(state.y) + CENTER_X);
                state.targetY = 830.0f;
            } else if (state.direction == Direction::LEFT) {
                state.targetX = state.y - CENTER_Y + CENTER_X;
                state.targetY = -30.0f;
            }
            break;
        }

        // Top lanes (B)
        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE: {
            int laneIndex = static_cast<int>(laneId) - static_cast<int>(LaneId::BL1_INCOMING);
            state.x = static_cast<float>(CENTER_X + (laneIndex * LANE_OFFSET) - LANE_OFFSET);
            state.y = -30.0f;

            if (state.direction == Direction::STRAIGHT) {
                state.targetX = state.x;
                state.targetY = 830.0f;
            } else if (state.direction == Direction::RIGHT) {
                state.targetX = 830.0f;
                state.targetY = state.x - CENTER_X + CENTER_Y;
            } else if (state.direction == Direction::LEFT) {
                state.targetX = -30.0f;
                state.targetY = CENTER_Y - (state.x - CENTER_X);
            }
            break;
        }

        // Right lanes (C)
        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE: {
            int laneIndex = static_cast<int>(laneId) - static_cast<int>(LaneId::CL1_INCOMING);
            state.x = 830.0f;
            state.y = static_cast<float>(CENTER_Y + (laneIndex * LANE_OFFSET) - LANE_OFFSET);

            if (state.direction == Direction::STRAIGHT) {
                state.targetX = -30.0f;
                state.targetY = state.y;
            } else if (state.direction == Direction::RIGHT) {
                state.targetX = static_cast<float>(CENTER_Y - (state.y - CENTER_Y));
                state.targetY = -30.0f;
            } else if (state.direction == Direction::LEFT) {
                state.targetX = CENTER_X - (state.y - CENTER_Y);
                state.targetY = 830.0f;
            }
            break;
        }

        // Bottom lanes (D)
        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE: {
            int laneIndex = static_cast<int>(laneId) - static_cast<int>(LaneId::DL1_INCOMING);
            state.x = static_cast<float>(CENTER_X + (laneIndex * LANE_OFFSET) - LANE_OFFSET);
            state.y = 830.0f;

            if (state.direction == Direction::STRAIGHT) {
                state.targetX = state.x;
                state.targetY = -30.0f;
            } else if (state.direction == Direction::RIGHT) {
                state.targetX = -30.0f;
                state.targetY = CENTER_Y + (state.x - CENTER_X);
            } else if (state.direction == Direction::LEFT) {
                state.targetX = 830.0f;
                state.targetY = CENTER_Y - (state.x - CENTER_X);
            }
            break;
        }

        default:
            state.x = -30.0f;
            state.y = static_cast<float>(CENTER_Y);
            state.targetX = 830.0f;
            state.targetY = static_cast<float>(CENTER_Y);
    }

    activeVehicles[vehicle->getId()] = state;
}


================================================================================
File: src\utils\Queue.cpp
================================================================================

// include/utils/Queue.hpp
#pragma once
#include <memory>
#include <stdexcept>

template<typename T>
class Queue {
protected:
    struct Node {
        T data;
        std::shared_ptr<Node> next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::shared_ptr<Node> front;
    std::shared_ptr<Node> rear;
    size_t size;

public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}

    virtual ~Queue() = default;

    void enqueue(const T& value) {
        auto newNode = std::make_shared<Node>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    T dequeue() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    bool isEmpty() const {
        return front == nullptr;
    }

    size_t getSize() const {
        return size;
    }

    T peek() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return front->data;
    }
};


================================================================================
File: src\utils\vector2d.h
================================================================================



================================================================================
File: src\visualization\DebugOverlay.cpp
================================================================================

// src/visualization/DebugOverlay.cpp
#define _USE_MATH_DEFINES
#include <cmath>
#include "visualization/DebugOverlay.h"

void DebugOverlay::render(SDL_Renderer* renderer, const TrafficManager& trafficManager) {
    // Draw background for debug panel
    SDL_FRect debugPanel = {10.0f, 10.0f, 200.0f, 300.0f};
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200);
    SDL_RenderFillRect(renderer, &debugPanel);

    // Priority mode indicator
    if (trafficManager.isInPriorityMode()) {
        SDL_FRect priorityIndicator = {20.0f, 20.0f, 20.0f, 20.0f};
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderFillRect(renderer, &priorityIndicator);
    }

    // Queue lengths visualization
    int yOffset = 50;
    for (const auto& lane : trafficManager.getLanes()) {
        SDL_FRect queueBar = {
            20.0f,
            static_cast<float>(yOffset),
            static_cast<float>(lane->getQueueSize() * 5),
            15.0f
        };

        // Color based on lane type
        if (lane->isPriorityLane()) {
            SDL_SetRenderDrawColor(renderer, 255, 100, 100, 255);
        } else if (lane->getId() == LaneId::AL3_FREELANE ||
                   lane->getId() == LaneId::BL3_FREELANE ||
                   lane->getId() == LaneId::CL3_FREELANE ||
                   lane->getId() == LaneId::DL3_FREELANE) {
            SDL_SetRenderDrawColor(renderer, 100, 255, 100, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 100, 150, 255, 255);
        }

        SDL_RenderFillRect(renderer, &queueBar);
        yOffset += 20;
    }
}

void DebugOverlay::updateStatistics(const TrafficManager& trafficManager) {
    for (const auto& lane : trafficManager.getLanes()) {
        LaneStatistics& laneStat = stats[lane->getId()];
        laneStat.vehicleCount = static_cast<int>(lane->getQueueSize());
    }
}

void DebugOverlay::renderQueueStats(SDL_Renderer* renderer, int x, int y) {
    int yOffset = y;
    for (const auto& [laneId, stat] : stats) {
        SDL_FRect bar = {
            static_cast<float>(x + 10),
            static_cast<float>(yOffset),
            static_cast<float>(stat.vehicleCount * 5),
            15.0f
        };

        if (stat.vehicleCount > 10) {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        } else if (stat.vehicleCount > 5) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        }

        SDL_RenderFillRect(renderer, &bar);
        yOffset += 20;
    }
}

void DebugOverlay::renderLaneLoadIndicator(SDL_Renderer* renderer, int x, int y) {
    const float RADIUS = 50.0f;
    const int SEGMENTS = 12;
    const float TWO_PI = static_cast<float>(2.0 * M_PI);

    for (int i = 0; i < SEGMENTS; i++) {
        float startAngle = (TWO_PI * i) / SEGMENTS;
        float endAngle = (TWO_PI * (i + 1)) / SEGMENTS;

        float startX = x + RADIUS * cosf(startAngle);
        float startY = y + RADIUS * sinf(startAngle);
        float endX = x + RADIUS * cosf(endAngle);
        float endY = y + RADIUS * sinf(endAngle);

        // Color based on load
        int laneIndex = i % 4;
        LaneId laneId = static_cast<LaneId>(laneIndex);
        int load = stats[laneId].vehicleCount;

        if (load > 10) {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        } else if (load > 5) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        }

        SDL_RenderLine(renderer, startX, startY, endX, endY);
    }
}

void DebugOverlay::renderSystemStatus(SDL_Renderer* renderer, int x, int y) {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    // TODO: Add text rendering for system status when needed
}


================================================================================
File: src\visualization\Renderer.cpp
================================================================================

#include "visualization/Renderer.h"
#include <iostream>

Renderer::Renderer() : window(nullptr), renderer(nullptr) {}

Renderer::~Renderer() {
    cleanup();
}

bool Renderer::initialize() {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        std::cerr << "SDL initialization failed: " << SDL_GetError() << std::endl;
        return false;
    }

    window = SDL_CreateWindow(
        "Traffic Simulator",
        WINDOW_WIDTH,
        WINDOW_HEIGHT,
        SDL_WINDOW_RESIZABLE
    );

    if (!window) {
        std::cerr << "Window creation failed: " << SDL_GetError() << std::endl;
        return false;
    }

    renderer = SDL_CreateRenderer(window, nullptr);
    if (!renderer) {
        std::cerr << "Renderer creation failed: " << SDL_GetError() << std::endl;
        return false;
    }

    return true;
}

void Renderer::renderRoads() {
    // Background
    SDL_SetRenderDrawColor(renderer, 40, 40, 40, 255);
    SDL_RenderClear(renderer);

    // Main roads
    SDL_SetRenderDrawColor(renderer, 60, 60, 60, 255);

    // Horizontal road
    SDL_FRect horizontalRoad = {
        static_cast<float>(CENTER_X - 350),
        static_cast<float>(CENTER_Y - ROAD_WIDTH/2),
        700.0f,
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &horizontalRoad);

    // Vertical road
    SDL_FRect verticalRoad = {
        static_cast<float>(CENTER_X - ROAD_WIDTH/2),
        static_cast<float>(CENTER_Y - 350),
        static_cast<float>(ROAD_WIDTH),
        700.0f
    };
    SDL_RenderFillRect(renderer, &verticalRoad);

    // Draw lane markers
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    // Horizontal lanes
    for (int i = -1; i <= 1; i++) {
        float y = static_cast<float>(CENTER_Y + i * LANE_WIDTH);
        for (float x = CENTER_X - 300.0f; x <= CENTER_X + 300.0f; x += 40.0f) {
            if (x < CENTER_X - ROAD_WIDTH/2 || x > CENTER_X + ROAD_WIDTH/2) {
                SDL_FRect dash = {x, y - 1.5f, 20.0f, 3.0f};
                SDL_RenderFillRect(renderer, &dash);
            }
        }
    }

    // Vertical lanes
    for (int i = -1; i <= 1; i++) {
        float x = static_cast<float>(CENTER_X + i * LANE_WIDTH);
        for (float y = CENTER_Y - 300.0f; y <= CENTER_Y + 300.0f; y += 40.0f) {
            if (y < CENTER_Y - ROAD_WIDTH/2 || y > CENTER_Y + ROAD_WIDTH/2) {
                SDL_FRect dash = {x - 1.5f, y, 3.0f, 20.0f};
                SDL_RenderFillRect(renderer, &dash);
            }
        }
    }
}

void Renderer::renderVehicle(float x, float y, Direction dir, bool isPriority, float angle) {
    const float halfWidth = VEHICLE_WIDTH / 2.0f;
    const float halfHeight = VEHICLE_HEIGHT / 2.0f;

    float cosAngle = cosf(angle);
    float sinAngle = sinf(angle);

    // Vehicle corners
    SDL_FPoint vertices[4] = {
        {x + (-halfWidth * cosAngle - halfHeight * sinAngle),
         y + (-halfWidth * sinAngle + halfHeight * cosAngle)},
        {x + (halfWidth * cosAngle - halfHeight * sinAngle),
         y + (halfWidth * sinAngle + halfHeight * cosAngle)},
        {x + (halfWidth * cosAngle + halfHeight * sinAngle),
         y + (halfWidth * sinAngle - halfHeight * cosAngle)},
        {x + (-halfWidth * cosAngle + halfHeight * sinAngle),
         y + (-halfWidth * sinAngle - halfHeight * cosAngle)}
    };

    // Draw vehicle body
    if (isPriority) {
        SDL_SetRenderDrawColor(renderer, 255, 100, 100, 255);
    } else {
        SDL_SetRenderDrawColor(renderer, 100, 150, 255, 255);
    }

    // Draw outline
    for (int i = 0; i < 4; i++) {
        SDL_RenderLine(renderer,
            vertices[i].x, vertices[i].y,
            vertices[(i + 1) % 4].x, vertices[(i + 1) % 4].y);
    }

    // Draw direction indicator
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float arrowLength = VEHICLE_WIDTH * 0.4f;
    float arrowAngle = angle;

    switch (dir) {
        case Direction::LEFT:
            arrowAngle -= 0.785f; // 45 degrees in radians
            break;
        case Direction::RIGHT:
            arrowAngle += 0.785f;
            break;
        default:
            break;
    }

    float endX = x + arrowLength * cosf(arrowAngle);
    float endY = y + arrowLength * sinf(arrowAngle);
    SDL_RenderLine(renderer, x, y, endX, endY);
}

float Renderer::calculateVehicleAngle(LaneId laneId) const {
    switch (laneId) {
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE:
            return 0.0f;

        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE:
            return 1.5708f; // π/2

        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE:
            return 3.1416f; // π

        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE:
            return -1.5708f; // -π/2

        default:
            return 0.0f;
    }
}

void Renderer::renderVehicles(const std::vector<std::unique_ptr<Lane>>& lanes) {
    for (const auto& lane : lanes) {
        size_t queueSize = lane->getQueueSize();
        if (queueSize == 0) continue;

        LaneId laneId = lane->getId();
        float spacing = VEHICLE_WIDTH * 1.5f;
        float baseAngle = calculateVehicleAngle(laneId);

        for (size_t i = 0; i < queueSize; i++) {
            float x = 0.0f, y = 0.0f;
            Direction dir = Direction::STRAIGHT; // Get actual direction from vehicle

            // Calculate position based on lane
            if (laneId <= LaneId::AL3_FREELANE) { // Left lanes
                x = static_cast<float>(CENTER_X - 300 + (i * spacing));
                y = static_cast<float>(CENTER_Y + ((static_cast<int>(laneId) % 3) - 1) * LANE_WIDTH);
            }
            else if (laneId <= LaneId::BL3_FREELANE) { // Top lanes
                x = static_cast<float>(CENTER_X + ((static_cast<int>(laneId) % 3) - 1) * LANE_WIDTH);
                y = static_cast<float>(CENTER_Y - 300 + (i * spacing));
            }
            else if (laneId <= LaneId::CL3_FREELANE) { // Right lanes
                x = static_cast<float>(CENTER_X + 300 - (i * spacing));
                y = static_cast<float>(CENTER_Y + ((static_cast<int>(laneId) % 3) - 1) * LANE_WIDTH);
            }
            else { // Bottom lanes
                x = static_cast<float>(CENTER_X + ((static_cast<int>(laneId) % 3) - 1) * LANE_WIDTH);
                y = static_cast<float>(CENTER_Y + 300 - (i * spacing));
            }

            renderVehicle(x, y, dir, laneId == LaneId::AL2_PRIORITY, baseAngle);
        }
    }
}

void Renderer::renderTrafficLights(const std::map<LaneId, TrafficLight>& lights) {
    for (const auto& [laneId, light] : lights) {
        float x = 0.0f, y = 0.0f;

        switch (laneId) {
            case LaneId::AL2_PRIORITY:
                x = static_cast<float>(CENTER_X - ROAD_WIDTH/2 - 40);
                y = static_cast<float>(CENTER_Y - LANE_WIDTH);
                break;
            case LaneId::BL2_NORMAL:
                x = static_cast<float>(CENTER_X - LANE_WIDTH);
                y = static_cast<float>(CENTER_Y - ROAD_WIDTH/2 - 40);
                break;
            case LaneId::CL2_NORMAL:
                x = static_cast<float>(CENTER_X + ROAD_WIDTH/2 + 20);
                y = static_cast<float>(CENTER_Y - LANE_WIDTH);
                break;
            case LaneId::DL2_NORMAL:
                x = static_cast<float>(CENTER_X - LANE_WIDTH);
                y = static_cast<float>(CENTER_Y + ROAD_WIDTH/2 + 20);
                break;
            default:
                continue;
        }

        light.render(renderer, x, y);
    }
}

void Renderer::render(const TrafficManager& trafficManager) {
    renderRoads();
    renderTrafficLights(trafficManager.getTrafficLights());
    renderVehicles(trafficManager.getLanes());
    debugOverlay.render(renderer, trafficManager);
    SDL_RenderPresent(renderer);
}

void Renderer::cleanup() {
    if (renderer) {
        SDL_DestroyRenderer(renderer);
        renderer = nullptr;
    }
    if (window) {
        SDL_DestroyWindow(window);
        window = nullptr;
    }
    SDL_Quit();
}

