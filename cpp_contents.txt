
================================================================================
File: include\core\Constants.h
================================================================================

// Constants.h
#pragma once
#include <cstdint>

enum class LaneId {
    AL1_INCOMING,
    AL2_PRIORITY,
    AL3_FREELANE,
    BL1_INCOMING,
    BL2_NORMAL,
    BL3_FREELANE,
    CL1_INCOMING,
    CL2_NORMAL,
    CL3_FREELANE,
    DL1_INCOMING,
    DL2_NORMAL,
    DL3_FREELANE
};

enum class Direction {
    STRAIGHT,
    LEFT,
    RIGHT
};

enum class LightState {
    RED,
    GREEN
};

namespace SimConstants {


  static constexpr float VEHICLE_LENGTH = 50.0f;  // Length of vehicle for queue spacing


static constexpr size_t PRIORITY_THRESHOLD = 10;     // Switch to priority mode at 10 vehicles
static constexpr size_t NORMAL_THRESHOLD = 5;
    // Window and Display
    static constexpr int WINDOW_WIDTH = 1280;
    static constexpr int WINDOW_HEIGHT = 960;
    static constexpr int CENTER_X = WINDOW_WIDTH / 2;
    static constexpr int CENTER_Y = WINDOW_HEIGHT / 2;

    // Road and Lane Configuration
    static constexpr int ROAD_WIDTH = 360;     // Width for 3 lanes
    static constexpr int LANE_WIDTH = 120;     // Individual lane width
    static constexpr float QUEUE_SPACING = 60.0f;
    static constexpr float QUEUE_START_OFFSET = 200.0f;


    static constexpr float QUEUE_START = ROAD_WIDTH / 2.0f + 50.0f;  // Where queues start from intersection

    static constexpr float LANE_OFFSET = ROAD_WIDTH / 6.0f;  // Half of lane width

    // Vehicle Configuration
    static constexpr float VEHICLE_WIDTH = 40.0f;
    static constexpr float VEHICLE_HEIGHT = 30.0f;
    static constexpr float VEHICLE_BASE_SPEED = 50.0f;
    static constexpr float VEHICLE_TURN_SPEED = 30.0f;

    static constexpr float VEHICLE_MIN_SPACING = 60.0f;

    static constexpr float VEHICLE_ACCEL_RATE = 2.0f;

    static constexpr float VEHICLE_DECEL_RATE = 4.0f;

    // Traffic Light Configuration
    static constexpr float LIGHT_SIZE = 40.0f;
    static constexpr float LIGHT_SPACING = 60.0f;

    // Intersection Configuration
    static constexpr float INTERSECTION_RADIUS = 180.0f;
    static constexpr float TURN_GUIDE_RADIUS = 150.0f;

    // System Timing
    static constexpr int FILE_CHECK_INTERVAL = 100;    // ms
    static constexpr int TRAFFIC_UPDATE_INTERVAL = 50; // ms
    static constexpr float VEHICLE_PROCESS_TIME = 3.0f; // seconds


    static constexpr float TURN_ENTRY_DISTANCE = 100.0f;
    static constexpr float TURN_EXIT_DISTANCE = 100.0f;

    // Intersection Configuration
    static constexpr float INTERSECTION_SIZE = 360.0f;
    static constexpr float STOP_LINE_OFFSET = 20.0f;
    static constexpr float CROSSWALK_WIDTH = 30.0f;

  static constexpr float MAX_WAIT_TIME = 30.0f;


static constexpr float MIN_VEHICLE_SPACING = 60.0f;


// Add these constants to the class
static constexpr float UPDATE_INTERVAL = 0.016f;         // ~60 FPS
};


================================================================================
File: include\core\Lane.h
================================================================================

// Lane.h
#pragma once
#include "Vehicle.h"
#include "utils/Queue.h"
#include <memory>
#include <string>

class Lane {
private:
    LaneId id;
    Queue<std::shared_ptr<Vehicle>> vehicleQueue;
    bool isPriority;
    std::string dataFile;

public:
    Lane(LaneId id, bool isPriority);

    void addVehicle(std::shared_ptr<Vehicle> vehicle);
    std::shared_ptr<Vehicle> removeVehicle();
    Direction getVehicleDirection(size_t index) const;  // Add this method
    size_t getQueueSize() const;
    bool isPriorityLane() const;
    LaneId getId() const;
    const std::string& getDataFile() const;
    void update();
};


================================================================================
File: include\core\TrafficLight.h
================================================================================

// TrafficLight.h
#pragma once
#include <SDL3/SDL.h>
#include "Constants.h"
#include <cstdint>

class TrafficLight {
private:
    LightState state;                // Current light state
    LightState nextState;            // Next scheduled state
    float transitionProgress;        // Progress of state transition (0-1)
    float transitionDuration;        // Duration of transition animation
    float stateTimer;               // Timer for current state
    bool isTransitioning;           // Whether in transition between states
    float currentStateDuration;     // Duration for current state
    bool isPriorityMode;            // Whether in priority mode
    bool isForced;                  // Whether state is being forced

    // Private methods
    void startTransition(LightState newState);
    float getNextStateDuration() const;

public:
    TrafficLight();

    // Core state management
    void update(float deltaTime);
    void setState(LightState newState);
    LightState getState() const { return state; }
    void forceState(LightState newState, bool force = true);
    void setPriorityMode(bool enabled);

    // State query methods
    bool isInTransition() const { return isTransitioning; }
    float getTransitionProgress() const { return transitionProgress; }
    float getStateTimer() const { return stateTimer; }
    float getStateDuration() const;

    // Rendering
    void render(SDL_Renderer* renderer, float x, float y) const;
};


================================================================================
File: include\core\Vehicle.h
================================================================================

# pragma once
#include "core/Constants.h"
#include <cstdint>
#include <chrono>
#include <memory>
#include <string>

class Vehicle {
private:
    uint32_t id;
    Direction direction;
    LaneId currentLane;
    LaneId targetLane;  // Added for lane transitions
    float waitTime;
    bool isProcessing;
    float turnProgress;
    bool hasStartedTurn;
    float speed;
    float position;
    std::chrono::steady_clock::time_point entryTime;

    struct Position {
        float x;
        float y;
        float angle;
        float targetX;
        float targetY;
        float targetAngle;
    } pos;

public:
    Vehicle(uint32_t vehicleId, Direction dir, LaneId lane);

    // Core accessors
    uint32_t getId() const { return id; }
    Direction getDirection() const { return direction; }
    LaneId getCurrentLane() const { return currentLane; }
    LaneId getTargetLane() const { return targetLane; }
    bool isInProcess() const { return isProcessing; }
    float getWaitTime() const { return waitTime; }
    float getTurnProgress() const { return turnProgress; }
    bool hasTurnStarted() const { return hasStartedTurn; }
    float getSpeed() const { return speed; }
    float getPosition() const { return position; }

    // Position getters
    float getX() const { return pos.x; }
    float getY() const { return pos.y; }
    float getAngle() const { return pos.angle; }
    float getTargetX() const { return pos.targetX; }
    float getTargetY() const { return pos.targetY; }
    float getTargetAngle() const { return pos.targetAngle; }

    // State modifiers
    void setProcessing(bool processing);
    void updateWaitTime(float delta);
    void updateTurnProgress(float delta);
    void startTurn();
    void setSpeed(float newSpeed);
    void setPosition(float pos);
    void setTargetLane(LaneId lane) { targetLane = lane; }

    // Movement control
    void setTargetPosition(float x, float y, float angle);
    void updateMovement(float deltaTime);
    bool hasReachedTarget() const;
    float calculateTurnRadius() const;

    // Static helpers
    static float calculateLanePosition(LaneId lane, size_t queuePosition);
    static float calculateTurnAngle(Direction dir, LaneId fromLane, LaneId toLane);

    // Queue metrics
    std::chrono::steady_clock::time_point getEntryTime() const { return entryTime; }
    float getTimeInSystem() const;

    // Debug helper
    std::string toString() const;
};


================================================================================
File: include\managers\FileHandler.h
================================================================================

//FileHandler.h
#pragma once
#include "core/Vehicle.h"
#include "core/Constants.h"
#include <memory>
#include <vector>
#include <string>
#include <map>
#include <filesystem>
#include <chrono>
#include <mutex>

class FileHandler {
public:
    FileHandler();
    ~FileHandler() = default;

    // Core file operations
    std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> readNewVehicles();
    void clearLaneFiles();
    bool writeVehicleToLane(LaneId laneId, const std::shared_ptr<Vehicle>& vehicle);

    // State queries
    bool isLaneFileAvailable(LaneId laneId) const;
    size_t getVehicleCountInFile(LaneId laneId) const;
    std::chrono::system_clock::time_point getLastModifiedTime(LaneId laneId) const;

private:
    // File management
    std::map<LaneId, std::filesystem::path> laneFiles;
    std::map<std::filesystem::path, std::chrono::steady_clock::time_point> lastCheckTimes;
    std::map<std::filesystem::path, int64_t> lastReadPositions;
    std::filesystem::path dataDir;
    std::mutex fileMutex;

    // Configuration
    static constexpr int FILE_CHECK_INTERVAL_MS = 100;
    static const std::string BASE_PATH;

    // File operation methods
    void initializeFileSystem();
    void validateFileSystem() const;
    std::vector<std::shared_ptr<Vehicle>> parseVehicleData(const std::string& data, LaneId laneId);
    std::shared_ptr<Vehicle> parseVehicleLine(const std::string& line, LaneId laneId);
    void updateLastReadPosition(const std::filesystem::path& filepath, int64_t position);

    // Helper methods
    std::filesystem::path getLaneFilePath(LaneId laneId) const;
    bool shouldCheckFile(const std::filesystem::path& filepath) const;
    void ensureDirectoryExists(const std::filesystem::path& dir);
    void logFileOperation(const std::string& operation, const std::filesystem::path& filepath) const;

    // File access checks
    bool hasReadAccess(const std::filesystem::path& filepath) const;
    bool hasWriteAccess(const std::filesystem::path& filepath) const;

    // Error handling
    void handleFileError(const std::string& operation, const std::filesystem::path& filepath, const std::exception& e) const;
    void validateFilePath(const std::filesystem::path& filepath) const;

    // Data validation
    bool isValidVehicleData(const std::string& data) const;
    bool isValidVehicleId(uint32_t id) const;
    bool isValidDirection(char dirChar) const;

    // File system utilities
    void createEmptyFile(const std::filesystem::path& filepath);
    bool isFileEmpty(const std::filesystem::path& filepath) const;
    void truncateFile(const std::filesystem::path& filepath);

#ifdef _DEBUG
    // Debug helpers
    void dumpFileContents(const std::filesystem::path& filepath) const;
    void validateFileIntegrity() const;
    void checkFileSizes() const;
#endif
};


================================================================================
File: include\managers\IntersectionController.h
================================================================================

// IntersectionController.h
#pragma once

#include "core/Lane.h"
#include "core/Vehicle.h"
#include "utils/PriorityQueue.h"
#include <vector>
#include <memory>
#include <cmath>

class IntersectionController {
public:
    // Public types for status reporting
    struct LaneStatus {
        LaneId id;
        size_t queueSize;
        int priority;
        bool isActive;
        float waitTime;
    };

    struct ProcessingStats {
        float avgWaitTime;
        size_t totalVehiclesProcessed;
        size_t currentQueueSizes[12]; // One for each lane
        bool isPriorityMode;
    };

    // Constructor
    explicit IntersectionController(std::vector<std::unique_ptr<Lane>>& lanes);

    // Core update method
    void update(float deltaTime);

    // State query methods
    bool isInPriorityMode() const { return isPriorityMode; }
    std::vector<LaneStatus> getLaneStatuses() const;
    ProcessingStats getStats() const;

private:
    // Core components
    std::vector<std::unique_ptr<Lane>>& lanes;
    PriorityQueue<LaneId> laneQueue;

    // State tracking
    bool isPriorityMode;
    float stateTimer;
    float elapsedTime;
    float processingTimer;
    size_t vehiclesProcessedInState;
    size_t totalVehiclesProcessed;

    // Configuration constants
    static constexpr size_t PRIORITY_THRESHOLD = 10;     // Switch to priority mode at 10 vehicles
    static constexpr size_t PRIORITY_RELEASE_THRESHOLD = 5; // Return to normal mode at 5 vehicles
    static constexpr float MIN_STATE_TIME = 5.0f;        // Minimum time in any state
    static constexpr float MAX_STATE_TIME = 30.0f;       // Maximum time in any state
    static constexpr float MAX_WAIT_TIME = 45.0f;        // Maximum vehicle wait time
    static constexpr float BASE_VEHICLE_PROCESS_TIME = 2.0f; // Base time to process one vehicle

    // Queue management methods
    void updateLaneQueue();
    void processPriorityLane();
    void processNormalLanes();
    void processFreeLanes();
    size_t calculateVehiclesToProcess() const;

    // State management methods
    void handleStateTransition();
    void checkWaitTimes();
    void updateTimers(float deltaTime);
    void resetStateTimers();

    // Utility methods
    float calculateAverageWaitingVehicles() const;
    float calculateProcessingTime() const;
    bool shouldSwitchToNormalMode() const;
    bool shouldSwitchToPriorityMode() const;
    Lane* getPriorityLane() const;
    bool isFreeLane(LaneId id) const;
    int calculateLanePriority(const Lane& lane) const;
};


================================================================================
File: include\managers\TrafficManager.h
================================================================================

#pragma once
#include "core/Constants.h"
#include "core/Lane.h"
#include "core/TrafficLight.h"
#include "core/Vehicle.h"
#include "managers/FileHandler.h"
#include "utils/PriorityQueue.h"
#include <vector>
#include <memory>
#include <map>
#include <chrono>

struct Position {
    float x;
    float y;
    Position(float x_ = 0.0f, float y_ = 0.0f) : x(x_), y(y_) {}
};

struct VehicleState {
    std::shared_ptr<Vehicle> vehicle;
    Position pos;                  // Current position
    Position targetPos;           // Target position
    float speed;                  // Current speed
    bool isMoving;               // Is vehicle in motion
    Direction direction;          // Turn direction
    bool hasStartedTurn;         // Has turn begun
    float turnProgress;          // Turn progress (0-1)
    float waitTime;              // Time in queue
    float turnAngle;             // Current angle
    float targetAngle;           // Target angle
    Position turnCenter;         // Center of turn
    float turnRadius;            // Turn radius
    float startAngle;           // Start angle for turn
    float endAngle;             // End angle for turn
    float processingTime;        // Time being processed
    size_t queuePosition;        // Position in lane queue
    bool inIntersection;        // Whether in intersection
    bool isPassing;             // Whether passing through intersection
    bool isChangingLanes;       // Whether changing lanes
    bool hasStoppedAtLight;     // Whether stopped at light
    std::vector<Position> intermediateTargets;  // Waypoints for lane changes
    size_t currentTargetIndex;   // Current waypoint index
};

class TrafficManager {
public:
    TrafficManager();

    // Core update methods
    void update(float deltaTime);
    void addVehicleToLane(LaneId laneId, std::shared_ptr<Vehicle> vehicle);
    size_t getLaneSize(LaneId laneId) const;

    // State queries
    bool isInPriorityMode() const { return inPriorityMode; }
    const std::vector<std::unique_ptr<Lane>>& getLanes() const { return lanes; }
    const std::map<LaneId, TrafficLight>& getTrafficLights() const { return trafficLights; }
    const std::map<uint32_t, VehicleState>& getActiveVehicles() const { return activeVehicles; }

private:
    // Core components
    std::vector<std::unique_ptr<Lane>> lanes;
    std::map<LaneId, TrafficLight> trafficLights;
    std::map<uint32_t, VehicleState> activeVehicles;
    FileHandler fileHandler;

    // State tracking
    bool inPriorityMode;
    float stateTimer;
    float lastUpdateTime;
    float processingTimer;
    size_t totalVehiclesProcessed;
    float averageWaitTime;

    // Constants
    static constexpr size_t PRIORITY_THRESHOLD = 10;
    static constexpr size_t PRIORITY_RELEASE_THRESHOLD = 5;
    static constexpr float MIN_STATE_TIME = 5.0f;
    static constexpr float MAX_STATE_TIME = 30.0f;
    static constexpr float VEHICLE_PROCESS_TIME = 2.0f;

    // Vehicle movement methods
    void updateVehiclePositions(float deltaTime);
    void updateVehicleMovement(VehicleState& state, float deltaTime);
    void updateStraightMovement(VehicleState& state, float deltaTime);
    void updateTurningMovement(VehicleState& state, float deltaTime);
    bool checkCollision(const VehicleState& state, float newX, float newY) const;
    void calculateTurnParameters(VehicleState& state);
    void calculateTurnPath(VehicleState& state);
    void calculateLeftTurnPath(VehicleState& state);
    void calculateRightTurnPath(VehicleState& state);
    void calculateTargetPosition(VehicleState& state, LaneId laneId);
    bool hasReachedDestination(const VehicleState& state) const;

    // Vehicle state management
    void addNewVehicleToState(std::shared_ptr<Vehicle> vehicle, LaneId laneId);
    void updateVehicleQueuePosition(VehicleState& state, LaneId laneId, size_t queuePosition);
    bool isNearIntersection(const VehicleState& state) const;
    bool isInIntersection(const Position& pos) const;
    float getDistanceToIntersection(const VehicleState& state) const;
    bool hasVehicleAhead(const VehicleState& state) const;
    bool isVehicleAhead(const VehicleState& first, const VehicleState& second) const;
    float calculateTurningRadius(Direction dir) const;

    // Traffic flow methods
    void processNewVehicles();
    void processPriorityLane();
    void processNormalLanes(size_t vehicleCount);
    void processFreeLanes();
    void checkWaitTimes();
    size_t calculateVehiclesToProcess() const;

    // Lane management methods
    LaneId determineOptimalLane(Direction direction, LaneId sourceLane) const;
    LaneId determineTargetLane(LaneId currentLane, Direction direction) const;
    bool isValidSpawnLane(LaneId laneId, Direction direction) const;
    bool isFreeLane(LaneId laneId) const;
    Lane* getPriorityLane() const;
    Position calculateLaneEndpoint(LaneId laneId) const;
    void changeLaneToFree(VehicleState& state);
    void changeLaneToFirst(VehicleState& state);

    // Traffic light management
    void updateTrafficLights(float deltaTime);
    void synchronizeTrafficLights();
    void handleStateTransition(float deltaTime);
    bool checkPriorityConditions() const;
    bool canVehicleMove(const VehicleState& state) const;
    LightState getLightStateForLane(LaneId laneId) const;

    // Utility methods
    void updateTimers(float deltaTime);
    void cleanupRemovedVehicles();
    void removeVehicle(uint32_t vehicleId);
    void updateStatistics(float deltaTime);
    float calculateAverageWaitTime() const;
    size_t getQueuedVehicleCount() const;
};


================================================================================
File: include\utils\PriorityQueue.h
================================================================================

// include/utils/PriorityQueue.hpp
#pragma once
#include "Queue.h"

template <typename T> class PriorityQueue : public Queue<T> {
  struct PriorityNode : public Queue<T>::Node {
    int priority;
    PriorityNode(const T &value, int p) : Queue<T>::Node(value), priority(p) {}
  };

public:
  void enqueuePriority(const T &value, int priority) {
    auto newNode = std::make_shared<PriorityNode>(value, priority);

    if (this->isEmpty() ||
        static_cast<PriorityNode *>(this->front.get())->priority < priority) {
      newNode->next = this->front;
      this->front = newNode;
    } else {
      auto current = this->front;
      while (current->next &&
             static_cast<PriorityNode *>(current->next.get())->priority >=
                 priority) {
        current = current->next;
      }
      newNode->next = current->next;
      current->next = newNode;
    }
    this->size++;
  }
};


================================================================================
File: include\utils\Queue.h
================================================================================

// include/utils/Queue.h
#pragma once
#include <memory>
#include <stdexcept>

template<typename T>
class Queue {
protected:
    struct Node {
        T data;
        std::shared_ptr<Node> next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::shared_ptr<Node> front;
    std::shared_ptr<Node> rear;
    size_t size;

public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}

    virtual ~Queue() = default;

    void enqueue(const T& value) {
        auto newNode = std::make_shared<Node>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    T dequeue() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    bool isEmpty() const {
        return front == nullptr;
    }

    size_t getSize() const {
        return size;
    }

    T peek() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return front->data;
    }

    // Add index-based peek
    T peek(size_t index) const {
        if (index >= size) {
            throw std::out_of_range("Index out of bounds");
        }

        auto current = front;
        for (size_t i = 0; i < index; i++) {
            current = current->next;
        }
        return current->data;
    }
};


================================================================================
File: include\visualization\DebugOverlay.h
================================================================================

// DebugOverlay.h
#pragma once
#include <SDL3/SDL.h>
#include <cmath>
#include "managers/TrafficManager.h"
#include <map>

class DebugOverlay {
private:
    struct LaneStatistics {
        int vehicleCount;
        float avgWaitTime;
        int processedCount;
    };

    std::map<LaneId, LaneStatistics> stats;
    void updateStatistics(const TrafficManager& trafficManager);
    void renderQueueStats(SDL_Renderer* renderer, int x, int y);
    void renderLaneLoadIndicator(SDL_Renderer* renderer, int x, int y);
    void renderSystemStatus(SDL_Renderer* renderer, int x, int y);

public:
    DebugOverlay() = default;
    void render(SDL_Renderer* renderer, const TrafficManager& trafficManager);
};


================================================================================
File: include\visualization\Renderer.h
================================================================================

#pragma once


// Core SDL includes
#include <SDL3/SDL.h>

// Project includes
#include "managers/TrafficManager.h"
#include "visualization/DebugOverlay.h"
#include "core/Constants.h"

// Standard library includes
#include <memory>
#include <map>
#include <cmath>

/**
 * @class Renderer
 * @brief Handles visualization for the traffic simulation system
 */
class Renderer {
private:
    // Core SDL components
    SDL_Window* window;
    SDL_Renderer* renderer;

    // Debug components
    DebugOverlay debugOverlay;
    bool debugMode;
    bool showGrid;

    // Rendering constants
    static constexpr float VEHICLE_WIDTH = 40.0f;
    static constexpr float VEHICLE_HEIGHT = 30.0f;
    static constexpr float LIGHT_SIZE = 20.0f;
    static constexpr float ARROW_SIZE = 30.0f;
    static constexpr float DASH_LENGTH = 20.0f;
    static constexpr float GAP_LENGTH = 20.0f;
    static constexpr float HOUSING_PADDING = 5.0f;

    // Environment rendering methods
    void renderBackground();
    void renderGrassAreas();
    void renderRoads();
    void renderRoadEdges();
    void renderLanes();
    void renderIntersection();
    void renderCrosswalks();
    void renderStopLines();

    // Traffic elements rendering
    void renderDirectionalArrows();
    void renderTrafficLights(const std::map<LaneId, TrafficLight>& lights);

    void renderTrafficLight(float x, float y, float rotation, LightState state);
    void renderVehicles(const std::map<uint32_t, VehicleState>& vehicles);
    void renderVehicle(float x, float y, Direction dir, bool isPriority, float angle, bool isMoving);
    void renderPriorityLane();
    void renderPriorityLaneIndicator();
    void renderTurningGuides();

    // Debug visualization
    void renderLaneIdentifiers();
    void renderVehicleCount(const TrafficManager& trafficManager);
    void drawDebugGrid();

    // Helper methods
    void drawArrow(float x, float y, float angle, Direction dir);
    void renderCircle(float x, float y, float radius);
    void renderDashedLine(float x1, float y1, float x2, float y2);
    void renderRoundedRect(float x, float y, float w, float h, float radius);
    SDL_FPoint rotatePoint(float x, float y, float cx, float cy, float angle);
    float calculateTurningAngle(const VehicleState& state) const;
    SDL_Color getLaneColor(LaneId laneId, bool isActive) const;

public:
    // Constructor and destructor
    Renderer();
    ~Renderer();

    // Core methods
    bool initialize();
    void render(const TrafficManager& trafficManager);
    void cleanup();
    bool isInitialized() const { return window != nullptr && renderer != nullptr; }

    // Configuration methods
    void setDebugMode(bool enabled) { debugMode = enabled; }
    void toggleGridDisplay() { showGrid = !showGrid; }
    void updateWindowSize(int width, int height);
};


================================================================================
File: src\common\types.h
================================================================================

// src/common/types.h
#pragma once
#include <cstdint>
#include <string>

enum class LaneId {
    AL1_INCOMING,
    AL2_PRIORITY,
    AL3_FREELANE,
    BL1_INCOMING,
    BL2_NORMAL,
    BL3_FREELANE,
    CL1_INCOMING,
    CL2_NORMAL,
    CL3_FREELANE,
    DL1_INCOMING,
    DL2_NORMAL,
    DL3_FREELANE
};

enum class LightState {
    RED,
    GREEN
};

;


================================================================================
File: src\common\vector2d.h
================================================================================

// src/utils/vector2d.h
#pragma once

struct Vector2D {
    float x;
    float y;

    Vector2D() : x(0.0f), y(0.0f) {}
    Vector2D(float x, float y) : x(x), y(y) {}

    Vector2D operator+(const Vector2D& other) const {
        return Vector2D(x + other.x, y + other.y);
    }

    Vector2D operator*(float scalar) const {
        return Vector2D(x * scalar, y * scalar);
    }
};



================================================================================
File: src\core\Lane.cpp
================================================================================

// src/core/Lane.cpp
#include "core/Lane.h"
#include <filesystem>

Lane::Lane(LaneId id, bool isPriority)
    : id(id), isPriority(isPriority) {
    // Set up data file path based on lane ID
    std::string lanePrefix;
    switch(id) {
        case LaneId::AL1_INCOMING: lanePrefix = "a1"; break;
        case LaneId::AL2_PRIORITY: lanePrefix = "a2"; break;
        case LaneId::AL3_FREELANE: lanePrefix = "a3"; break;
        // ... add other cases
        default: lanePrefix = "unknown";
    }
    dataFile = "data/lanes/lane_" + lanePrefix + ".txt";
}


Direction Lane::getVehicleDirection(size_t index) const {
    if (index >= vehicleQueue.getSize()) {
        return Direction::STRAIGHT;  // Default direction
    }

    // This assumes you maintain the vehicles in order in your queue
    // You might need to adjust this based on your Queue implementation
    auto vehicle = vehicleQueue.peek(index);
    return vehicle ? vehicle->getDirection() : Direction::STRAIGHT;
}

void Lane::addVehicle(std::shared_ptr<Vehicle> vehicle) {
    vehicleQueue.enqueue(vehicle);
}

std::shared_ptr<Vehicle> Lane::removeVehicle() {
    if (vehicleQueue.isEmpty()) return nullptr;
    return vehicleQueue.dequeue();
}

size_t Lane::getQueueSize() const {
    return vehicleQueue.getSize();
}

bool Lane::isPriorityLane() const {
    return isPriority;
}

LaneId Lane::getId() const {
    return id;
}

const std::string& Lane::getDataFile() const {
    return dataFile;
}

void Lane::update() {
    // Update logic for free lanes
    if (id == LaneId::AL3_FREELANE ||
        id == LaneId::BL3_FREELANE ||
        id == LaneId::CL3_FREELANE ||
        id == LaneId::DL3_FREELANE) {
        // Free lanes process vehicles immediately
        while (!vehicleQueue.isEmpty()) {
            removeVehicle();
        }
    }
}


================================================================================
File: src\core\TrafficLight.cpp
================================================================================

// TrafficLight.cpp
#include "core/TrafficLight.h"
#include <cmath>

TrafficLight::TrafficLight()
    : state(LightState::RED)
    , nextState(LightState::RED)
    , transitionProgress(0.0f)
    , transitionDuration(1.0f)
    , stateTimer(0.0f)
    , isTransitioning(false)
    , currentStateDuration(30.0f)  // Default duration
    , isPriorityMode(false)
    , isForced(false)
{
}

void TrafficLight::update(float deltaTime) {
    // Don't update if state is being forced
    if (isForced) {
        return;
    }

    stateTimer += deltaTime;

    if (isTransitioning) {
        // Handle transition animation
        transitionProgress += deltaTime / transitionDuration;
        if (transitionProgress >= 1.0f) {
            state = nextState;
            isTransitioning = false;
            transitionProgress = 0.0f;
            stateTimer = 0.0f;
            currentStateDuration = getNextStateDuration();
        }
    }
    else if (stateTimer >= currentStateDuration) {
        // Time to change state
        LightState newState = (state == LightState::RED) ? LightState::GREEN : LightState::RED;
        startTransition(newState);
    }
}

void TrafficLight::setState(LightState newState) {
    if (state != newState && !isTransitioning) {
        startTransition(newState);
    }
}

void TrafficLight::forceState(LightState newState, bool force) {
    isForced = force;
    if (force) {
        state = newState;
        nextState = newState;
        isTransitioning = false;
        transitionProgress = 0.0f;
        stateTimer = 0.0f;
    } else {
        isForced = false;
        setState(newState);
    }
}

void TrafficLight::setPriorityMode(bool enabled) {
    isPriorityMode = enabled;
    // Adjust timings when priority mode changes
    currentStateDuration = getStateDuration();
}

float TrafficLight::getStateDuration() const {
    if (isPriorityMode) {
        return (state == LightState::GREEN) ? 40.0f : 20.0f;  // Longer green in priority
    }
    return (state == LightState::GREEN) ? 30.0f : 30.0f;  // Equal in normal mode
}

float TrafficLight::getNextStateDuration() const {
    if (isPriorityMode) {
        return (nextState == LightState::GREEN) ? 40.0f : 20.0f;
    }
    return 30.0f;
}

void TrafficLight::startTransition(LightState newState) {
    nextState = newState;
    isTransitioning = true;
    transitionProgress = 0.0f;
    stateTimer = 0.0f;
}

void TrafficLight::render(SDL_Renderer* renderer, float x, float y) const {
    // Constants for rendering
    const float LIGHT_SIZE = 30.0f;
    const float HOUSING_PADDING = 5.0f;
    const float HOUSING_WIDTH = LIGHT_SIZE + (HOUSING_PADDING * 2.0f);
    const float HOUSING_HEIGHT = (LIGHT_SIZE * 2.0f) + (HOUSING_PADDING * 3.0f);

    // Draw housing (dark gray background)
    SDL_FRect housing = {
        x - HOUSING_PADDING,
        y - HOUSING_PADDING,
        HOUSING_WIDTH,
        HOUSING_HEIGHT
    };
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);
    SDL_RenderFillRect(renderer, &housing);

    // Draw border
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_RenderRect(renderer, &housing);

    // Calculate light positions
    float redY = y;
    float greenY = y + LIGHT_SIZE + HOUSING_PADDING;

    // Draw RED light
    SDL_FRect redLight = {x, redY, LIGHT_SIZE, LIGHT_SIZE};
    float redIntensity;
    if (state == LightState::RED) {
        redIntensity = isTransitioning ? (1.0f - transitionProgress) : 1.0f;
    } else {
        redIntensity = isTransitioning ? transitionProgress : 0.0f;
    }
    SDL_SetRenderDrawColor(renderer,
        255,  // Red always max
        static_cast<uint8_t>(50 * redIntensity),  // Slight glow
        static_cast<uint8_t>(50 * redIntensity),  // Slight glow
        255
    );
    SDL_RenderFillRect(renderer, &redLight);

    // Draw GREEN light
    SDL_FRect greenLight = {x, greenY, LIGHT_SIZE, LIGHT_SIZE};
    float greenIntensity;
    if (state == LightState::GREEN) {
        greenIntensity = isTransitioning ? (1.0f - transitionProgress) : 1.0f;
    } else {
        greenIntensity = isTransitioning ? transitionProgress : 0.0f;
    }
    SDL_SetRenderDrawColor(renderer,
        static_cast<uint8_t>(50 * greenIntensity),  // Slight glow
        255,  // Green always max
        static_cast<uint8_t>(50 * greenIntensity),  // Slight glow
        255
    );
    SDL_RenderFillRect(renderer, &greenLight);

    // Draw light borders
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}


================================================================================
File: src\core\Vehicle.cpp
================================================================================


// src/core/Vehicle.cpp
#include "core/Vehicle.h"
#include <sstream>
#include <iomanip>
#include <cmath>

Vehicle::Vehicle(uint32_t vehicleId, Direction dir, LaneId lane)
    : id(vehicleId)
    , direction(dir)
    , currentLane(lane)
    , waitTime(0.0f)
    , isProcessing(false)
    , turnProgress(0.0f)
    , hasStartedTurn(false)
    , speed(0.0f)
    , position(0.0f)
    , entryTime(std::chrono::steady_clock::now())
{
    // Initialize position
    pos.x = 0.0f;
    pos.y = 0.0f;
    pos.angle = 0.0f;
    pos.targetX = 0.0f;
    pos.targetY = 0.0f;
    pos.targetAngle = 0.0f;
}

void Vehicle::setProcessing(bool processing) {
    isProcessing = processing;
    if (processing) {
        speed = SimConstants::VEHICLE_BASE_SPEED;
    }
}

void Vehicle::updateWaitTime(float delta) {
    if (!isProcessing) {
        waitTime += delta;
    }
}

void Vehicle::updateTurnProgress(float delta) {
    if (hasStartedTurn && turnProgress < 1.0f) {
        turnProgress = std::min(1.0f, turnProgress + delta);
    }
}

void Vehicle::startTurn() {
    hasStartedTurn = true;
    turnProgress = 0.0f;
    speed = SimConstants::VEHICLE_TURN_SPEED;
}

void Vehicle::setSpeed(float newSpeed) {
    speed = newSpeed;
}

void Vehicle::setPosition(float newPos) {
    position = newPos;
}

void Vehicle::setTargetPosition(float x, float y, float angle) {
    pos.targetX = x;
    pos.targetY = y;
    pos.targetAngle = angle;
}

void Vehicle::updateMovement(float deltaTime) {
    if (!isProcessing) return;

    // Calculate distance to target
    float dx = pos.targetX - pos.x;
    float dy = pos.targetY - pos.y;
    float distance = std::sqrt(dx * dx + dy * dy);

    // Update position if not at target
    if (distance > 0.1f) {
        float moveSpeed = speed * deltaTime;
        float moveRatio = std::min(1.0f, moveSpeed / distance);

        pos.x += dx * moveRatio;
        pos.y += dy * moveRatio;

        // Update angle smoothly using floats explicitly
        float targetAngle = std::atan2f(dy, dx);
        float angleDiff = targetAngle - pos.angle;

        // Normalize angle to [-π, π] using float constants
        while (angleDiff > static_cast<float>(M_PI)) {
            angleDiff -= 2.0f * static_cast<float>(M_PI);
        }
        while (angleDiff < -static_cast<float>(M_PI)) {
            angleDiff += 2.0f * static_cast<float>(M_PI);
        }

        pos.angle += angleDiff * moveRatio;
    }
}

bool Vehicle::hasReachedTarget() const {
    float dx = pos.targetX - pos.x;
    float dy = pos.targetY - pos.y;
    return std::sqrt(dx * dx + dy * dy) < 0.1f;
}

float Vehicle::calculateTurnRadius() const {
    switch (direction) {
        case Direction::LEFT:
            return SimConstants::TURN_GUIDE_RADIUS * 1.2f;
        case Direction::RIGHT:
            return SimConstants::TURN_GUIDE_RADIUS * 0.8f;
        default:
            return SimConstants::TURN_GUIDE_RADIUS;
    }
}

float Vehicle::calculateLanePosition(LaneId lane, size_t queuePosition) {
    using namespace SimConstants;
    float baseOffset = QUEUE_START_OFFSET + queuePosition * QUEUE_SPACING;

    switch (lane) {
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE:
            return CENTER_X - baseOffset;

        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE:
            return CENTER_Y - baseOffset;

        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE:
            return CENTER_X + baseOffset;

        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE:
            return CENTER_Y + baseOffset;

        default:
            return 0.0f;
    }
}

float Vehicle::calculateTurnAngle(Direction dir, LaneId fromLane, LaneId /*toLane*/) {
    const float WEST_ANGLE = 0.0f;
    const float NORTH_ANGLE = static_cast<float>(M_PI) / 2.0f;
    const float EAST_ANGLE = static_cast<float>(M_PI);
    const float SOUTH_ANGLE = -static_cast<float>(M_PI) / 2.0f;

    // Get base angle from source lane
    float baseAngle;
    if (fromLane <= LaneId::AL3_FREELANE) baseAngle = WEST_ANGLE;
    else if (fromLane <= LaneId::BL3_FREELANE) baseAngle = NORTH_ANGLE;
    else if (fromLane <= LaneId::CL3_FREELANE) baseAngle = EAST_ANGLE;
    else baseAngle = SOUTH_ANGLE;

    // Adjust for turn direction
    switch (dir) {
        case Direction::LEFT:
            return baseAngle - static_cast<float>(M_PI) / 2.0f;
        case Direction::RIGHT:
            return baseAngle + static_cast<float>(M_PI) / 2.0f;
        default:
            return baseAngle;
    }
}

float Vehicle::getTimeInSystem() const {
    auto now = std::chrono::steady_clock::now();
    return std::chrono::duration<float>(now - entryTime).count();
}

std::string Vehicle::toString() const {
    std::stringstream ss;
    ss << "Vehicle[ID:" << id
       << ", Lane:" << static_cast<int>(currentLane)
       << ", Dir:" << static_cast<int>(direction)
       << ", Pos:(" << std::fixed << std::setprecision(1)
       << pos.x << "," << pos.y << ")"
       << ", Wait:" << std::setprecision(1) << waitTime << "s"
       << ", Turn:" << (hasStartedTurn ? "Yes" : "No")
       << ", Progress:" << std::setprecision(2) << turnProgress * 100 << "%]";
    return ss.str();
}


================================================================================
File: src\main.cpp
================================================================================

// src/main.cpp
#include <SDL3/SDL.h>
#include "managers/TrafficManager.h"
#include "managers/FileHandler.h"
#include "visualization/Renderer.h"
#include <iostream>
#include <chrono>

class Simulator {
private:
    TrafficManager trafficManager;
    Renderer renderer;
    bool running;

    void processInput() {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
                case SDL_EVENT_QUIT:
                    running = false;
                    break;
                case SDL_EVENT_KEY_DOWN:
                    // For SDL3, we use scancode instead of keysym
                    if (event.key.scancode == SDL_SCANCODE_ESCAPE) {
                        running = false;
                    }
                    break;
            }
        }
    }

    void update(float deltaTime) {
        trafficManager.update(deltaTime);
    }

    void render() {
        renderer.render(trafficManager);
    }

public:
    Simulator() : running(false) {}

    bool initialize() {
        if (!renderer.initialize()) {
            std::cerr << "Failed to initialize renderer" << std::endl;
            return false;
        }

        // Clear any existing vehicle data
        FileHandler fileHandler;
        fileHandler.clearLaneFiles();

        running = true;
        return true;
    }

    void run() {
        auto lastUpdateTime = std::chrono::high_resolution_clock::now();

        while (running) {
            auto currentTime = std::chrono::high_resolution_clock::now();
            float deltaTime = std::chrono::duration<float>(currentTime - lastUpdateTime).count();
            lastUpdateTime = currentTime;

            processInput();
            update(deltaTime);
            render();

            // Cap frame rate at ~60 FPS
            if (deltaTime < 0.016f) {
                SDL_Delay(static_cast<uint32_t>((0.016f - deltaTime) * 1000));
            }
        }
    }

    void cleanup() {
        renderer.cleanup();
    }
};

int main(int argc, char* argv[]) {
    (void)argc; // Suppress unused parameter warning
    (void)argv; // Suppress unused parameter warning

    Simulator simulator;

    if (!simulator.initialize()) {
        std::cerr << "Failed to initialize simulator" << std::endl;
        return 1;
    }

    std::cout << "Traffic Simulator Started\n";
    std::cout << "Press ESC to exit\n";

    simulator.run();
    simulator.cleanup();

    return 0;
}


================================================================================
File: src\managers\FileHandler.cpp
================================================================================

// FileHandler.cpp
#include "managers/FileHandler.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>

const std::string FileHandler::BASE_PATH = "data/lanes";

FileHandler::FileHandler() {
    try {
        initializeFileSystem();
    } catch (const std::exception& e) {
        std::cerr << "FileHandler initialization failed: " << e.what() << std::endl;
        throw;
    }
}

void FileHandler::initializeFileSystem() {
    // Setup data directory path
    dataDir = (std::filesystem::current_path() / BASE_PATH).lexically_normal();
    std::cout << "FileHandler using path: " << dataDir << std::endl;

    // Initialize lane file paths
    laneFiles = {
        {LaneId::AL1_INCOMING, (dataDir / "lane_a1.txt").lexically_normal()},
        {LaneId::AL2_PRIORITY, (dataDir / "lane_a2.txt").lexically_normal()},
        {LaneId::AL3_FREELANE, (dataDir / "lane_a3.txt").lexically_normal()},
        {LaneId::BL1_INCOMING, (dataDir / "lane_b1.txt").lexically_normal()},
        {LaneId::BL2_NORMAL,   (dataDir / "lane_b2.txt").lexically_normal()},
        {LaneId::BL3_FREELANE, (dataDir / "lane_b3.txt").lexically_normal()},
        {LaneId::CL1_INCOMING, (dataDir / "lane_c1.txt").lexically_normal()},
        {LaneId::CL2_NORMAL,   (dataDir / "lane_c2.txt").lexically_normal()},
        {LaneId::CL3_FREELANE, (dataDir / "lane_c3.txt").lexically_normal()},
        {LaneId::DL1_INCOMING, (dataDir / "lane_d1.txt").lexically_normal()},
        {LaneId::DL2_NORMAL,   (dataDir / "lane_d2.txt").lexically_normal()},
        {LaneId::DL3_FREELANE, (dataDir / "lane_d3.txt").lexically_normal()}
    };

    // Create directory structure
    std::filesystem::create_directories(dataDir);

    // Initialize all files
    for (const auto& [laneId, filepath] : laneFiles) {
        if (!std::filesystem::exists(filepath)) {
            std::ofstream file(filepath);
            if (!file) {
                throw std::runtime_error("Cannot create file: " + filepath.string());
            }
        }
        lastReadPositions[filepath] = 0;
        lastCheckTimes[filepath] = std::chrono::steady_clock::now();
    }
}

// In FileHandler.cpp
std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> FileHandler::readNewVehicles() {
    std::vector<std::pair<LaneId, std::shared_ptr<Vehicle>>> newVehicles;
    std::lock_guard<std::mutex> lock(fileMutex);

    for (const auto& [laneId, filepath] : laneFiles) {
        try {
            if (!std::filesystem::exists(filepath)) continue;

            std::ifstream file(filepath);
            if (!file) continue;

            std::string line;
            std::vector<std::string> lines;
            while (std::getline(file, line)) {
                if (!line.empty()) {
                    lines.push_back(line);
                }
            }

            // Clear file after reading
            file.close();
            std::ofstream clearFile(filepath, std::ios::trunc);

            // Process lines
            for (const auto& line : lines) {
                size_t commaPos = line.find(',');
                size_t semicolonPos = line.find(';');

                if (commaPos != std::string::npos && semicolonPos != std::string::npos) {
                    try {
                        uint32_t id = std::stoul(line.substr(0, commaPos));
                        char dirChar = line[commaPos + 1];

                        Direction dir;
                        switch (dirChar) {
                            case 'S': dir = Direction::STRAIGHT; break;
                            case 'L': dir = Direction::LEFT; break;
                            case 'R': dir = Direction::RIGHT; break;
                            default: continue;
                        }

                        auto vehicle = std::make_shared<Vehicle>(id, dir, laneId);
                        newVehicles.emplace_back(laneId, vehicle);

                        std::cout << "Read vehicle " << id << " from " << filepath
                                 << " with direction " << static_cast<int>(dir) << std::endl;
                    } catch (const std::exception& e) {
                        std::cerr << "Error parsing line: " << line << " - " << e.what() << std::endl;
                    }
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "Error reading file " << filepath << ": " << e.what() << std::endl;
        }
    }

    return newVehicles;
}

std::shared_ptr<Vehicle> FileHandler::parseVehicleLine(const std::string& line, LaneId laneId) {
    size_t commaPos = line.find(',');
    size_t semicolonPos = line.find(';');

    if (commaPos == std::string::npos || semicolonPos == std::string::npos) {
        return nullptr;
    }

    try {
        uint32_t id = std::stoul(line.substr(0, commaPos));
        char dirChar = line[commaPos + 1];

        Direction dir;
        switch (dirChar) {
            case 'S': dir = Direction::STRAIGHT; break;
            case 'L': dir = Direction::LEFT; break;
            case 'R': dir = Direction::RIGHT; break;
            default: return nullptr;
        }

        return std::make_shared<Vehicle>(id, dir, laneId);
    } catch (const std::exception& e) {
        std::cerr << "Error parsing line: " << line << " - " << e.what() << std::endl;
        return nullptr;
    }
}

void FileHandler::clearLaneFiles() {
    std::lock_guard<std::mutex> lock(fileMutex);

    for (const auto& [_, filepath] : laneFiles) {
        std::ofstream file(filepath, std::ios::trunc);
        lastReadPositions[filepath] = 0;
    }
}

size_t FileHandler::getVehicleCountInFile(LaneId laneId) const {
    auto it = laneFiles.find(laneId);
    if (it == laneFiles.end()) return 0;

    try {
        std::ifstream file(it->second);
        if (!file) return 0;

        size_t count = 0;
        std::string line;
        while (std::getline(file, line)) {
            if (!line.empty()) count++;
        }
        return count;
    } catch (const std::exception& e) {
        std::cerr << "Error counting vehicles: " << e.what() << std::endl;
        return 0;
    }
}

void FileHandler::handleFileError(const std::string& operation,
                                const std::filesystem::path& filepath,
                                const std::exception& e) const {
    std::cerr << "File " << operation << " error for " << filepath
              << ": " << e.what() << std::endl;
}


================================================================================
File: src\managers\IntersectionController.cpp
================================================================================

// IntersectionController.cpp
#include "managers/IntersectionController.h"
#include <algorithm>
#include <numeric>

IntersectionController::IntersectionController(std::vector<std::unique_ptr<Lane>>& lanes)
    : lanes(lanes)
    , isPriorityMode(false)
    , stateTimer(0.0f)
    , elapsedTime(0.0f)
    , processingTimer(0.0f)
    , vehiclesProcessedInState(0)
    , totalVehiclesProcessed(0)
{
    updateLaneQueue();
}

void IntersectionController::update(float deltaTime) {
    updateTimers(deltaTime);

    // Check state transitions
    handleStateTransition();

    // Process vehicles based on current state
    if (processingTimer >= calculateProcessingTime()) {
        if (isPriorityMode) {
            processPriorityLane();
        } else {
            processNormalLanes();
        }
        processFreeLanes();
        processingTimer = 0.0f;
    }

    // Check wait times and update priorities
    checkWaitTimes();
    updateLaneQueue();
}

void IntersectionController::updateLaneQueue() {
    // Clear existing queue
    while (!laneQueue.isEmpty()) {
        laneQueue.dequeue();
    }

    // Add lanes with calculated priorities
    for (const auto& lane : lanes) {
        if (!isFreeLane(lane->getId())) {
            int priority = calculateLanePriority(*lane);
            laneQueue.enqueuePriority(lane->getId(), priority);
        }
    }
}

int IntersectionController::calculateLanePriority(const Lane& lane) const {
    int priority = 1; // Base priority

    if (lane.isPriorityLane() && lane.getQueueSize() > PRIORITY_THRESHOLD) {
        priority = 3; // Highest priority
    }
    else if (lane.getQueueSize() > 8) {
        priority = 2; // Medium priority
    }

    return priority;
}

void IntersectionController::processPriorityLane() {
    Lane* priorityLane = getPriorityLane();
    if (!priorityLane) return;

    size_t initialSize = priorityLane->getQueueSize();
    while (priorityLane->getQueueSize() > PRIORITY_RELEASE_THRESHOLD) {
        auto vehicle = priorityLane->removeVehicle();
        if (vehicle) {
            vehiclesProcessedInState++;
            totalVehiclesProcessed++;
        }
    }
}

void IntersectionController::processNormalLanes() {
    size_t vehiclesToProcess = calculateVehiclesToProcess();

    for (auto& lane : lanes) {
        if (!isFreeLane(lane->getId()) && !lane->isPriorityLane()) {
            for (size_t i = 0; i < vehiclesToProcess && lane->getQueueSize() > 0; ++i) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

void IntersectionController::processFreeLanes() {
    for (auto& lane : lanes) {
        if (isFreeLane(lane->getId())) {
            while (lane->getQueueSize() > 0) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

size_t IntersectionController::calculateVehiclesToProcess() const {
    // |V| = 1/n Σ|Li| formula from assignment
    float avgVehicles = calculateAverageWaitingVehicles();
    return static_cast<size_t>(std::ceil(avgVehicles));
}

float IntersectionController::calculateAverageWaitingVehicles() const {
    size_t totalVehicles = 0;
    size_t normalLaneCount = 0;

    // Only count vehicles in normal lanes (not free or priority lanes)
    for (const auto& lane : lanes) {
        if (!isFreeLane(lane->getId()) && !lane->isPriorityLane()) {
            totalVehicles += lane->getQueueSize();
            normalLaneCount++;
        }
    }

    return normalLaneCount > 0 ?
        static_cast<float>(totalVehicles) / static_cast<float>(normalLaneCount) : 0.0f;
}

float IntersectionController::calculateProcessingTime() const {
    // According to assignment formula: T = |V| * t
    // where |V| = average number of waiting vehicles
    // and t = 2 seconds per vehicle

    if (isPriorityMode) {
        // In priority mode, only process priority lane
        Lane* priorityLane = getPriorityLane();
        if (priorityLane) {
            return priorityLane->getQueueSize() * BASE_VEHICLE_PROCESS_TIME;
        }
        return 0.0f;
    }

    // In normal mode, calculate average of normal lanes
    float avgVehicles = calculateAverageWaitingVehicles();
    return avgVehicles * BASE_VEHICLE_PROCESS_TIME;
}

void IntersectionController::handleStateTransition() {
    if (isPriorityMode && shouldSwitchToNormalMode()) {
        isPriorityMode = false;
        resetStateTimers();
    }
    else if (!isPriorityMode && shouldSwitchToPriorityMode()) {
        isPriorityMode = true;
        resetStateTimers();
    }

    // Force state change if stuck too long
    if (stateTimer >= MAX_STATE_TIME) {
        isPriorityMode = !isPriorityMode;
        resetStateTimers();
    }
}

bool IntersectionController::shouldSwitchToNormalMode() const {
    if (!isPriorityMode) return false;

    Lane* priorityLane = getPriorityLane();
    return priorityLane &&
           priorityLane->getQueueSize() <= PRIORITY_RELEASE_THRESHOLD &&
           stateTimer >= MIN_STATE_TIME;
}

bool IntersectionController::shouldSwitchToPriorityMode() const {
    if (isPriorityMode) return false;

    Lane* priorityLane = getPriorityLane();
    return priorityLane &&
           priorityLane->getQueueSize() > PRIORITY_THRESHOLD &&
           stateTimer >= MIN_STATE_TIME;
}

void IntersectionController::resetStateTimers() {
    stateTimer = 0.0f;
    processingTimer = 0.0f;
    vehiclesProcessedInState = 0;
}

Lane* IntersectionController::getPriorityLane() const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [](const auto& lane) { return lane->isPriorityLane(); });
    return it != lanes.end() ? it->get() : nullptr;
}

bool IntersectionController::isFreeLane(LaneId id) const {
    return id == LaneId::AL3_FREELANE ||
           id == LaneId::BL3_FREELANE ||
           id == LaneId::CL3_FREELANE ||
           id == LaneId::DL3_FREELANE;
}

void IntersectionController::checkWaitTimes() {
    for (const auto& lane : lanes) {
        if (lane->getQueueSize() > 0 && !isFreeLane(lane->getId())) {
            // Process lanes that have been waiting too long
            if (lane->getQueueSize() >= 8) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    vehiclesProcessedInState++;
                    totalVehiclesProcessed++;
                }
            }
        }
    }
}

void IntersectionController::updateTimers(float deltaTime) {
    stateTimer += deltaTime;
    elapsedTime += deltaTime;
    processingTimer += deltaTime;
}

std::vector<IntersectionController::LaneStatus> IntersectionController::getLaneStatuses() const {
    std::vector<LaneStatus> statuses;

    for (const auto& lane : lanes) {
        LaneStatus status;
        status.id = lane->getId();
        status.queueSize = lane->getQueueSize();
        status.isActive = isPriorityMode ? lane->isPriorityLane() :
                         !isFreeLane(lane->getId());
        status.priority = calculateLanePriority(*lane);

        statuses.push_back(status);
    }

    return statuses;
}

IntersectionController::ProcessingStats IntersectionController::getStats() const {
    ProcessingStats stats;
    stats.totalVehiclesProcessed = totalVehiclesProcessed;
    stats.isPriorityMode = isPriorityMode;

    // Fill current queue sizes
    size_t laneIndex = 0;
    for (const auto& lane : lanes) {
        stats.currentQueueSizes[laneIndex++] = lane->getQueueSize();
    }

    return stats;
}


================================================================================
File: src\managers\TrafficManager.cpp
================================================================================

// TrafficManager.cpp
#include "managers/TrafficManager.h"
#include <cmath>
#include <algorithm>
#include <iostream>
#include<core/Constants.h>

TrafficManager::TrafficManager()
    : inPriorityMode(false)
    , stateTimer(0.0f)
    , lastUpdateTime(0.0f)
    , processingTimer(0.0f)
    , totalVehiclesProcessed(0)
    , averageWaitTime(0.0f)
{
    // Initialize lanes
    lanes.push_back(std::make_unique<Lane>(LaneId::AL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::AL2_PRIORITY, true));
    lanes.push_back(std::make_unique<Lane>(LaneId::AL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::BL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::CL3_FREELANE, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL1_INCOMING, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL2_NORMAL, false));
    lanes.push_back(std::make_unique<Lane>(LaneId::DL3_FREELANE, false));

    // Initialize traffic lights
    trafficLights[LaneId::AL2_PRIORITY] = TrafficLight();
    trafficLights[LaneId::BL2_NORMAL] = TrafficLight();
    trafficLights[LaneId::CL2_NORMAL] = TrafficLight();
    trafficLights[LaneId::DL2_NORMAL] = TrafficLight();

    synchronizeTrafficLights();
}

void TrafficManager::update(float deltaTime) {
    updateTimers(deltaTime);
    processNewVehicles();
    handleStateTransition(deltaTime);
    updateVehiclePositions(deltaTime);
    updateTrafficLights(deltaTime);
    updateStatistics(deltaTime);

    // Process vehicles based on mode
    if (processingTimer >= VEHICLE_PROCESS_TIME) {
        if (inPriorityMode) {
            processPriorityLane();
        } else {
            processNormalLanes(calculateVehiclesToProcess());
        }
        processFreeLanes();
        processingTimer = 0.0f;
    }

    checkWaitTimes();
    cleanupRemovedVehicles();
}


void TrafficManager::updateVehicleMovement(VehicleState& state, float deltaTime) {
    if (!state.isMoving) return;

    using namespace SimConstants;

    // Check if vehicle should start turning
    if (!state.hasStartedTurn && state.direction != Direction::STRAIGHT) {
        float distToIntersection = getDistanceToIntersection(state);
        if (distToIntersection < TURN_ENTRY_DISTANCE) {
            state.hasStartedTurn = true;
            state.turnProgress = 0.0f;
            state.speed = VEHICLE_TURN_SPEED;
            calculateTurnParameters(state);
        }
    }

    if (state.hasStartedTurn) {
        // Execute turn
        updateTurningMovement(state, deltaTime);
    } else {
        // Normal straight movement
        updateStraightMovement(state, deltaTime);
    }
}


void TrafficManager::addVehicleToLane(LaneId laneId, std::shared_ptr<Vehicle> vehicle) {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [laneId](const auto& lane) { return lane->getId() == laneId; });

    if (it != lanes.end()) {
        (*it)->addVehicle(vehicle);
    }
}

size_t TrafficManager::getLaneSize(LaneId laneId) const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [laneId](const auto& lane) { return lane->getId() == laneId; });
    return it != lanes.end() ? (*it)->getQueueSize() : 0;
}

bool TrafficManager::isFreeLane(LaneId laneId) const {
    return laneId == LaneId::AL3_FREELANE ||
           laneId == LaneId::BL3_FREELANE ||
           laneId == LaneId::CL3_FREELANE ||
           laneId == LaneId::DL3_FREELANE;
}

Lane* TrafficManager::getPriorityLane() const {
    auto it = std::find_if(lanes.begin(), lanes.end(),
        [](const auto& lane) { return lane->isPriorityLane(); });
    return it != lanes.end() ? it->get() : nullptr;
}

bool TrafficManager::isNearIntersection(const VehicleState& state) const {
    float dx = state.pos.x - SimConstants::CENTER_X;
    float dy = state.pos.y - SimConstants::CENTER_Y;
    float distance = std::sqrt(dx * dx + dy * dy);
    return distance < SimConstants::ROAD_WIDTH * 0.75f;
}


bool TrafficManager::isInIntersection(const Position& pos) const {
    using namespace SimConstants;
    float dx = pos.x - CENTER_X;
    float dy = pos.y - CENTER_Y;
    return std::sqrt(dx * dx + dy * dy) < ROAD_WIDTH/2.0f;
}


// TrafficManager.cpp continuation


void TrafficManager::updateVehiclePositions(float deltaTime) {
    for (auto& [_, state] : activeVehicles) {
        if (!state.isMoving && canVehicleMove(state)) {
            state.isMoving = true;
            if (state.direction != Direction::STRAIGHT) {
                calculateTurnPath(state);
            }
        }

        if (state.isMoving) {
            float dx = state.targetPos.x - state.pos.x;
            float dy = state.targetPos.y - state.pos.y;
            float distance = std::sqrt(dx * dx + dy * dy);

            if (distance > 0.1f) {
                // Calculate speed and movement
                float speedFactor = 1.0f;
                if (isInIntersection(state.pos)) {
                    speedFactor = 1.2f; // Faster through intersection
                } else {
                    float distToIntersection = std::abs(distance - SimConstants::ROAD_WIDTH);
                    if (distToIntersection < SimConstants::ROAD_WIDTH) {
                        speedFactor = 0.7f + (distToIntersection / SimConstants::ROAD_WIDTH) * 0.3f;
                    }
                }

                float currentSpeed = state.speed * speedFactor * deltaTime;
                float moveX = state.pos.x + (dx / distance) * currentSpeed;
                float moveY = state.pos.y + (dy / distance) * currentSpeed;

                // Check for collision before moving
                if (!checkCollision(state, moveX, moveY)) {
                    state.pos.x = moveX;
                    state.pos.y = moveY;
                    state.turnAngle = std::atan2(dy, dx);
                } else {
                    state.speed *= 0.5f; // Slow down when near collision
                }
            }
        }
    }

    // Clean up vehicles that have reached their destination
    cleanupRemovedVehicles();
}


void TrafficManager::updateStraightMovement(VehicleState& state, float deltaTime) {
    if (!state.isMoving) return;

    float dx = state.targetPos.x - state.pos.x;
    float dy = state.targetPos.y - state.pos.y;
    float distance = std::sqrt(dx * dx + dy * dy);

    if (distance > 0.1f) {
        float moveSpeed = state.speed * deltaTime;
        float moveRatio = std::min(1.0f, moveSpeed / distance);

        float newX = state.pos.x + dx * moveRatio;
        float newY = state.pos.y + dy * moveRatio;

        if (!checkCollision(state, newX, newY)) {
            state.pos.x = newX;
            state.pos.y = newY;
            state.turnAngle = std::atan2(dy, dx);
        } else {
            state.speed *= 0.5f; // Slow down when near collision
        }
    }
}


void TrafficManager::updateTurningMovement(VehicleState& state, float deltaTime) {
    if (!state.hasStartedTurn && isNearIntersection(state)) {
        state.hasStartedTurn = true;
        state.turnProgress = 0.0f;
        state.speed = SimConstants::VEHICLE_TURN_SPEED;
    }

    if (state.hasStartedTurn) {
        // Smooth turn progression
        float progressDelta = deltaTime * (1.0f - state.turnProgress * 0.5f);
        state.turnProgress = std::min(1.0f, state.turnProgress + progressDelta);

        // Use cubic easing for smoother turns
        float easedProgress = state.turnProgress * state.turnProgress * (3.0f - 2.0f * state.turnProgress);
        float currentAngle = state.startAngle + (state.endAngle - state.startAngle) * easedProgress;

        // Calculate new position along turn arc
        float newX = state.turnCenter.x + state.turnRadius * std::cos(currentAngle);
        float newY = state.turnCenter.y + state.turnRadius * std::sin(currentAngle);

        // Look ahead for collisions
        bool willCollide = false;
        const int LOOK_AHEAD_STEPS = 5;
        for (int i = 1; i <= LOOK_AHEAD_STEPS; i++) {
            float futureProgress = std::min(1.0f, state.turnProgress + progressDelta * i);
            float futureAngle = state.startAngle + (state.endAngle - state.startAngle) * futureProgress;
            float futureX = state.turnCenter.x + state.turnRadius * std::cos(futureAngle);
            float futureY = state.turnCenter.y + state.turnRadius * std::sin(futureAngle);

            if (checkCollision(state, futureX, futureY)) {
                willCollide = true;
                break;
            }
        }

        if (!willCollide && !checkCollision(state, newX, newY)) {
            state.pos.x = newX;
            state.pos.y = newY;
            state.turnAngle = currentAngle;
            state.inIntersection = true;
        } else {
            state.speed *= 0.8f; // Slow down if collision likely
        }
    } else {
        updateStraightMovement(state, deltaTime);
    }
}



bool TrafficManager::checkCollision(const VehicleState& state, float newX, float newY) const {
    using namespace SimConstants;

    const float MIN_DISTANCE = VEHICLE_WIDTH * 1.5f;

    for (const auto& [otherId, otherState] : activeVehicles) {
        if (otherId != state.vehicle->getId()) {
            float dx = newX - otherState.pos.x;
            float dy = newY - otherState.pos.y;
            float distance = std::sqrt(dx * dx + dy * dy);

            if (distance < MIN_DISTANCE) {
                return true;
            }
        }
    }
    return false;
}





void TrafficManager::addNewVehicleToState(std::shared_ptr<Vehicle> vehicle, LaneId laneId) {
    using namespace SimConstants;

    VehicleState state;
    state.vehicle = vehicle;
    state.speed = VEHICLE_BASE_SPEED;
    state.isMoving = false;
    state.direction = vehicle->getDirection();
    state.hasStartedTurn = false;
    state.turnProgress = 0.0f;
    state.waitTime = 0.0f;
    state.processingTime = 0.0f;
    state.inIntersection = false;
    state.isPassing = false;

    // Calculate lane offset from center (important for preventing collisions)
    float laneOffset = 0.0f;
    int lanePosition = static_cast<int>(laneId) % 3;

    // Proper lane spacing to prevent collisions
    if (lanePosition == 0) {  // Left lane
        laneOffset = -LANE_WIDTH;
    } else if (lanePosition == 1) {  // Middle lane
        laneOffset = 0.0f;
    } else {  // Right lane
        laneOffset = LANE_WIDTH;
    }

    // Calculate initial positions based on road
    int roadNum = static_cast<int>(laneId) / 3;
    switch(roadNum) {
        case 0: // West approach (A lanes)
            state.pos.x = -VEHICLE_WIDTH * 2;
            state.pos.y = CENTER_Y + laneOffset;
            state.turnAngle = 0.0f;
            break;

        case 1: // North approach (B lanes)
            state.pos.x = CENTER_X + laneOffset;
            state.pos.y = -VEHICLE_HEIGHT * 2;
            state.turnAngle = M_PI/2;
            break;

        case 2: // East approach (C lanes)
            state.pos.x = WINDOW_WIDTH + VEHICLE_WIDTH * 2;
            state.pos.y = CENTER_Y - laneOffset; // Note negative offset
            state.turnAngle = M_PI;
            break;

        case 3: // South approach (D lanes)
            state.pos.x = CENTER_X - laneOffset; // Note negative offset
            state.pos.y = WINDOW_HEIGHT + VEHICLE_HEIGHT * 2;
            state.turnAngle = -M_PI/2;
            break;
    }

    // Calculate target position based on direction

calculateTargetPosition(state, laneId);


    // Add queue offset for multiple vehicles
    size_t queuePosition = getLaneSize(laneId);
    float queueOffset = queuePosition * (VEHICLE_LENGTH + MIN_VEHICLE_SPACING);

    // Apply queue offset based on approach direction
    switch(roadNum) {
        case 0: state.pos.x -= queueOffset; break;
        case 1: state.pos.y -= queueOffset; break;
        case 2: state.pos.x += queueOffset; break;
        case 3: state.pos.y += queueOffset; break;
    }

    activeVehicles[vehicle->getId()] = state;
}// TrafficManager.cpp continuation



void TrafficManager::calculateTurnParameters(VehicleState& state) {
    using namespace SimConstants;

    // Get the quadrant (0-3 for W,N,E,S)
    int quadrant = static_cast<int>(state.vehicle->getCurrentLane()) / 3;

    // Calculate turn center and angles
    switch (quadrant) {
        case 0: // From West
            state.turnCenter.x = CENTER_X - ROAD_WIDTH/4;
            state.turnCenter.y = CENTER_Y;
            state.startAngle = 0.0f;
            state.endAngle = -M_PI/2;  // For right turns
            break;
        case 1: // From North
            state.turnCenter.x = CENTER_X;
            state.turnCenter.y = CENTER_Y - ROAD_WIDTH/4;
            state.startAngle = M_PI/2;
            state.endAngle = 0.0f;  // For right turns
            break;
        case 2: // From East
            state.turnCenter.x = CENTER_X + ROAD_WIDTH/4;
            state.turnCenter.y = CENTER_Y;
            state.startAngle = M_PI;
            state.endAngle = M_PI/2;  // For right turns
            break;
        case 3: // From South
            state.turnCenter.x = CENTER_X;
            state.turnCenter.y = CENTER_Y + ROAD_WIDTH/4;
            state.startAngle = -M_PI/2;
            state.endAngle = M_PI;  // For right turns
            break;
    }
}

void TrafficManager::updateTrafficLights(float deltaTime) {
    // Update each light's state
    for (auto& [_, light] : trafficLights) {
        light.update(deltaTime);
    }

    if (inPriorityMode) {
        // Priority mode: AL2 gets green, others red
        trafficLights[LaneId::AL2_PRIORITY].setState(LightState::GREEN);
        trafficLights[LaneId::BL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(LightState::RED);
    } else {
        // Normal mode: Alternate between N-S and E-W traffic
        float cycleTime = 10.0f;
        bool northSouthGreen = std::fmod(stateTimer, cycleTime * 2) < cycleTime;

        trafficLights[LaneId::BL2_NORMAL].setState(northSouthGreen ? LightState::GREEN : LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(northSouthGreen ? LightState::GREEN : LightState::RED);
        trafficLights[LaneId::AL2_PRIORITY].setState(northSouthGreen ? LightState::RED : LightState::GREEN);
        trafficLights[LaneId::CL2_NORMAL].setState(northSouthGreen ? LightState::RED : LightState::GREEN);
    }
}

void TrafficManager::synchronizeTrafficLights() {
    if (inPriorityMode) {
        trafficLights[LaneId::AL2_PRIORITY].setState(LightState::GREEN);
        trafficLights[LaneId::BL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(LightState::RED);
    } else {
        // Start with North-South flow
        trafficLights[LaneId::AL2_PRIORITY].setState(LightState::RED);
        trafficLights[LaneId::BL2_NORMAL].setState(LightState::GREEN);
        trafficLights[LaneId::CL2_NORMAL].setState(LightState::RED);
        trafficLights[LaneId::DL2_NORMAL].setState(LightState::GREEN);
    }
}

void TrafficManager::handleStateTransition(float deltaTime) {
    bool shouldBePriority = checkPriorityConditions();

    if (shouldBePriority && !inPriorityMode) {
        if (stateTimer >= MIN_STATE_TIME) {
            inPriorityMode = true;
            stateTimer = 0.0f;
            synchronizeTrafficLights();
        }
    } else if (!shouldBePriority && inPriorityMode) {
        auto* priorityLane = getPriorityLane();
        if (priorityLane && priorityLane->getQueueSize() <= PRIORITY_RELEASE_THRESHOLD &&
            stateTimer >= MIN_STATE_TIME) {
            inPriorityMode = false;
            stateTimer = 0.0f;
            synchronizeTrafficLights();
        }
    }

    // Force state change if stuck too long
    if (stateTimer >= MAX_STATE_TIME) {
        inPriorityMode = !inPriorityMode;
        stateTimer = 0.0f;
        synchronizeTrafficLights();
    }
}



void TrafficManager::processNewVehicles() {
    auto newVehicles = fileHandler.readNewVehicles();

    for (const auto& [laneId, vehicle] : newVehicles) {
        std::cout << "Processing new vehicle " << vehicle->getId()
                 << " for lane " << static_cast<int>(laneId) << std::endl;

        LaneId optimalLane = determineOptimalLane(vehicle->getDirection(), laneId);

        if (isValidSpawnLane(optimalLane, vehicle->getDirection())) {
            // First add to lane queue
            addVehicleToLane(optimalLane, vehicle);

            // Then initialize vehicle state
            addNewVehicleToState(vehicle, optimalLane);

            std::cout << "Vehicle " << vehicle->getId()
                     << " added to lane " << static_cast<int>(optimalLane) << std::endl;
        } else {
            std::cout << "Invalid spawn configuration for vehicle "
                     << vehicle->getId() << std::endl;
        }
    }
}

LaneId TrafficManager::determineOptimalLane(Direction direction, LaneId sourceLane) const {
    int roadGroup = static_cast<int>(sourceLane) / 3;

    switch (direction) {
        case Direction::LEFT:
            return static_cast<LaneId>(roadGroup * 3 + 2); // Third lane for left turns

        case Direction::RIGHT:
            return static_cast<LaneId>(roadGroup * 3); // First lane for right turns

        case Direction::STRAIGHT: {
            // Use less congested lane between first and second
            LaneId lane1 = static_cast<LaneId>(roadGroup * 3);
            LaneId lane2 = static_cast<LaneId>(roadGroup * 3 + 1);
            return (getLaneSize(lane1) <= getLaneSize(lane2)) ? lane1 : lane2;
        }

        default:
            return sourceLane;
    }
}

bool TrafficManager::isValidSpawnLane(LaneId laneId, Direction direction) const {
    int laneInRoad = static_cast<int>(laneId) % 3;

    switch (direction) {
        case Direction::LEFT:
            return laneInRoad == 2; // Third lane only
        case Direction::RIGHT:
            return laneInRoad == 0; // First lane only
        case Direction::STRAIGHT:
            return laneInRoad == 0 || laneInRoad == 1; // First or second lane
        default:
            return false;
    }
}

void TrafficManager::processPriorityLane() {
    auto* priorityLane = getPriorityLane();
    if (!priorityLane) return;

    while (priorityLane->getQueueSize() > PRIORITY_RELEASE_THRESHOLD) {
        auto vehicle = priorityLane->removeVehicle();
        if (vehicle) {
            auto it = activeVehicles.find(vehicle->getId());
            if (it != activeVehicles.end()) {
                it->second.isMoving = true;
            }
        }
    }
}


// TrafficManager.cpp final part

void TrafficManager::processNormalLanes(size_t vehicleCount) {
    if (vehicleCount == 0) return;

    for (auto& lane : lanes) {
        if (!lane->isPriorityLane() && !isFreeLane(lane->getId())) {
            for (size_t i = 0; i < vehicleCount && lane->getQueueSize() > 0; ++i) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    auto it = activeVehicles.find(vehicle->getId());
                    if (it != activeVehicles.end()) {
                        it->second.isMoving = true;
                    }
                }
            }
        }
    }
}

void TrafficManager::processFreeLanes() {
    for (auto& lane : lanes) {
        if (isFreeLane(lane->getId())) {
            while (lane->getQueueSize() > 0) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    auto it = activeVehicles.find(vehicle->getId());
                    if (it != activeVehicles.end()) {
                        it->second.isMoving = true;
                    }
                }
            }
        }
    }
}

size_t TrafficManager::calculateVehiclesToProcess() const {
    size_t totalVehicles = 0;
    size_t normalLaneCount = 0;

    for (const auto& lane : lanes) {
        if (!lane->isPriorityLane() && !isFreeLane(lane->getId())) {
            totalVehicles += lane->getQueueSize();
            normalLaneCount++;
        }
    }

    return normalLaneCount > 0 ?
        static_cast<size_t>(std::ceil(static_cast<float>(totalVehicles) / normalLaneCount)) : 0;
}

void TrafficManager::checkWaitTimes() {
    using namespace SimConstants;

    for (auto& lane : lanes) {
        if (lane->getQueueSize() > 0 && !isFreeLane(lane->getId())) {
            bool needsProcessing = false;

            // Get the first vehicle's wait time
            auto firstVehicleIt = std::find_if(activeVehicles.begin(), activeVehicles.end(),
                [&lane](const auto& pair) {
                    return pair.second.vehicle->getCurrentLane() == lane->getId() &&
                           !pair.second.isMoving;
                });

            if (firstVehicleIt != activeVehicles.end()) {
                if (firstVehicleIt->second.waitTime > MAX_WAIT_TIME) {
                    needsProcessing = true;
                }
            }

            if (needsProcessing || lane->getQueueSize() >= 8) {
                auto vehicle = lane->removeVehicle();
                if (vehicle) {
                    auto it = activeVehicles.find(vehicle->getId());
                    if (it != activeVehicles.end()) {
                        it->second.isMoving = true;
                    }
                }
            }
        }
    }
}

void TrafficManager::updateTimers(float deltaTime) {
    stateTimer += deltaTime;
    processingTimer += deltaTime;
    lastUpdateTime += deltaTime;

    // Update wait times for vehicles
    for (auto& [_, state] : activeVehicles) {
        if (!state.isMoving) {
            state.waitTime += deltaTime;
        }
    }
}

void TrafficManager::updateStatistics(float deltaTime) {
    // Update average wait time
    float totalWaitTime = 0.0f;
    size_t waitingVehicles = 0;

    for (const auto& [_, state] : activeVehicles) {
        if (!state.isMoving) {
            totalWaitTime += state.waitTime;
            waitingVehicles++;
        }
    }

    if (waitingVehicles > 0) {
        averageWaitTime = totalWaitTime / static_cast<float>(waitingVehicles);
    }
}

float TrafficManager::calculateAverageWaitTime() const {
    float totalWaitTime = 0.0f;
    size_t vehicleCount = 0;

    for (const auto& [_, state] : activeVehicles) {
        if (!state.isMoving) {
            totalWaitTime += state.waitTime;
            vehicleCount++;
        }
    }

    return vehicleCount > 0 ? totalWaitTime / static_cast<float>(vehicleCount) : 0.0f;
}

size_t TrafficManager::getQueuedVehicleCount() const {
    size_t count = 0;
    for (const auto& lane : lanes) {
        count += lane->getQueueSize();
    }
    return count;
}

void TrafficManager::cleanupRemovedVehicles() {
    auto it = activeVehicles.begin();
    while (it != activeVehicles.end()) {
        if (hasReachedDestination(it->second)) {
            it = activeVehicles.erase(it);
        } else {
            ++it;
        }
    }
}

bool TrafficManager::checkPriorityConditions() const {
    auto* priorityLane = getPriorityLane();
    if (!priorityLane) return false;

    return priorityLane->getQueueSize() > PRIORITY_THRESHOLD;
}

float TrafficManager::calculateTurningRadius(Direction dir) const {
    using namespace SimConstants;
    switch (dir) {
        case Direction::LEFT:
            return TURN_GUIDE_RADIUS * 1.2f;  // Wider radius for left turns
        case Direction::RIGHT:
            return TURN_GUIDE_RADIUS * 0.8f;  // Tighter radius for right turns
        default:
            return TURN_GUIDE_RADIUS;
    }
}

Position TrafficManager::calculateLaneEndpoint(LaneId laneId) const {
    using namespace SimConstants;
    const float EXIT_DISTANCE = QUEUE_START_OFFSET * 1.5f;

    float laneOffset = static_cast<float>((static_cast<int>(laneId) % 3)) * LANE_WIDTH;
    float baseY = CENTER_Y - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;

    switch (laneId) {
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE:
            return Position(CENTER_X + EXIT_DISTANCE, baseY);

        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE:
            return Position(CENTER_X - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset,
                          CENTER_Y + EXIT_DISTANCE);

        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE:
            return Position(CENTER_X - EXIT_DISTANCE, baseY);

        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE:
            return Position(CENTER_X - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset,
                          CENTER_Y - EXIT_DISTANCE);

        default:
            return Position(CENTER_X, CENTER_Y);
    }
}

bool TrafficManager::hasReachedDestination(const VehicleState& state) const {
    float dx = state.pos.x - state.targetPos.x;
    float dy = state.pos.y - state.targetPos.y;
    return std::sqrt(dx * dx + dy * dy) < 1.0f;
}



void TrafficManager::calculateTurnPath(VehicleState& state) {
    using namespace SimConstants;
    float turnOffset = ROAD_WIDTH * 0.25f;
    state.turnRadius = calculateTurningRadius(state.direction);

    LaneId laneId = state.vehicle->getCurrentLane();
    bool isLeftTurn = state.direction == Direction::LEFT;

    // Set turn center based on lane and turn direction
    switch (laneId) {
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE:
            state.turnCenter.x = CENTER_X - ROAD_WIDTH/2.0f + turnOffset;
            state.turnCenter.y = isLeftTurn ?
                CENTER_Y - ROAD_WIDTH/2.0f - turnOffset :
                CENTER_Y + ROAD_WIDTH/2.0f + turnOffset;
            state.startAngle = 0.0f;
            state.endAngle = isLeftTurn ? -M_PI/2.0f : M_PI/2.0f;
            break;

        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE:
            state.turnCenter.x = isLeftTurn ?
                CENTER_X + ROAD_WIDTH/2.0f + turnOffset :
                CENTER_X - ROAD_WIDTH/2.0f - turnOffset;
            state.turnCenter.y = CENTER_Y - ROAD_WIDTH/2.0f + turnOffset;
            state.startAngle = M_PI/2.0f;
            state.endAngle = isLeftTurn ? 0.0f : M_PI;
            break;

        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE:
            state.turnCenter.x = CENTER_X + ROAD_WIDTH/2.0f - turnOffset;
            state.turnCenter.y = isLeftTurn ?
                CENTER_Y + ROAD_WIDTH/2.0f + turnOffset :
                CENTER_Y - ROAD_WIDTH/2.0f - turnOffset;
            state.startAngle = M_PI;
            state.endAngle = isLeftTurn ? M_PI/2.0f : -M_PI/2.0f;
            break;

        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE:
            state.turnCenter.x = isLeftTurn ?
                CENTER_X - ROAD_WIDTH/2.0f - turnOffset :
                CENTER_X + ROAD_WIDTH/2.0f + turnOffset;
            state.turnCenter.y = CENTER_Y + ROAD_WIDTH/2.0f - turnOffset;
            state.startAngle = -M_PI/2.0f;
            state.endAngle = isLeftTurn ? M_PI : 0.0f;
            break;
    }
}

// Add these implementations to TrafficManager.cpp

void TrafficManager::updateVehicleQueuePosition(VehicleState& state, LaneId laneId, size_t queuePosition) {
    using namespace SimConstants;

    float laneOffset = static_cast<float>((static_cast<int>(laneId) % 3)) * LANE_WIDTH;
    float queueOffset = QUEUE_START_OFFSET + (queuePosition * QUEUE_SPACING);

    // Calculate target position based on lane
    switch (laneId) {
        case LaneId::AL1_INCOMING:
        case LaneId::AL2_PRIORITY:
        case LaneId::AL3_FREELANE: {
            state.pos.x = CENTER_X - queueOffset;
            state.pos.y = CENTER_Y - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            state.turnAngle = 0.0f;
            break;
        }
        case LaneId::BL1_INCOMING:
        case LaneId::BL2_NORMAL:
        case LaneId::BL3_FREELANE: {
            state.pos.x = CENTER_X - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            state.pos.y = CENTER_Y - queueOffset;
            state.turnAngle = static_cast<float>(M_PI) / 2.0f;
            break;
        }
        case LaneId::CL1_INCOMING:
        case LaneId::CL2_NORMAL:
        case LaneId::CL3_FREELANE: {
            state.pos.x = CENTER_X + queueOffset;
            state.pos.y = CENTER_Y - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            state.turnAngle = static_cast<float>(M_PI);
            break;
        }
        case LaneId::DL1_INCOMING:
        case LaneId::DL2_NORMAL:
        case LaneId::DL3_FREELANE: {
            state.pos.x = CENTER_X - ROAD_WIDTH/2.0f + LANE_WIDTH/2.0f + laneOffset;
            state.pos.y = CENTER_Y + queueOffset;
            state.turnAngle = -static_cast<float>(M_PI) / 2.0f;
            break;
        }
    }
}



void TrafficManager::calculateTargetPosition(VehicleState& state, LaneId laneId) {
    using namespace SimConstants;

    // Get road number (0-3) and lane position (0-2)
    int roadNum = static_cast<int>(laneId) / 3;
    int lanePosition = static_cast<int>(laneId) % 3;

    if (state.direction == Direction::STRAIGHT) {
        switch(roadNum) {
            case 0: // West to East
                state.targetPos.x = WINDOW_WIDTH + VEHICLE_WIDTH;
                state.targetPos.y = CENTER_Y + (lanePosition - 1) * LANE_WIDTH;
                break;
            case 1: // North to South
                state.targetPos.x = CENTER_X + (lanePosition - 1) * LANE_WIDTH;
                state.targetPos.y = WINDOW_HEIGHT + VEHICLE_HEIGHT;
                break;
            case 2: // East to West
                state.targetPos.x = -VEHICLE_WIDTH;
                state.targetPos.y = CENTER_Y + (1 - lanePosition) * LANE_WIDTH;
                break;
            case 3: // South to North
                state.targetPos.x = CENTER_X + (1 - lanePosition) * LANE_WIDTH;
                state.targetPos.y = -VEHICLE_HEIGHT;
                break;
        }
    }
    else if (state.direction == Direction::RIGHT) {
        switch(roadNum) {
            case 0: // West to North
                state.targetPos.x = CENTER_X + LANE_WIDTH;
                state.targetPos.y = -VEHICLE_HEIGHT;
                break;
            case 1: // North to East
                state.targetPos.x = WINDOW_WIDTH + VEHICLE_WIDTH;
                state.targetPos.y = CENTER_Y - LANE_WIDTH;
                break;
            case 2: // East to South
                state.targetPos.x = CENTER_X - LANE_WIDTH;
                state.targetPos.y = WINDOW_HEIGHT + VEHICLE_HEIGHT;
                break;
            case 3: // South to West
                state.targetPos.x = -VEHICLE_WIDTH;
                state.targetPos.y = CENTER_Y + LANE_WIDTH;
                break;
        }
        state.turnRadius = ROAD_WIDTH * 0.75f;
    }
}
LaneId TrafficManager::determineTargetLane(LaneId currentLane, Direction direction) const {
    // Return appropriate target lane based on current lane and intended direction
    switch(direction) {
        case Direction::LEFT:
            // Third lane only for left turns
            switch(currentLane) {
                case LaneId::AL3_FREELANE: return LaneId::BL3_FREELANE;
                case LaneId::BL3_FREELANE: return LaneId::CL3_FREELANE;
                case LaneId::CL3_FREELANE: return LaneId::DL3_FREELANE;
                case LaneId::DL3_FREELANE: return LaneId::AL3_FREELANE;
                default: return currentLane; // Should not happen
            }

        case Direction::RIGHT:
            // First lane only for right turns
            switch(currentLane) {
                case LaneId::AL1_INCOMING: return LaneId::DL1_INCOMING;
                case LaneId::BL1_INCOMING: return LaneId::AL1_INCOMING;
                case LaneId::CL1_INCOMING: return LaneId::BL1_INCOMING;
                case LaneId::DL1_INCOMING: return LaneId::CL1_INCOMING;
                default: return currentLane;
            }

        default: // STRAIGHT
            // Can use first or second lane
            return currentLane;
    }
}


void TrafficManager::changeLaneToFree(VehicleState& state) {
    // Logic to smoothly change to free lane for left turns
    float targetLaneY = state.pos.y;
    if (state.pos.x < SimConstants::CENTER_X) targetLaneY += SimConstants::LANE_WIDTH;
    else targetLaneY -= SimConstants::LANE_WIDTH;

    state.intermediateTargets.push_back({state.pos.x, targetLaneY});
}

void TrafficManager::changeLaneToFirst(VehicleState& state) {
    // Logic to smoothly change to first lane for right turns
    float targetLaneY = state.pos.y;
    if (state.pos.x < SimConstants::CENTER_X) targetLaneY -= SimConstants::LANE_WIDTH;
    else targetLaneY += SimConstants::LANE_WIDTH;

    state.intermediateTargets.push_back({state.pos.x, targetLaneY});
}



bool TrafficManager::canVehicleMove(const VehicleState& state) const {
    using namespace SimConstants;  // Add this for constant access

    // Check traffic light state
    auto lightIt = trafficLights.find(state.vehicle->getCurrentLane());
    if (lightIt != trafficLights.end() && lightIt->second.getState() == LightState::RED
        && !state.inIntersection) {
        // Handle red light stop
        float distToIntersection = getDistanceToIntersection(state);
        if (distToIntersection < STOP_LINE_OFFSET) {
            return false;
        }
    }

    return !hasVehicleAhead(state);
}

LightState TrafficManager::getLightStateForLane(LaneId laneId) const {
    auto it = trafficLights.find(laneId);
    return it != trafficLights.end() ? it->second.getState() : LightState::RED;
}

float TrafficManager::getDistanceToIntersection(const VehicleState& state) const {
    using namespace SimConstants;

    float dx = CENTER_X - state.pos.x;
    float dy = CENTER_Y - state.pos.y;
    return std::sqrt(dx * dx + dy * dy) - INTERSECTION_RADIUS;
}

bool TrafficManager::hasVehicleAhead(const VehicleState& state) const {
    for (const auto& [_, otherState] : activeVehicles) {
        if (state.vehicle->getId() != otherState.vehicle->getId() &&
            state.vehicle->getCurrentLane() == otherState.vehicle->getCurrentLane()) {

            float dx = otherState.pos.x - state.pos.x;
            float dy = otherState.pos.y - state.pos.y;
            float distance = std::sqrt(dx * dx + dy * dy);

            if (distance < SimConstants::VEHICLE_MIN_SPACING &&
                isVehicleAhead(state, otherState)) {
                return true;
            }
        }
    }
    return false;
}

bool TrafficManager::isVehicleAhead(const VehicleState& first,
                                  const VehicleState& second) const {
    // Determine if second vehicle is ahead of first based on road direction
    LaneId laneId = first.vehicle->getCurrentLane();

    if (laneId <= LaneId::AL3_FREELANE) {
        return second.pos.x > first.pos.x;
    } else if (laneId <= LaneId::BL3_FREELANE) {
        return second.pos.y > first.pos.y;
    } else if (laneId <= LaneId::CL3_FREELANE) {
        return second.pos.x < first.pos.x;
    } else {
        return second.pos.y < first.pos.y;
    }
}


void TrafficManager::calculateLeftTurnPath(VehicleState& state) {
    using namespace SimConstants;

    // Calculate larger radius for left turns
    state.turnRadius = TURN_GUIDE_RADIUS * 1.2f;

    // Calculate turn center and angles based on approach direction
    LaneId laneId = state.vehicle->getCurrentLane();

    if (laneId <= LaneId::AL3_FREELANE) {  // Coming from West
        // Turn center will be north-west of intersection
        state.turnCenter.x = CENTER_X - ROAD_WIDTH/2.0f;
        state.turnCenter.y = CENTER_Y - ROAD_WIDTH/2.0f;
        state.startAngle = 0.0f;  // Start facing east
        state.endAngle = -M_PI/2.0f;  // End facing north
        state.targetPos.x = CENTER_X;
        state.targetPos.y = -VEHICLE_HEIGHT;  // Exit north
    }
    else if (laneId <= LaneId::BL3_FREELANE) {  // Coming from North
        // Turn center will be north-east of intersection
        state.turnCenter.x = CENTER_X + ROAD_WIDTH/2.0f;
        state.turnCenter.y = CENTER_Y - ROAD_WIDTH/2.0f;
        state.startAngle = M_PI/2.0f;  // Start facing south
        state.endAngle = 0.0f;  // End facing east
        state.targetPos.x = WINDOW_WIDTH + VEHICLE_WIDTH;  // Exit east
        state.targetPos.y = CENTER_Y;
    }
    else if (laneId <= LaneId::CL3_FREELANE) {  // Coming from East
        // Turn center will be south-east of intersection
        state.turnCenter.x = CENTER_X + ROAD_WIDTH/2.0f;
        state.turnCenter.y = CENTER_Y + ROAD_WIDTH/2.0f;
        state.startAngle = M_PI;  // Start facing west
        state.endAngle = M_PI/2.0f;  // End facing south
        state.targetPos.x = CENTER_X;
        state.targetPos.y = WINDOW_HEIGHT + VEHICLE_HEIGHT;  // Exit south
    }
    else {  // Coming from South
        // Turn center will be south-west of intersection
        state.turnCenter.x = CENTER_X - ROAD_WIDTH/2.0f;
        state.turnCenter.y = CENTER_Y + ROAD_WIDTH/2.0f;
        state.startAngle = -M_PI/2.0f;  // Start facing north
        state.endAngle = M_PI;  // End facing west
        state.targetPos.x = -VEHICLE_WIDTH;  // Exit west
        state.targetPos.y = CENTER_Y;
    }

    // Adjust speed for turning
    state.speed = VEHICLE_TURN_SPEED;
    state.turnProgress = 0.0f;
    state.hasStartedTurn = true;
}

void TrafficManager::calculateRightTurnPath(VehicleState& state) {
    using namespace SimConstants;

    // Calculate smaller radius for right turns
    state.turnRadius = TURN_GUIDE_RADIUS * 0.8f;

    // Calculate turn center and angles based on approach direction
    LaneId laneId = state.vehicle->getCurrentLane();

    if (laneId <= LaneId::AL3_FREELANE) {  // Coming from West
        // Turn center will be south-west of intersection
        state.turnCenter.x = CENTER_X - ROAD_WIDTH/2.0f;
        state.turnCenter.y = CENTER_Y + ROAD_WIDTH/2.0f;
        state.startAngle = 0.0f;  // Start facing east
        state.endAngle = M_PI/2.0f;  // End facing south
        state.targetPos.x = CENTER_X;
        state.targetPos.y = WINDOW_HEIGHT + VEHICLE_HEIGHT;  // Exit south
    }
    else if (laneId <= LaneId::BL3_FREELANE) {  // Coming from North
        // Turn center will be north-west of intersection
        state.turnCenter.x = CENTER_X - ROAD_WIDTH/2.0f;
        state.turnCenter.y = CENTER_Y - ROAD_WIDTH/2.0f;
        state.startAngle = M_PI/2.0f;  // Start facing south
        state.endAngle = M_PI;  // End facing west
        state.targetPos.x = -VEHICLE_WIDTH;  // Exit west
        state.targetPos.y = CENTER_Y;
    }
    else if (laneId <= LaneId::CL3_FREELANE) {  // Coming from East
        // Turn center will be north-east of intersection
        state.turnCenter.x = CENTER_X + ROAD_WIDTH/2.0f;
        state.turnCenter.y = CENTER_Y - ROAD_WIDTH/2.0f;
        state.startAngle = M_PI;  // Start facing west
        state.endAngle = -M_PI/2.0f;  // End facing north
        state.targetPos.x = CENTER_X;
        state.targetPos.y = -VEHICLE_HEIGHT;  // Exit north
    }
    else {  // Coming from South
        // Turn center will be south-east of intersection
        state.turnCenter.x = CENTER_X + ROAD_WIDTH/2.0f;
        state.turnCenter.y = CENTER_Y + ROAD_WIDTH/2.0f;
        state.startAngle = -M_PI/2.0f;  // Start facing north
        state.endAngle = 0.0f;  // End facing east
        state.targetPos.x = WINDOW_WIDTH + VEHICLE_WIDTH;  // Exit east
        state.targetPos.y = CENTER_Y;
    }

    // Adjust speed for turning
    state.speed = VEHICLE_TURN_SPEED;
    state.turnProgress = 0.0f;
    state.hasStartedTurn = true;
}


================================================================================
File: src\utils\Queue.cpp
================================================================================

// include/utils/Queue.hpp
#pragma once
#include <memory>
#include <stdexcept>

template<typename T>
class Queue {
protected:
    struct Node {
        T data;
        std::shared_ptr<Node> next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::shared_ptr<Node> front;
    std::shared_ptr<Node> rear;
    size_t size;

public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}

    virtual ~Queue() = default;

    void enqueue(const T& value) {
        auto newNode = std::make_shared<Node>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    T dequeue() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }

        T value = front->data;
        front = front->next;
        size--;

        if (isEmpty()) {
            rear = nullptr;
        }

        return value;
    }

    bool isEmpty() const {
        return front == nullptr;
    }

    size_t getSize() const {
        return size;
    }

    T peek() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return front->data;
    }
};


================================================================================
File: src\utils\vector2d.h
================================================================================



================================================================================
File: src\visualization\DebugOverlay.cpp
================================================================================

// src/visualization/DebugOverlay.cpp
#include <cmath>
#include "visualization/DebugOverlay.h"

void DebugOverlay::render(SDL_Renderer* renderer, const TrafficManager& trafficManager) {
    // Draw background for debug panel
    SDL_FRect debugPanel = {10.0f, 10.0f, 200.0f, 300.0f};
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200);
    SDL_RenderFillRect(renderer, &debugPanel);

    // Priority mode indicator
    if (trafficManager.isInPriorityMode()) {
        SDL_FRect priorityIndicator = {20.0f, 20.0f, 20.0f, 20.0f};
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        SDL_RenderFillRect(renderer, &priorityIndicator);
    }

    // Queue lengths visualization
    int yOffset = 50;
    for (const auto& lane : trafficManager.getLanes()) {
        SDL_FRect queueBar = {
            20.0f,
            static_cast<float>(yOffset),
            static_cast<float>(lane->getQueueSize() * 5),
            15.0f
        };

        // Color based on lane type
        if (lane->isPriorityLane()) {
            SDL_SetRenderDrawColor(renderer, 255, 100, 100, 255);
        } else if (lane->getId() == LaneId::AL3_FREELANE ||
                   lane->getId() == LaneId::BL3_FREELANE ||
                   lane->getId() == LaneId::CL3_FREELANE ||
                   lane->getId() == LaneId::DL3_FREELANE) {
            SDL_SetRenderDrawColor(renderer, 100, 255, 100, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 100, 150, 255, 255);
        }

        SDL_RenderFillRect(renderer, &queueBar);
        yOffset += 20;
    }
}

void DebugOverlay::updateStatistics(const TrafficManager& trafficManager) {
    for (const auto& lane : trafficManager.getLanes()) {
        LaneStatistics& laneStat = stats[lane->getId()];
        laneStat.vehicleCount = static_cast<int>(lane->getQueueSize());
    }
}

void DebugOverlay::renderQueueStats(SDL_Renderer* renderer, int x, int y) {
    int yOffset = y;
    for (const auto& [laneId, stat] : stats) {
        SDL_FRect bar = {
            static_cast<float>(x + 10),
            static_cast<float>(yOffset),
            static_cast<float>(stat.vehicleCount * 5),
            15.0f
        };

        if (stat.vehicleCount > 10) {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        } else if (stat.vehicleCount > 5) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        }

        SDL_RenderFillRect(renderer, &bar);
        yOffset += 20;
    }
}

void DebugOverlay::renderLaneLoadIndicator(SDL_Renderer* renderer, int x, int y) {
    const float RADIUS = 50.0f;
    const int SEGMENTS = 12;
    const float TWO_PI = static_cast<float>(2.0 * M_PI);

    for (int i = 0; i < SEGMENTS; i++) {
        float startAngle = (TWO_PI * i) / SEGMENTS;
        float endAngle = (TWO_PI * (i + 1)) / SEGMENTS;

        float startX = x + RADIUS * cosf(startAngle);
        float startY = y + RADIUS * sinf(startAngle);
        float endX = x + RADIUS * cosf(endAngle);
        float endY = y + RADIUS * sinf(endAngle);

        // Color based on load
        int laneIndex = i % 4;
        LaneId laneId = static_cast<LaneId>(laneIndex);
        int load = stats[laneId].vehicleCount;

        if (load > 10) {
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
        } else if (load > 5) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255);
        } else {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        }

        SDL_RenderLine(renderer, startX, startY, endX, endY);
    }
}

void DebugOverlay::renderSystemStatus(SDL_Renderer* renderer, int x, int y) {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    // TODO: Add text rendering for system status when needed
}


================================================================================
File: src\visualization\Renderer.cpp
================================================================================



#include "visualization/Renderer.h"
#include <iostream>
#include <cmath>
#include <cmath>
Renderer::Renderer()
    : window(nullptr)
    , renderer(nullptr)
    , debugMode(false) {
}

Renderer::~Renderer() {
    cleanup();
}

bool Renderer::initialize() {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        std::cerr << "SDL initialization failed: " << SDL_GetError() << std::endl;
        return false;
    }

    window = SDL_CreateWindow(
        "Traffic Junction Simulator",
        SimConstants::WINDOW_WIDTH,
        SimConstants::WINDOW_HEIGHT,
        SDL_WINDOW_RESIZABLE
    );

    if (!window) {
        std::cerr << "Window creation failed: " << SDL_GetError() << std::endl;
        return false;
    }

    renderer = SDL_CreateRenderer(window, nullptr);
    if (!renderer) {
        std::cerr << "Renderer creation failed: " << SDL_GetError() << std::endl;
        return false;
    }

    return true;
}

void Renderer::render(const TrafficManager& trafficManager) {
    // Clear screen with black background
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    // Core rendering
    renderBackground();
    renderRoads();
    renderLanes();
    renderIntersection();
    renderCrosswalks();
    renderStopLines();
    renderDirectionalArrows();

    // Traffic elements
    renderTrafficLights(trafficManager.getTrafficLights());
    renderVehicles(trafficManager.getActiveVehicles());

    // Priority mode indicators
    if (trafficManager.isInPriorityMode()) {
        renderPriorityLaneIndicator();
    }

    // Debug visualization
    if (debugMode) {
        if (showGrid) {
            drawDebugGrid();
        }
        renderLaneIdentifiers();
        renderVehicleCount(trafficManager);
        debugOverlay.render(renderer, trafficManager);
    }

    SDL_RenderPresent(renderer);
}


void Renderer::renderBackground() {
    // Create a gradient sky effect
    for (int y = 0; y < SimConstants::WINDOW_HEIGHT; ++y) {
        float t = static_cast<float>(y) / SimConstants::WINDOW_HEIGHT;
        uint8_t skyR = static_cast<uint8_t>(135 * (1 - t) + 30 * t);
        uint8_t skyG = static_cast<uint8_t>(206 * (1 - t) + 30 * t);
        uint8_t skyB = static_cast<uint8_t>(235 * (1 - t) + 30 * t);

        SDL_SetRenderDrawColor(renderer, skyR, skyG, skyB, 255);
        SDL_RenderLine(renderer, 0, y, SimConstants::WINDOW_WIDTH, y);
    }

    // Render grass areas with texture
    renderGrassAreas();
}

void Renderer::renderGrassAreas() {
    using namespace SimConstants;
    SDL_SetRenderDrawColor(renderer, 34, 139, 34, 255); // Base grass color

    // Define the four corner grass areas around the intersection
    SDL_FRect grassAreas[] = {
        // Top-left quadrant
        {0, 0, CENTER_X - ROAD_WIDTH/2.0f, CENTER_Y - ROAD_WIDTH/2.0f},
        // Top-right quadrant
        {CENTER_X + ROAD_WIDTH/2.0f, 0,
         static_cast<float>(WINDOW_WIDTH) - (CENTER_X + ROAD_WIDTH/2.0f),
         CENTER_Y - ROAD_WIDTH/2.0f},
        // Bottom-left quadrant
        {0, CENTER_Y + ROAD_WIDTH/2.0f,
         CENTER_X - ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_HEIGHT) - (CENTER_Y + ROAD_WIDTH/2.0f)},
        // Bottom-right quadrant
        {CENTER_X + ROAD_WIDTH/2.0f, CENTER_Y + ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_WIDTH) - (CENTER_X + ROAD_WIDTH/2.0f),
         static_cast<float>(WINDOW_HEIGHT) - (CENTER_Y + ROAD_WIDTH/2.0f)}
    };

    // Fill base grass areas
    for (const auto& area : grassAreas) {
        SDL_RenderFillRect(renderer, &area);
    }

    // Add grass texture variation using random dots
    SDL_SetRenderDrawColor(renderer, 28, 120, 28, 255);
    for (int i = 0; i < 2000; i++) {
        int x = rand() % WINDOW_WIDTH;
        int y = rand() % WINDOW_HEIGHT;

        // Check if point is in grass area (not on road)
        bool inRoad = (x > CENTER_X - ROAD_WIDTH/2 && x < CENTER_X + ROAD_WIDTH/2) ||
                     (y > CENTER_Y - ROAD_WIDTH/2 && y < CENTER_Y + ROAD_WIDTH/2);

        if (!inRoad) {
            SDL_RenderPoint(renderer, x, y);
        }
    }
}

void Renderer::renderRoads() {
    using namespace SimConstants;

    // Main road surface with asphalt texture
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);

    // Draw horizontal road
    SDL_FRect horizontalRoad = {
        0, CENTER_Y - ROAD_WIDTH/2.0f,
        static_cast<float>(WINDOW_WIDTH),
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &horizontalRoad);

    // Draw vertical road
    SDL_FRect verticalRoad = {
        CENTER_X - ROAD_WIDTH/2.0f, 0,
        static_cast<float>(ROAD_WIDTH),
        static_cast<float>(WINDOW_HEIGHT)
    };
    SDL_RenderFillRect(renderer, &verticalRoad);

    // Add road edges and curbs
    renderRoadEdges();
}

void Renderer::renderRoadEdges() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 150, 150, 150, 255);
    const float CURB_WIDTH = 4.0f;

    // Render curbs for all road edges
    SDL_FRect curbs[] = {
        // Horizontal road curbs
        {0, CENTER_Y - ROAD_WIDTH/2.0f,
         static_cast<float>(WINDOW_WIDTH), CURB_WIDTH},
        {0, CENTER_Y + ROAD_WIDTH/2.0f - CURB_WIDTH,
         static_cast<float>(WINDOW_WIDTH), CURB_WIDTH},

        // Vertical road curbs
        {CENTER_X - ROAD_WIDTH/2.0f, 0,
         CURB_WIDTH, static_cast<float>(WINDOW_HEIGHT)},
        {CENTER_X + ROAD_WIDTH/2.0f - CURB_WIDTH, 0,
         CURB_WIDTH, static_cast<float>(WINDOW_HEIGHT)}
    };

    for (const auto& curb : curbs) {
        SDL_RenderFillRect(renderer, &curb);
    }
}

void Renderer::renderLanes() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    float laneWidth = ROAD_WIDTH / 3.0f;

    // Draw horizontal lane dividers
    for (int i = 1; i < 3; i++) {
        float y = CENTER_Y - ROAD_WIDTH/2.0f + i * laneWidth;
        renderDashedLine(0, y, WINDOW_WIDTH, y);
    }

    // Draw vertical lane dividers
    for (int i = 1; i < 3; i++) {
        float x = CENTER_X - ROAD_WIDTH/2.0f + i * laneWidth;
        renderDashedLine(x, 0, x, WINDOW_HEIGHT);
    }

    // Render special lane markings
    renderPriorityLane();
}

void Renderer::renderPriorityLane() {
    using namespace SimConstants;

    // Highlight AL2 priority lane with semi-transparent orange
    SDL_SetRenderDrawColor(renderer, 255, 165, 0, 100);
    float laneWidth = ROAD_WIDTH / 3.0f;

    SDL_FRect priorityLane = {
        0,
        CENTER_Y - laneWidth/2.0f,
        static_cast<float>(CENTER_X - ROAD_WIDTH/2.0f),
        laneWidth
    };

    SDL_RenderFillRect(renderer, &priorityLane);
}

void Renderer::renderTrafficLight(float x, float y, float rotation, LightState state) {
    // Constants for traffic light dimensions
    const float LIGHT_SPACING = 15.0f;        // Space between each light
    const float LIGHT_RADIUS = LIGHT_SIZE/2.0f;

    // Calculate oriented position for the traffic light housing
    float orientedX = x;
    float orientedY = y;

    // Apply rotation if needed to orient the traffic light correctly
    if (rotation != 0.0f) {
        SDL_FPoint rotated = rotatePoint(x, y,
            static_cast<float>(SimConstants::CENTER_X),
            static_cast<float>(SimConstants::CENTER_Y),
            rotation
        );
        orientedX = rotated.x;
        orientedY = rotated.y;
    }

    // Draw the traffic light housing (black background box)
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 255);  // Dark gray color
    SDL_FRect housing = {
        orientedX - HOUSING_PADDING,
        orientedY - HOUSING_PADDING,
        LIGHT_SIZE + (HOUSING_PADDING * 2.0f),
        (LIGHT_SIZE * 3.0f) + (HOUSING_PADDING * 4.0f)  // Room for three lights
    };
    SDL_RenderFillRect(renderer, &housing);

    // Draw outline for the housing
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);  // Lighter gray for border
    SDL_RenderRect(renderer, &housing);

    // Calculate positions for each light
    float centerX = orientedX + LIGHT_SIZE/2.0f;
    float redY = orientedY + LIGHT_SIZE/2.0f;
    float yellowY = redY + LIGHT_SIZE + LIGHT_SPACING;
    float greenY = yellowY + LIGHT_SIZE + LIGHT_SPACING;

    // Draw red light
    SDL_SetRenderDrawColor(renderer,
        state == LightState::RED ? 255 : 64,  // Bright red when active, dim when inactive
        0, 0, 255);
    renderCircle(centerX, redY, LIGHT_RADIUS);

    // Draw yellow light (always dim in two-state system)
    SDL_SetRenderDrawColor(renderer, 64, 64, 0, 255);
    renderCircle(centerX, yellowY, LIGHT_RADIUS);

    // Draw green light
    SDL_SetRenderDrawColor(renderer, 0,
        state == LightState::GREEN ? 255 : 64,  // Bright green when active, dim when inactive
        0, 255);
    renderCircle(centerX, greenY, LIGHT_RADIUS);
}

void Renderer::renderTrafficLights(const std::map<LaneId, TrafficLight>& lights) {
    using namespace SimConstants;

    // Define the standard positions for traffic lights
    struct LightPosition {
        float x;
        float y;
        float rotation;
        LaneId laneId;
    };

    // Define fixed positions for each traffic light
    const LightPosition positions[] = {
        // West approach (AL2 - Priority lane)
        {
            static_cast<float>(CENTER_X - ROAD_WIDTH/2.0f - 50.0f),
            static_cast<float>(CENTER_Y - LIGHT_SIZE * 3.0f),
            0.0f,
            LaneId::AL2_PRIORITY
        },
        // North approach (BL2)
        {
            static_cast<float>(CENTER_X - LIGHT_SIZE * 3.0f),
            static_cast<float>(CENTER_Y - ROAD_WIDTH/2.0f - 50.0f),
            90.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::BL2_NORMAL
        },
        // East approach (CL2)
        {
            static_cast<float>(CENTER_X + ROAD_WIDTH/2.0f + 50.0f),
            static_cast<float>(CENTER_Y - LIGHT_SIZE * 3.0f),
            180.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::CL2_NORMAL
        },
        // South approach (DL2)
        {
            static_cast<float>(CENTER_X - LIGHT_SIZE * 3.0f),
            static_cast<float>(CENTER_Y + ROAD_WIDTH/2.0f + 50.0f),
            270.0f * static_cast<float>(M_PI) / 180.0f,
            LaneId::DL2_NORMAL
        }
    };

    // Render each traffic light
    for (const auto& position : positions) {
        auto it = lights.find(position.laneId);
        if (it != lights.end()) {
            renderTrafficLight(
                position.x,
                position.y,
                position.rotation,
                it->second.getState()
            );
        }
    }
}


void Renderer::renderVehicles(const std::map<uint32_t, VehicleState>& vehicles) {
    for (const auto& [id, state] : vehicles) {
        renderVehicle(
            state.pos.x,          // Use pos.x instead of x
            state.pos.y,          // Use pos.y instead of y
            state.direction,
            state.vehicle->getCurrentLane() == LaneId::AL2_PRIORITY,
            state.turnAngle,
            state.isMoving
        );
    }
}

void Renderer::renderVehicle(float x, float y, Direction dir, bool isPriority, float angle, bool isMoving) {
    const float halfWidth = VEHICLE_WIDTH / 2.0f;
    const float halfHeight = VEHICLE_HEIGHT / 2.0f;

    // Create a smoother vehicle shape
    SDL_FPoint vertices[8] = {
        // Front
        {x + (halfWidth * 0.8f) * cosf(angle), y + (halfWidth * 0.8f) * sinf(angle)},
        // Front right
        {x + halfWidth * cosf(angle + 0.4f), y + halfWidth * sinf(angle + 0.4f)},
        // Right
        {x + halfWidth * cosf(angle + M_PI/2), y + halfWidth * sinf(angle + M_PI/2)},
        // Back right
        {x + halfWidth * cosf(angle + M_PI - 0.4f), y + halfWidth * sinf(angle + M_PI - 0.4f)},
        // Back
        {x - (halfWidth * 0.8f) * cosf(angle), y - (halfWidth * 0.8f) * sinf(angle)},
        // Back left
        {x + halfWidth * cosf(angle + M_PI + 0.4f), y + halfWidth * sinf(angle + M_PI + 0.4f)},
        // Left
        {x + halfWidth * cosf(angle - M_PI/2), y + halfWidth * sinf(angle - M_PI/2)},
        // Front left
        {x + halfWidth * cosf(angle - 0.4f), y + halfWidth * sinf(angle - 0.4f)}
    };

    // Draw shadow
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 100);
    for (int i = 0; i < 8; i++) {
        SDL_RenderLine(renderer,
            vertices[i].x + 2, vertices[i].y + 2,
            vertices[(i + 1) % 8].x + 2, vertices[(i + 1) % 8].y + 2);
    }

    // Vehicle body color
    if (isPriority) {
        SDL_SetRenderDrawColor(renderer, 255, 140, 0, 255); // Orange for priority
    } else {
        SDL_SetRenderDrawColor(renderer, 30, 144, 255, 255); // Blue for normal
    }

    // Draw vehicle body
    for (int i = 0; i < 8; i++) {
        SDL_RenderLine(renderer,
            vertices[i].x, vertices[i].y,
            vertices[(i + 1) % 8].x, vertices[(i + 1) % 8].y);
    }

    // Draw headlights
    SDL_SetRenderDrawColor(renderer, 255, 255, 200, 255);
    renderCircle(vertices[0].x - 5 * cosf(angle + 0.2f),
                vertices[0].y - 5 * sinf(angle + 0.2f), 3);
    renderCircle(vertices[0].x - 5 * cosf(angle - 0.2f),
                vertices[0].y - 5 * sinf(angle - 0.2f), 3);

    // Direction indicators
    if (dir != Direction::STRAIGHT) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 0, 200);
        if (dir == Direction::LEFT) {
            renderCircle(vertices[6].x, vertices[6].y, 4);
        } else {
            renderCircle(vertices[2].x, vertices[2].y, 4);
        }
    }

    // Movement trail
    if (isMoving) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 50);
        float t = static_cast<float>(SDL_GetTicks()) / 1000.0f;
        for (int i = 1; i <= 3; i++) {
            float offset = i * (5.0f + sinf(t * 4.0f) * 2.0f);
            float trailX = x - offset * cosf(angle);
            float trailY = y - offset * sinf(angle);
            renderCircle(trailX, trailY, 2);
        }
    }
}

void Renderer::renderIntersection() {
    using namespace SimConstants;

    // Draw intersection box with slightly darker asphalt
    SDL_SetRenderDrawColor(renderer, 45, 45, 45, 255);
    SDL_FRect intersection = {
        CENTER_X - ROAD_WIDTH/2.0f,
        CENTER_Y - ROAD_WIDTH/2.0f,
        static_cast<float>(ROAD_WIDTH),
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &intersection);

    // Draw intersection guidelines
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 100);

    // Center cross guidelines
    renderDashedLine(
        CENTER_X - ROAD_WIDTH/2.0f, CENTER_Y,
        CENTER_X + ROAD_WIDTH/2.0f, CENTER_Y
    );
    renderDashedLine(
        CENTER_X, CENTER_Y - ROAD_WIDTH/2.0f,
        CENTER_X, CENTER_Y + ROAD_WIDTH/2.0f
    );

    // Draw turning guide arcs
    renderTurningGuides();
}

void Renderer::renderTurningGuides() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 50);
    const int SEGMENTS = 32;
    const float TURN_RADIUS = ROAD_WIDTH / 2.0f;

    // Draw turning guide arcs for each corner
    for (int corner = 0; corner < 4; corner++) {
        float centerX = CENTER_X + ((corner & 1) ? ROAD_WIDTH/4.0f : -ROAD_WIDTH/4.0f);
        float centerY = CENTER_Y + ((corner & 2) ? ROAD_WIDTH/4.0f : -ROAD_WIDTH/4.0f);

        for (int i = 0; i < SEGMENTS; i++) {
            float startAngle = (corner * 90 + i * 90.0f / SEGMENTS) * M_PI / 180.0f;
            float endAngle = (corner * 90 + (i + 1) * 90.0f / SEGMENTS) * M_PI / 180.0f;

            float x1 = centerX + TURN_RADIUS * cosf(startAngle);
            float y1 = centerY + TURN_RADIUS * sinf(startAngle);
            float x2 = centerX + TURN_RADIUS * cosf(endAngle);
            float y2 = centerY + TURN_RADIUS * sinf(endAngle);

            SDL_RenderLine(renderer, x1, y1, x2, y2);
        }
    }
}

void Renderer::renderStopLines() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float STOP_LINE_WIDTH = 8.0f;
    const float OFFSET = ROAD_WIDTH/2.0f - 20.0f;

    // Draw stop lines at each intersection approach
    SDL_FRect stopLines[] = {
        // West approach
        {CENTER_X - OFFSET - STOP_LINE_WIDTH,
         CENTER_Y - LANE_WIDTH,
         STOP_LINE_WIDTH,
         LANE_WIDTH * 2},

        // North approach
        {CENTER_X - LANE_WIDTH,
         CENTER_Y - OFFSET - STOP_LINE_WIDTH,
         LANE_WIDTH * 2,
         STOP_LINE_WIDTH},

        // East approach
        {CENTER_X + OFFSET,
         CENTER_Y - LANE_WIDTH,
         STOP_LINE_WIDTH,
         LANE_WIDTH * 2},

        // South approach
        {CENTER_X - LANE_WIDTH,
         CENTER_Y + OFFSET,
         LANE_WIDTH * 2,
         STOP_LINE_WIDTH}
    };

    for (const auto& line : stopLines) {
        SDL_RenderFillRect(renderer, &line);
    }
}

void Renderer::renderDirectionalArrows() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 128);
    const float ARROW_DISTANCE = 150.0f;

    // Draw direction arrows for each lane
    for (int lane = -1; lane <= 1; lane++) {
        float laneOffset = static_cast<float>(lane * LANE_WIDTH);

        // West approach (right-side driving)
        drawArrow(CENTER_X - ARROW_DISTANCE, CENTER_Y + laneOffset,
                 0.0f, Direction::STRAIGHT);

        // North approach
        drawArrow(CENTER_X + laneOffset, CENTER_Y - ARROW_DISTANCE,
                 static_cast<float>(M_PI / 2), Direction::STRAIGHT);

        // East approach
        drawArrow(CENTER_X + ARROW_DISTANCE, CENTER_Y + laneOffset,
                 static_cast<float>(M_PI), Direction::STRAIGHT);

        // South approach
        drawArrow(CENTER_X + laneOffset, CENTER_Y + ARROW_DISTANCE,
                 static_cast<float>(-M_PI / 2), Direction::STRAIGHT);
    }

    // Add left turn arrows for free lanes
    drawArrow(CENTER_X - ARROW_DISTANCE, CENTER_Y + LANE_WIDTH,
             0.0f, Direction::LEFT);
    drawArrow(CENTER_X + LANE_WIDTH, CENTER_Y - ARROW_DISTANCE,
             static_cast<float>(M_PI / 2), Direction::LEFT);
    drawArrow(CENTER_X + ARROW_DISTANCE, CENTER_Y + LANE_WIDTH,
             static_cast<float>(M_PI), Direction::LEFT);
    drawArrow(CENTER_X + LANE_WIDTH, CENTER_Y + ARROW_DISTANCE,
             static_cast<float>(-M_PI / 2), Direction::LEFT);
}

void Renderer::drawArrow(float x, float y, float angle, Direction dir) {
    const float ARROW_LENGTH = 30.0f;
    const float HEAD_SIZE = 10.0f;
    const float HEAD_ANGLE = static_cast<float>(M_PI / 6);

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    // Draw arrow shaft
    float endX = x + ARROW_LENGTH * cosA;
    float endY = y + ARROW_LENGTH * sinA;
    SDL_RenderLine(renderer, x, y, endX, endY);

    // Draw arrow head
    float leftX = endX - HEAD_SIZE * cosf(angle + HEAD_ANGLE);
    float leftY = endY - HEAD_SIZE * sinf(angle + HEAD_ANGLE);
    float rightX = endX - HEAD_SIZE * cosf(angle - HEAD_ANGLE);
    float rightY = endY - HEAD_SIZE * sinf(angle - HEAD_ANGLE);

    SDL_RenderLine(renderer, endX, endY, leftX, leftY);
    SDL_RenderLine(renderer, endX, endY, rightX, rightY);

    // Add curved arrow for left turns
    if (dir == Direction::LEFT) {
        const float CURVE_RADIUS = 15.0f;
        const int SEGMENTS = 8;

        for (int i = 0; i < SEGMENTS; i++) {
            float startAngle = angle - M_PI/2 + (i * M_PI/2) / SEGMENTS;
            float endAngle = angle - M_PI/2 + ((i + 1) * M_PI/2) / SEGMENTS;

            float x1 = x + CURVE_RADIUS * cosf(startAngle);
            float y1 = y + CURVE_RADIUS * sinf(startAngle);
            float x2 = x + CURVE_RADIUS * cosf(endAngle);
            float y2 = y + CURVE_RADIUS * sinf(endAngle);

            SDL_RenderLine(renderer, x1, y1, x2, y2);
        }
    }
}

void Renderer::renderCircle(float x, float y, float radius) {
    const int SEGMENTS = 16;
    for (int i = 0; i < SEGMENTS; i++) {
        float angle1 = 2.0f * M_PI * i / SEGMENTS;
        float angle2 = 2.0f * M_PI * (i + 1) / SEGMENTS;

        SDL_RenderLine(renderer,
            x + radius * cosf(angle1),
            y + radius * sinf(angle1),
            x + radius * cosf(angle2),
            y + radius * sinf(angle2)
        );
    }
}

void Renderer::renderDashedLine(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    float length = std::sqrt(dx * dx + dy * dy);
    float nx = dx / length;
    float ny = dy / length;

    float x = x1;
    float y = y1;
    bool drawing = true;
    float remainingLength = length;

    while (remainingLength > 0) {
        float segmentLength = std::min(drawing ? DASH_LENGTH : GAP_LENGTH, remainingLength);

        if (drawing) {
            float endX = x + nx * segmentLength;
            float endY = y + ny * segmentLength;
            SDL_RenderLine(renderer, x, y, endX, endY);
        }

        x += nx * segmentLength;
        y += ny * segmentLength;
        remainingLength -= segmentLength;
        drawing = !drawing;
    }
}

void Renderer::cleanup() {
    if (renderer) {
        SDL_DestroyRenderer(renderer);
        renderer = nullptr;
    }
    if (window) {
        SDL_DestroyWindow(window);
        window = nullptr;
    }
    SDL_Quit();
}

float Renderer::calculateTurningAngle(const VehicleState& state) const {
    float dx = state.targetPos.x - state.pos.x;
    float dy = state.targetPos.y - state.pos.y;
    return std::atan2f(dy, dx);
}

SDL_Color Renderer::getLaneColor(LaneId laneId, bool isActive) const {
    if (isActive) {
        if (laneId == LaneId::AL2_PRIORITY) {
            return {255, 165, 0, 255}; // Orange for active priority lane
        }
        return {0, 255, 0, 255}; // Green for active normal lanes
    }

    if (laneId == LaneId::AL2_PRIORITY) {
        return {255, 165, 0, 128}; // Semi-transparent orange for inactive priority lane
    }
    return {255, 255, 255, 128}; // Semi-transparent white for inactive normal lanes
}

void Renderer::drawDebugGrid() {
    SDL_SetRenderDrawColor(renderer, 128, 128, 128, 64);

    // Draw vertical grid lines
    for (float x = 0.0f; x < static_cast<float>(SimConstants::WINDOW_WIDTH); x += 50.0f) {
        SDL_RenderLine(renderer,
            static_cast<int>(x), 0,
            static_cast<int>(x), SimConstants::WINDOW_HEIGHT
        );
    }

    // Draw horizontal grid lines
    for (float y = 0.0f; y < static_cast<float>(SimConstants::WINDOW_HEIGHT); y += 50.0f) {
        SDL_RenderLine(renderer,
            0, static_cast<int>(y),
            SimConstants::WINDOW_WIDTH, static_cast<int>(y)
        );
    }
}



void Renderer::renderCrosswalks() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float STRIPE_WIDTH = 5.0f;
    const float STRIPE_LENGTH = 30.0f;
    const float STRIPE_GAP = 5.0f;
    const float CROSSWALK_WIDTH = 20.0f;

    // Render crosswalks on all four sides of the intersection
    for (int i = 0; i < 4; ++i) {
        float angle = static_cast<float>(i * 90) * static_cast<float>(M_PI) / 180.0f;
        float baseX = CENTER_X + cosf(angle) * (ROAD_WIDTH / 2.0f - CROSSWALK_WIDTH);
        float baseY = CENTER_Y + sinf(angle) * (ROAD_WIDTH / 2.0f - CROSSWALK_WIDTH);

        // Draw zebra stripes
        for (float offset = 0; offset < ROAD_WIDTH; offset += STRIPE_WIDTH + STRIPE_GAP) {
            SDL_FPoint p1 = rotatePoint(baseX, baseY + offset, CENTER_X, CENTER_Y, angle);
            SDL_FPoint p2 = rotatePoint(baseX + STRIPE_LENGTH, baseY + offset, CENTER_X, CENTER_Y, angle);

            SDL_FRect stripe = {
                p1.x, p1.y,
                STRIPE_WIDTH,
                p2.y - p1.y
            };
            SDL_RenderFillRect(renderer, &stripe);
        }
    }
}

SDL_FPoint Renderer::rotatePoint(float x, float y, float cx, float cy, float angle) {
    // First, translate point back to origin by subtracting center coordinates
    float translatedX = x - cx;
    float translatedY = y - cy;

    // Perform the rotation using the rotation matrix:
    // | cos(θ) -sin(θ) |
    // | sin(θ)  cos(θ) |
    float rotatedX = translatedX * cosf(angle) - translatedY * sinf(angle);
    float rotatedY = translatedX * sinf(angle) + translatedY * cosf(angle);

    // Translate back to original position by adding center coordinates
    SDL_FPoint result = {
        rotatedX + cx,
        rotatedY + cy
    };

    return result;
}

void Renderer::renderPriorityLaneIndicator() {
    using namespace SimConstants;

    // Draw priority mode indicator in top-left corner
    const float INDICATOR_SIZE = 30.0f;
    const float PADDING = 10.0f;

    SDL_SetRenderDrawColor(renderer, 255, 69, 0, 255); // Orange for priority
    SDL_FRect indicator = {
        PADDING,
        PADDING,
        INDICATOR_SIZE,
        INDICATOR_SIZE
    };
    SDL_RenderFillRect(renderer, &indicator);

    // Add pulsing effect
    float t = static_cast<float>(SDL_GetTicks()) / 1000.0f;
    uint8_t alpha = static_cast<uint8_t>(128 + 127 * sinf(t * 2.0f));
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, alpha);
    SDL_RenderRect(renderer, &indicator);
}

void Renderer::renderLaneIdentifiers() {
    using namespace SimConstants;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const float OFFSET = ROAD_WIDTH / 2.0f + 30.0f;

    // Define lane positions and labels
    struct LaneLabel {
        float x, y;
        LaneId id;
    } labels[] = {
        {CENTER_X - OFFSET, CENTER_Y - LANE_WIDTH, LaneId::AL1_INCOMING},
        {CENTER_X - OFFSET, CENTER_Y, LaneId::AL2_PRIORITY},
        {CENTER_X - OFFSET, CENTER_Y + LANE_WIDTH, LaneId::AL3_FREELANE},

        {CENTER_X - LANE_WIDTH, CENTER_Y - OFFSET, LaneId::BL1_INCOMING},
        {CENTER_X, CENTER_Y - OFFSET, LaneId::BL2_NORMAL},
        {CENTER_X + LANE_WIDTH, CENTER_Y - OFFSET, LaneId::BL3_FREELANE},

        {CENTER_X + OFFSET, CENTER_Y - LANE_WIDTH, LaneId::CL1_INCOMING},
        {CENTER_X + OFFSET, CENTER_Y, LaneId::CL2_NORMAL},
        {CENTER_X + OFFSET, CENTER_Y + LANE_WIDTH, LaneId::CL3_FREELANE},

        {CENTER_X - LANE_WIDTH, CENTER_Y + OFFSET, LaneId::DL1_INCOMING},
        {CENTER_X, CENTER_Y + OFFSET, LaneId::DL2_NORMAL},
        {CENTER_X + LANE_WIDTH, CENTER_Y + OFFSET, LaneId::DL3_FREELANE}
    };

    // Draw background rectangles for labels
    for (const auto& label : labels) {
        SDL_FRect bg = {
            label.x - 25.0f,
            label.y - 12.0f,
            50.0f,
            24.0f
        };

        // Different colors for different lane types
        if (label.id == LaneId::AL2_PRIORITY) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 128); // Orange for priority
        } else if (static_cast<int>(label.id) % 3 == 2) {
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 128); // Green for free lanes
        } else {
            SDL_SetRenderDrawColor(renderer, 100, 100, 100, 128); // Gray for normal lanes
        }

        SDL_RenderFillRect(renderer, &bg);
    }
}

void Renderer::renderVehicleCount(const TrafficManager& trafficManager) {
    using namespace SimConstants;

    const float PADDING = 10.0f;
    const float BOX_WIDTH = 150.0f;
    const float BOX_HEIGHT = 80.0f;

    // Draw background panel
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200);
    SDL_FRect countBox = {
        PADDING,
        WINDOW_HEIGHT - BOX_HEIGHT - PADDING,
        BOX_WIDTH,
        BOX_HEIGHT
    };
    SDL_RenderFillRect(renderer, &countBox);

    // Draw separator lines
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 128);
    SDL_RenderLine(renderer,
        countBox.x,
        countBox.y + BOX_HEIGHT / 2.0f,
        countBox.x + BOX_WIDTH,
        countBox.y + BOX_HEIGHT / 2.0f
    );

    // Vehicle counts are rendered here
    // Note: Actual text rendering would require SDL_ttf setup
    // For now, we just show the box layout
}

// End of Renderer.cpp

