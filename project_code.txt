// Project Code from CMakeLists.txt
// Total files: 21

//===== FILE: src/core/Vehicle.cpp =====//

// FILE: src/core/Vehicle.cpp
#include "core/Vehicle.h"
#include "core/Constants.h"
#include "utils/DebugLogger.h"
#include <cmath>
#include <sstream>
#include <random> // Add this for random number generation

Vehicle::Vehicle(const std::string& id, char lane, int laneNumber, bool isEmergency)
    : id(id),
      lane(lane),
      laneNumber(laneNumber),
      isEmergency(isEmergency),
      arrivalTime(time(nullptr)),
      animPos(0.0f),
      turning(false),
      turnProgress(0.0f),
      turnPosX(0.0f),
      turnPosY(0.0f),
      queuePos(0),
      destination(Destination::STRAIGHT),
      currentDirection(Direction::DOWN),
      state(VehicleState::APPROACHING),
      currentWaypoint(0) {

    // Log creation
    std::ostringstream oss;
    oss << "Created vehicle " << id << " in lane " << lane << laneNumber;
    DebugLogger::log(oss.str());

    // Window dimensions
    const int windowWidth = 800;
    const int windowHeight = 800;
    const int centerX = windowWidth / 2;
    const int centerY = windowHeight / 2;

    // Determine current direction based on road (lane letter)
    // A is North (top), B is East (right), C is South (bottom), D is West (left)
    switch (lane) {
        case 'A':
            currentDirection = Direction::DOWN;  // Road A (North) vehicles move DOWN
            break;
        case 'B':
            currentDirection = Direction::LEFT;  // Road B (East) vehicles move LEFT
            break;
        case 'C':
            currentDirection = Direction::UP;    // Road C (South) vehicles move UP
            break;
        case 'D':
            currentDirection = Direction::RIGHT; // Road D (West) vehicles move RIGHT
            break;
        default:
            DebugLogger::log("Invalid lane ID: " + std::string(1, lane), DebugLogger::LogLevel::ERROR);
            currentDirection = Direction::DOWN;
            break;
    }

    // Lane spacing - wider for better visibility
    const float laneWidth = 50.0f;
    const float laneOffset = 50.0f;
    const float roadWidth = 150.0f;

    // Set initial position based on lane and laneNumber (1, 2, or 3)
    // IMPORTANT: We position vehicles according to ONE-WAY lanes on each road
    switch (lane) {
        case 'A': // North road (top)
            // Lane 1 is not spawned (it's incoming)
            // Lane 2 is middle lane - can go straight or left
            // Lane 3 is rightmost lane - always turns left
            switch (laneNumber) {
                case 2:
                    turnPosX = centerX; // Center lane
                    break;
                case 3:
                    turnPosX = centerX + laneOffset; // Right lane
                    break;
                default:
                    turnPosX = centerX; // Default to center if invalid
                    DebugLogger::log("Invalid lane number for Road A: " + std::to_string(laneNumber), DebugLogger::LogLevel::WARNING);
                    break;
            }
            turnPosY = 20.0f; // Near top of screen
            break;

        case 'B': // East road (right)
            switch (laneNumber) {
                case 2:
                    turnPosY = centerY; // Center lane
                    break;
                case 3:
                    turnPosY = centerY + laneOffset; // Bottom lane
                    break;
                default:
                    turnPosY = centerY; // Default to center if invalid
                    DebugLogger::log("Invalid lane number for Road B: " + std::to_string(laneNumber), DebugLogger::LogLevel::WARNING);
                    break;
            }
            turnPosX = windowWidth - 20.0f; // Near right edge of screen
            break;

        case 'C': // South road (bottom)
            switch (laneNumber) {
                case 2:
                    turnPosX = centerX; // Center lane
                    break;
                case 3:
                    turnPosX = centerX - laneOffset; // Left lane
                    break;
                default:
                    turnPosX = centerX; // Default to center if invalid
                    DebugLogger::log("Invalid lane number for Road C: " + std::to_string(laneNumber), DebugLogger::LogLevel::WARNING);
                    break;
            }
            turnPosY = windowHeight - 20.0f; // Near bottom of screen
            break;

        case 'D': // West road (left)
            switch (laneNumber) {
                case 2:
                    turnPosY = centerY; // Center lane
                    break;
                case 3:
                    turnPosY = centerY - laneOffset; // Top lane
                    break;
                default:
                    turnPosY = centerY; // Default to center if invalid
                    DebugLogger::log("Invalid lane number for Road D: " + std::to_string(laneNumber), DebugLogger::LogLevel::WARNING);
                    break;
            }
            turnPosX = 20.0f; // Near left edge of screen
            break;
    }

    // Set initial animation position
    animPos = (currentDirection == Direction::UP || currentDirection == Direction::DOWN) ?
              turnPosY : turnPosX;

    // Determine destination based on lane number following the assignment rules
    if (laneNumber == 3) {
        // Lane 3 (L3) always turns left
        destination = Destination::LEFT;
        std::string msg = "Vehicle " + id + " on lane " + lane + std::to_string(laneNumber) + " will turn LEFT (free lane rule)";
        DebugLogger::log(msg);
    }
    else if (laneNumber == 2) {
        // Lane 2 (L2) can go straight or left (not right)
        // Check for direction indication in ID
        if (id.find("_LEFT") != std::string::npos) {
            destination = Destination::LEFT;
        } else if (id.find("_STRAIGHT") != std::string::npos) {
            destination = Destination::STRAIGHT;
        } else {
            // Default behavior: 60% straight, 40% left
            int idHash = 0;
            for (char c : id) idHash += c;
            destination = (idHash % 10 < 6) ? Destination::STRAIGHT : Destination::LEFT;
        }

        std::string destStr = (destination == Destination::STRAIGHT) ? "STRAIGHT" : "LEFT";
        DebugLogger::log("Vehicle " + id + " on lane " + lane + std::to_string(laneNumber) + " will go " + destStr);
    }
    else if (laneNumber == 1) {
        // Lane 1 (L1) is incoming lane (vehicles don't spawn here)
        destination = Destination::STRAIGHT;
        DebugLogger::log("WARNING: Vehicle " + id + " created in lane " + lane + "1 (incoming lane)");
    }

    // Initialize waypoints for movement
    initializeWaypoints();
}

Vehicle::~Vehicle() {
    std::ostringstream oss;
    oss << "Destroyed vehicle " << id;
    DebugLogger::log(oss.str());
}

void Vehicle::initializeWaypoints() {
    // Window dimensions
    const int windowWidth = 800;
    const int windowHeight = 800;
    const int centerX = windowWidth / 2;
    const int centerY = windowHeight / 2;

    // Clear existing waypoints
    waypoints.clear();

    // Adjust intersection boundaries
    const float intersectionHalf = 70.0f; // Increased size for better visualization
    const float leftEdge = centerX - intersectionHalf;
    const float rightEdge = centerX + intersectionHalf;
    const float topEdge = centerY - intersectionHalf;
    const float bottomEdge = centerY + intersectionHalf;

    // Lane offset - consistent with vehicle initialization
    const float laneOffset = 50.0f;

    // Define offsets for the lanes - L1, L2, L3
    const float lane1Offset = -20.0f;  // Offset for Lane 1 (incoming)
    const float lane2Offset = 0.0f;    // Lane 2 is aligned with center
    const float lane3Offset = 20.0f;   // Offset for Lane 3 (free lane)

    // Add the starting position as first waypoint
    waypoints.push_back({turnPosX, turnPosY});

    // Add approach to intersection waypoint
    switch (currentDirection) {
        case Direction::DOWN: // From North (A)
            waypoints.push_back({turnPosX, topEdge - 5.0f});
            break;
        case Direction::UP: // From South (C)
            waypoints.push_back({turnPosX, bottomEdge + 5.0f});
            break;
        case Direction::LEFT: // From East (B)
            waypoints.push_back({rightEdge + 5.0f, turnPosY});
            break;
        case Direction::RIGHT: // From West (D)
            waypoints.push_back({leftEdge - 5.0f, turnPosY});
            break;
    }

    // UPDATED TURNING LOGIC BASED ON ASSIGNMENT REQUIREMENTS:
    // AL3 → BL1; AL2: Straight → CL1, Left → DL1
    // BL3 → CL1; BL2: Straight → DL1, Left → AL1
    // CL3 → DL1; CL2: Straight → AL1, Left → BL1
    // DL3 → AL1; DL2: Straight → BL1, Left → CL1

    if (laneNumber == 3) {
        // Lane 3 always turns left - Updated for the required routing with improved turns
        switch (currentDirection) {
            case Direction::DOWN:  // A(North) to B(East) - AL3 → BL1
                // First intermediate point
                waypoints.push_back({turnPosX - 10.0f, topEdge + 20.0f});

                // Second intermediate point - smoother turn
                waypoints.push_back({centerX - 20.0f, centerY - 30.0f});

                // Third intermediate point - approaching exit
                waypoints.push_back({rightEdge - 20.0f, centerY + lane1Offset});

                // Exit point - precisely at BL1
                waypoints.push_back({rightEdge + 5.0f, centerY + lane1Offset});

                // Off screen
                waypoints.push_back({windowWidth + 30.0f, centerY + lane1Offset});
                break;

            case Direction::UP:    // C(South) to D(West) - CL3 → DL1
                // First intermediate point
                waypoints.push_back({turnPosX + 10.0f, bottomEdge - 20.0f});

                // Second intermediate point - smoother turn
                waypoints.push_back({centerX + 20.0f, centerY + 30.0f});

                // Third intermediate point - approaching exit
                waypoints.push_back({leftEdge + 20.0f, centerY + lane1Offset});

                // Exit point - precisely at DL1
                waypoints.push_back({leftEdge - 5.0f, centerY + lane1Offset});

                // Off screen
                waypoints.push_back({-30.0f, centerY + lane1Offset});
                break;

            case Direction::LEFT:  // B(East) to C(South) - BL3 → CL1
                // First intermediate point
                waypoints.push_back({rightEdge - 20.0f, turnPosY - 10.0f});

                // Second intermediate point - smoother turn
                waypoints.push_back({centerX + 30.0f, centerY - 20.0f});

                // Third intermediate point - approaching exit
                waypoints.push_back({centerX + lane1Offset, bottomEdge - 20.0f});

                // Exit point - precisely at CL1
                waypoints.push_back({centerX + lane1Offset, bottomEdge + 5.0f});

                // Off screen
                waypoints.push_back({centerX + lane1Offset, windowHeight + 30.0f});
                break;

            case Direction::RIGHT: // D(West) to A(North) - DL3 → AL1
                // First intermediate point
                waypoints.push_back({leftEdge + 20.0f, turnPosY + 10.0f});

                // Second intermediate point - smoother turn
                waypoints.push_back({centerX - 30.0f, centerY + 20.0f});

                // Third intermediate point - approaching exit
                waypoints.push_back({centerX + lane1Offset, topEdge + 20.0f});

                // Exit point - precisely at AL1
                waypoints.push_back({centerX + lane1Offset, topEdge - 5.0f});

                // Off screen
                waypoints.push_back({centerX + lane1Offset, -30.0f});
                break;
        }
    }
    else if (laneNumber == 2) {
        if (destination == Destination::STRAIGHT) {
            // Straight movements with gradual adjustment to reach L1
            switch (currentDirection) {
                case Direction::DOWN:  // A(North) to C(South) - AL2(straight) → CL1
                    // Through the intersection - slight adjustment to reach CL1
                    waypoints.push_back({turnPosX, centerY - 20.0f});
                    waypoints.push_back({centerX + lane1Offset, centerY + 20.0f});

                    // Exit point - precisely at CL1
                    waypoints.push_back({centerX + lane1Offset, bottomEdge + 5.0f});

                    // Off screen
                    waypoints.push_back({centerX + lane1Offset, windowHeight + 30.0f});
                    break;

                case Direction::UP:    // C(South) to A(North) - CL2(straight) → AL1
                    // Through the intersection - slight adjustment to reach AL1
                    waypoints.push_back({turnPosX, centerY + 20.0f});
                    waypoints.push_back({centerX + lane1Offset, centerY - 20.0f});

                    // Exit point - precisely at AL1
                    waypoints.push_back({centerX + lane1Offset, topEdge - 5.0f});

                    // Off screen
                    waypoints.push_back({centerX + lane1Offset, -30.0f});
                    break;

                case Direction::LEFT:  // B(East) to D(West) - BL2(straight) → DL1
                    // Through the intersection - slight adjustment to reach DL1
                    waypoints.push_back({centerX + 20.0f, turnPosY});
                    waypoints.push_back({centerX - 20.0f, centerY + lane1Offset});

                    // Exit point - precisely at DL1
                    waypoints.push_back({leftEdge - 5.0f, centerY + lane1Offset});

                    // Off screen
                    waypoints.push_back({-30.0f, centerY + lane1Offset});
                    break;

                case Direction::RIGHT: // D(West) to B(East) - DL2(straight) → BL1
                    // Through the intersection - slight adjustment to reach BL1
                    waypoints.push_back({centerX - 20.0f, turnPosY});
                    waypoints.push_back({centerX + 20.0f, centerY + lane1Offset});

                    // Exit point - precisely at BL1
                    waypoints.push_back({rightEdge + 5.0f, centerY + lane1Offset});

                    // Off screen
                    waypoints.push_back({windowWidth + 30.0f, centerY + lane1Offset});
                    break;
            }
        }
        else if (destination == Destination::LEFT) {
            // Left turn movements with smooth Bezier curves
            switch (currentDirection) {
                case Direction::DOWN:  // A(North) to D(West) - AL2(left) → DL1
                    // First intermediate point
                    waypoints.push_back({turnPosX - 20.0f, topEdge + 15.0f});

                    // Second intermediate point - smoother turn
                    waypoints.push_back({centerX - 40.0f, centerY - 20.0f});

                    // Third intermediate point - approaching exit
                    waypoints.push_back({leftEdge + 20.0f, centerY + lane1Offset});

                    // Exit point - precisely at DL1
                    waypoints.push_back({leftEdge - 5.0f, centerY + lane1Offset});

                    // Off screen
                    waypoints.push_back({-30.0f, centerY + lane1Offset});
                    break;

                case Direction::UP:    // C(South) to B(East) - CL2(left) → BL1
                    // First intermediate point
                    waypoints.push_back({turnPosX + 20.0f, bottomEdge - 15.0f});

                    // Second intermediate point - smoother turn
                    waypoints.push_back({centerX + 40.0f, centerY + 20.0f});

                    // Third intermediate point - approaching exit
                    waypoints.push_back({rightEdge - 20.0f, centerY + lane1Offset});

                    // Exit point - precisely at BL1
                    waypoints.push_back({rightEdge + 5.0f, centerY + lane1Offset});

                    // Off screen
                    waypoints.push_back({windowWidth + 30.0f, centerY + lane1Offset});
                    break;

                case Direction::LEFT:  // B(East) to A(North) - BL2(left) → AL1
                    // First intermediate point
                    waypoints.push_back({rightEdge - 15.0f, turnPosY - 20.0f});

                    // Second intermediate point - smoother turn
                    waypoints.push_back({centerX + 20.0f, centerY - 40.0f});

                    // Third intermediate point - approaching exit
                    waypoints.push_back({centerX + lane1Offset, topEdge + 20.0f});

                    // Exit point - precisely at AL1
                    waypoints.push_back({centerX + lane1Offset, topEdge - 5.0f});

                    // Off screen
                    waypoints.push_back({centerX + lane1Offset, -30.0f});
                    break;

                case Direction::RIGHT: // D(West) to C(South) - DL2(left) → CL1
                    // First intermediate point
                    waypoints.push_back({leftEdge + 15.0f, turnPosY + 20.0f});

                    // Second intermediate point - smoother turn
                    waypoints.push_back({centerX - 20.0f, centerY + 40.0f});

                    // Third intermediate point - approaching exit
                    waypoints.push_back({centerX + lane1Offset, bottomEdge - 20.0f});

                    // Exit point - precisely at CL1
                    waypoints.push_back({centerX + lane1Offset, bottomEdge + 5.0f});

                    // Off screen
                    waypoints.push_back({centerX + lane1Offset, windowHeight + 30.0f});
                    break;
            }
        }
    }

    // Set current waypoint index
    currentWaypoint = 0;
    turning = false;
}

std::string Vehicle::getId() const {
    return id;
}

char Vehicle::getLane() const {
    return lane;
}

void Vehicle::setLane(char lane) {
    this->lane = lane;
}

int Vehicle::getLaneNumber() const {
    return laneNumber;
}

void Vehicle::setLaneNumber(int number) {
    this->laneNumber = number;
}

bool Vehicle::isEmergencyVehicle() const {
    return isEmergency;
}

time_t Vehicle::getArrivalTime() const {
    return arrivalTime;
}

float Vehicle::getAnimationPos() const {
    return animPos;
}

void Vehicle::setAnimationPos(float pos) {
    this->animPos = pos;
}

bool Vehicle::isTurning() const {
    return turning;
}

void Vehicle::setTurning(bool turning) {
    this->turning = turning;
}

float Vehicle::getTurnProgress() const {
    return turnProgress;
}

void Vehicle::setTurnProgress(float progress) {
    this->turnProgress = progress;
}

float Vehicle::getTurnPosX() const {
    return turnPosX;
}

void Vehicle::setTurnPosX(float x) {
    this->turnPosX = x;
}

float Vehicle::getTurnPosY() const {
    return turnPosY;
}

void Vehicle::setTurnPosY(float y) {
    this->turnPosY = y;
}

void Vehicle::setDestination(Destination dest) {
    if (this->destination != dest) {
        this->destination = dest;

        // When destination changes, reinitialize waypoints to update the path
        initializeWaypoints();

        // Log the destination change
        std::ostringstream oss;
        std::string destStr;
        switch (dest) {
            case Destination::STRAIGHT: destStr = "STRAIGHT"; break;
            case Destination::LEFT: destStr = "LEFT"; break;
            case Destination::RIGHT: destStr = "RIGHT"; break;
        }
        oss << "Vehicle " << id << " destination set to " << destStr;
        DebugLogger::log(oss.str());
    }
}

Destination Vehicle::getDestination() const {
    return destination;
}

float Vehicle::easeInOutQuad(float t) const {
    return t < 0.5f ? 2.0f * t * t : -1.0f + (4.0f - 2.0f * t) * t;
}

void Vehicle::update(uint32_t delta, bool isGreenLight, float targetPos) {
    // Fine-tune speed for smoother animation
    const float SPEED_BASE = 0.018f;
    const float SPEED = SPEED_BASE * delta;
    const float VEHICLE_SPACING = 50.0f; // Increased from 35.0f for better separation

    // Free lane (lane 3) always has green light
    bool canMove = isGreenLight || laneNumber == 3;

    if (canMove) {
        // We have more waypoints to travel
        if (currentWaypoint < waypoints.size() - 1) {
            // Get current and next waypoint
            auto& current = waypoints[currentWaypoint];
            auto& next = waypoints[currentWaypoint + 1];

            // Calculate direction vector
            float dx = next.x - turnPosX;
            float dy = next.y - turnPosY;

            // Calculate distance to next waypoint
            float distance = std::sqrt(dx*dx + dy*dy);

            // If close enough to waypoint, move to next
            if (distance < 3.0f) {
                currentWaypoint++;

                // For L3 (always turns left) and L2 (turns left if specified)
                if ((laneNumber == 3) ||
                    (laneNumber == 2 && destination == Destination::LEFT)) {

                    // When entering turning points (varies by direction)
                    if (currentWaypoint == 2) {
                        turning = true;
                        turnProgress = 0.0f;
                        state = VehicleState::IN_INTERSECTION;

                        // Log turn start
                        std::ostringstream oss;
                        oss << "Vehicle " << id << " is now turning LEFT";
                        DebugLogger::log(oss.str());
                    }
                }

                // Determine when a vehicle has exited the intersection
                // This depends on the lane and destination
                bool isExiting = false;

                if (laneNumber == 3) {
                    // L3 vehicles have 5 waypoints typically
                    isExiting = (currentWaypoint == 4);
                } else if (laneNumber == 2) {
                    if (destination == Destination::LEFT) {
                        // L2 turning left has 5 waypoints
                        isExiting = (currentWaypoint == 4);
                    } else {
                        // L2 going straight has 4 waypoints
                        isExiting = (currentWaypoint == 3);
                    }
                }

                // Update vehicle state when exiting
                if (isExiting) {
                    turning = false;
                    state = VehicleState::EXITING;

                    // Update lane and number based on assignment rules:
                    // AL3 → BL1; AL2: Straight → CL1, Left → DL1
                    // BL3 → CL1; BL2: Straight → DL1, Left → AL1
                    // CL3 → DL1; CL2: Straight → AL1, Left → BL1
                    // DL3 → AL1; DL2: Straight → BL1, Left → CL1

                    std::string newLaneStr;
                    switch (currentDirection) {
                        case Direction::DOWN:  // From North (A)
                            if (laneNumber == 3) {
                                // AL3 → BL1
                                lane = 'B';
                                laneNumber = 1;
                                currentDirection = Direction::LEFT;
                                newLaneStr = "B1 (turned LEFT from A3)";
                            }
                            else if (destination == Destination::LEFT) {
                                // AL2(left) → DL1
                                lane = 'D';
                                laneNumber = 1;
                                currentDirection = Direction::RIGHT;
                                newLaneStr = "D1 (turned LEFT from A2)";
                            }
                            else {
                                // AL2(straight) → CL1
                                lane = 'C';
                                laneNumber = 1;
                                newLaneStr = "C1 (going STRAIGHT from A2)";
                            }
                            break;

                        case Direction::UP:    // From South (C)
                            if (laneNumber == 3) {
                                // CL3 → DL1
                                lane = 'D';
                                laneNumber = 1;
                                currentDirection = Direction::RIGHT;
                                newLaneStr = "D1 (turned LEFT from C3)";
                            }
                            else if (destination == Destination::LEFT) {
                                // CL2(left) → BL1
                                lane = 'B';
                                laneNumber = 1;
                                currentDirection = Direction::LEFT;
                                newLaneStr = "B1 (turned LEFT from C2)";
                            }
                            else {
                                // CL2(straight) → AL1
                                lane = 'A';
                                laneNumber = 1;
                                newLaneStr = "A1 (going STRAIGHT from C2)";
                            }
                            break;

                        case Direction::LEFT:  // From East (B)
                            if (laneNumber == 3) {
                                // BL3 → CL1
                                lane = 'C';
                                laneNumber = 1;
                                currentDirection = Direction::UP;
                                newLaneStr = "C1 (turned LEFT from B3)";
                            }
                            else if (destination == Destination::LEFT) {
                                // BL2(left) → AL1
                                lane = 'A';
                                laneNumber = 1;
                                currentDirection = Direction::DOWN;
                                newLaneStr = "A1 (turned LEFT from B2)";
                            }
                            else {
                                // BL2(straight) → DL1
                                lane = 'D';
                                laneNumber = 1;
                                newLaneStr = "D1 (going STRAIGHT from B2)";
                            }
                            break;

                        case Direction::RIGHT: // From West (D)
                            if (laneNumber == 3) {
                                // DL3 → AL1
                                lane = 'A';
                                laneNumber = 1;
                                currentDirection = Direction::DOWN;
                                newLaneStr = "A1 (turned LEFT from D3)";
                            }
                            else if (destination == Destination::LEFT) {
                                // DL2(left) → CL1
                                lane = 'C';
                                laneNumber = 1;
                                currentDirection = Direction::UP;
                                newLaneStr = "C1 (turned LEFT from D2)";
                            }
                            else {
                                // DL2(straight) → BL1
                                lane = 'B';
                                laneNumber = 1;
                                newLaneStr = "B1 (going STRAIGHT from D2)";
                            }
                            break;
                    }

                    // Log lane change
                    DebugLogger::log("Vehicle " + id + " now on " + newLaneStr);
                }
            }

            // Adjust speed based on position and turn status
            float adjustedSpeed = SPEED;

            // Slower when approaching intersection
            if (currentWaypoint == 1) {
                adjustedSpeed *= 0.9f;
            }
            // Even slower in turning phase
            else if (turning) {
                adjustedSpeed *= 0.7f;
            }
            // Faster when exiting intersection
            else if (currentWaypoint >= 3) {
                adjustedSpeed *= 1.2f;
            }

            // Move toward next waypoint
            if (distance > 0) {
                // Normalize direction vector
                dx /= distance;
                dy /= distance;

                // Move toward waypoint with adjusted speed
                turnPosX += dx * adjustedSpeed;
                turnPosY += dy * adjustedSpeed;

                // Update animation position
                animPos = (currentDirection == Direction::UP || currentDirection == Direction::DOWN) ?
                         turnPosY : turnPosX;
            }

            // Update turn progress for visualization
            if (turning) {
                turnProgress = std::min(1.0f, turnProgress + 0.002f * delta);
            }
        }

        // Check if we've reached the last waypoint
        if (currentWaypoint == waypoints.size() - 1) {
            // Get screen dimensions
            const int windowWidth = 800;
            const int windowHeight = 800;

            // Check if off-screen
            if (turnPosX < -30.0f || turnPosX > windowWidth + 30.0f ||
                turnPosY < -30.0f || turnPosY > windowHeight + 30.0f) {
                // Flag for removal
                state = VehicleState::EXITED;
            }
        }
    }
    else {
        // Red light - handle queue positioning with deceleration
        if (currentWaypoint <= 1) {  // Vehicle is approaching or at the stop line
            // Get the stop line waypoint
            auto& stopLine = waypoints[1];

            // Calculate target position based on queue position with improved spacing
            float queueOffsetDistance = VEHICLE_SPACING * (queuePos + 0.2f); // Added small offset for better staggering
            float queueStopX = stopLine.x;
            float queueStopY = stopLine.y;

            // Adjust target position based on direction of travel
            switch (currentDirection) {
                case Direction::DOWN:  // From North (A)
                    queueStopY -= queueOffsetDistance;
                    break;
                case Direction::UP:    // From South (C)
                    queueStopY += queueOffsetDistance;
                    break;
                case Direction::LEFT:  // From East (B)
                    queueStopX += queueOffsetDistance;
                    break;
                case Direction::RIGHT: // From West (D)
                    queueStopX -= queueOffsetDistance;
                    break;
            }

            // Calculate direction and distance to queue position
            float dx = queueStopX - turnPosX;
            float dy = queueStopY - turnPosY;
            float distance = std::sqrt(dx*dx + dy*dy);

            // Adjust speed based on distance (decelerate as approaching)
            float adjustedSpeed = SPEED;
            if (distance < 50.0f) {
                // Slow down as approaching the stop position
                adjustedSpeed *= (distance / 50.0f) + 0.2f;
            }

            // Only move if far enough from target position (prevents jitter)
            if (distance > 2.0f) {
                // Normalize direction
                dx /= distance;
                dy /= distance;

                // Move toward queue position with adjusted speed
                turnPosX += dx * adjustedSpeed;
                turnPosY += dy * adjustedSpeed;

                // Update animation position
                animPos = (currentDirection == Direction::UP || currentDirection == Direction::DOWN) ?
                        turnPosY : turnPosX;
            }
        }
    }
}

void Vehicle::calculateTurnPath(float startX, float startY, float controlX, float controlY,
                              float endX, float endY, float progress) {
    // Quadratic bezier curve calculation for smooth turning
    float oneMinusT = 1.0f - progress;

    // Calculate position on the curve
    turnPosX = oneMinusT * oneMinusT * startX +
               2.0f * oneMinusT * progress * controlX +
               progress * progress * endX;

    turnPosY = oneMinusT * oneMinusT * startY +
               2.0f * oneMinusT * progress * controlY +
               progress * progress * endY;
}

void Vehicle::render(SDL_Renderer* renderer, SDL_Texture* vehicleTexture, int queuePos) {
    // Store queue position for use in update method
    this->queuePos = queuePos;

    // ENHANCED VEHICLE RENDERING FOR BETTER VISUALIZATION
    SDL_Color color;

    // STEP 1: Choose appropriate vehicle color based on lane and type
    if (isEmergency) {
        // Emergency vehicles are bright red
        color = {255, 0, 0, 255};
    }
    else {
        // Base color determined by lane and lane number
        switch (lane) {
            case 'A': // North road
                if (laneNumber == 1) {
                    color = {30, 144, 255, 255}; // Dodger Blue for A1
                } else if (laneNumber == 2) {
                    // AL2 is priority lane - orange
                    color = {255, 140, 0, 255}; // Orange for A2 (Priority)
                } else {
                    // Free lane - green
                    color = {50, 205, 50, 255}; // Lime Green for A3 (Free)
                }
                break;

            case 'B': // East road
                if (laneNumber == 1) {
                    color = {75, 0, 130, 255}; // Indigo for B1
                } else if (laneNumber == 2) {
                    color = {218, 165, 32, 255}; // Goldenrod for B2
                } else {
                    color = {34, 139, 34, 255}; // Forest Green for B3 (Free)
                }
                break;

            case 'C': // South road
                if (laneNumber == 1) {
                    color = {30, 144, 255, 255}; // Dodger Blue for C1
                } else if (laneNumber == 2) {
                    color = {210, 105, 30, 255}; // Chocolate for C2
                } else {
                    color = {60, 179, 113, 255}; // Medium Sea Green for C3 (Free)
                }
                break;

            case 'D': // West road
                if (laneNumber == 1) {
                    color = {138, 43, 226, 255}; // Blue Violet for D1
                } else if (laneNumber == 2) {
                    color = {205, 133, 63, 255}; // Peru for D2
                } else {
                    color = {46, 139, 87, 255}; // Sea Green for D3 (Free)
                }
                break;

            default:
                color = {150, 150, 150, 255}; // Grey default
                break;
        }
    }

    // Make vehicles brighter when turning for better visibility
    if (turning) {
        color.r = std::min(255, color.r + 40);
        color.g = std::min(255, color.g + 40);
        color.b = std::min(255, color.b + 40);
    }

    // Set color for vehicle body
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);

    // STEP 2: Determine vehicle dimensions - LARGER for better visibility
    float vehicleWidth = 12.0f;  // Wider than original
    float vehicleLength = 24.0f; // Longer than original

    // STEP 3: Create vehicle rectangle based on orientation
    SDL_FRect vehicleRect;

    if (turning) {
        // For turning vehicles, adjust dimensions gradually for smooth turns
        float progress = turnProgress;
        float width = vehicleWidth;
        float length = vehicleLength;

        // During turn, gradually change dimensions
        if (currentDirection == Direction::UP || currentDirection == Direction::DOWN) {
            // Transitioning from vertical to horizontal
            if (destination == Destination::LEFT || destination == Destination::RIGHT) {
                width = vehicleWidth * (1.0f - progress) + vehicleLength * progress;
                length = vehicleLength * (1.0f - progress) + vehicleWidth * progress;
            }
        } else {
            // Transitioning from horizontal to vertical
            if (destination == Destination::LEFT || destination == Destination::RIGHT) {
                width = vehicleLength * (1.0f - progress) + vehicleWidth * progress;
                length = vehicleWidth * (1.0f - progress) + vehicleLength * progress;
            }
        }

        vehicleRect = {turnPosX - width/2, turnPosY - length/2, width, length};
    } else {
        // Non-turning vehicles have fixed orientation based on direction
        switch (currentDirection) {
            case Direction::DOWN:
            case Direction::UP:
                // Vertical roads (taller than wide)
                vehicleRect = {turnPosX - vehicleWidth/2, turnPosY - vehicleLength/2, vehicleWidth, vehicleLength};
                break;
            case Direction::LEFT:
            case Direction::RIGHT:
                // Horizontal roads (wider than tall)
                vehicleRect = {turnPosX - vehicleLength/2, turnPosY - vehicleWidth/2, vehicleLength, vehicleWidth};
                break;
        }
    }

    // STEP 4: Draw the vehicle body with border
    SDL_RenderFillRect(renderer, &vehicleRect);

    // Add border outline for better definition
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // Black border
    SDL_RenderRect(renderer, &vehicleRect);

    // STEP 5: Draw destination indicator - VERY CLEAR directional arrows
    // This shows exactly where each vehicle is going - LEFT or STRAIGHT

    if (destination == Destination::LEFT) {
        // LEFT TURN indicator - arrow pointing left relative to vehicle direction
        SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255); // Bright yellow

        // Draw left arrow based on vehicle direction
        SDL_FPoint arrow[3];
        int arrowSize = 8; // Larger arrow for better visibility

        switch (currentDirection) {
            case Direction::DOWN: // From North (A)
                // Draw on left side of vehicle
                arrow[0] = {vehicleRect.x, vehicleRect.y + vehicleRect.h/3}; // Point
                arrow[1] = {vehicleRect.x + arrowSize, vehicleRect.y + vehicleRect.h/3 - arrowSize/2}; // Top
                arrow[2] = {vehicleRect.x + arrowSize, vehicleRect.y + vehicleRect.h/3 + arrowSize/2}; // Bottom
                break;

            case Direction::UP: // From South (C)
                // Draw on right side of vehicle
                arrow[0] = {vehicleRect.x + vehicleRect.w, vehicleRect.y + vehicleRect.h*2/3};
                arrow[1] = {vehicleRect.x + vehicleRect.w - arrowSize, vehicleRect.y + vehicleRect.h*2/3 - arrowSize/2};
                arrow[2] = {vehicleRect.x + vehicleRect.w - arrowSize, vehicleRect.y + vehicleRect.h*2/3 + arrowSize/2};
                break;

            case Direction::LEFT: // From East (B)
                // Draw on left side of vehicle
                arrow[0] = {vehicleRect.x + vehicleRect.w/3, vehicleRect.y};
                arrow[1] = {vehicleRect.x + vehicleRect.w/3 - arrowSize/2, vehicleRect.y + arrowSize};
                arrow[2] = {vehicleRect.x + vehicleRect.w/3 + arrowSize/2, vehicleRect.y + arrowSize};
                break;

            case Direction::RIGHT: // From West (D)
                // Draw on right side of vehicle
                arrow[0] = {vehicleRect.x + vehicleRect.w*2/3, vehicleRect.y + vehicleRect.h};
                arrow[1] = {vehicleRect.x + vehicleRect.w*2/3 - arrowSize/2, vehicleRect.y + vehicleRect.h - arrowSize};
                arrow[2] = {vehicleRect.x + vehicleRect.w*2/3 + arrowSize/2, vehicleRect.y + vehicleRect.h - arrowSize};
                break;
        }

        // Draw triangle
        SDL_RenderFillTriangleF(renderer, arrow[0].x, arrow[0].y, arrow[1].x, arrow[1].y, arrow[2].x, arrow[2].y);
    }
    else if (destination == Destination::STRAIGHT) {
        // STRAIGHT indicator - double parallel lines
        SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255); // Bright yellow

        SDL_FRect line1, line2;
        float lineWidth = 2.5f;
        float lineLength = 8.0f;
        float lineGap = 4.0f;

        switch (currentDirection) {
            case Direction::DOWN:
                // Two vertical lines on top part of vehicle
                line1 = {vehicleRect.x + vehicleRect.w*0.33f, vehicleRect.y + 5.0f, lineWidth, lineLength};
                line2 = {vehicleRect.x + vehicleRect.w*0.67f, vehicleRect.y + 5.0f, lineWidth, lineLength};
                break;

            case Direction::UP:
                // Two vertical lines on bottom part of vehicle
                line1 = {vehicleRect.x + vehicleRect.w*0.33f, vehicleRect.y + vehicleRect.h - lineLength - 5.0f, lineWidth, lineLength};
                line2 = {vehicleRect.x + vehicleRect.w*0.67f, vehicleRect.y + vehicleRect.h - lineLength - 5.0f, lineWidth, lineLength};
                break;

            case Direction::LEFT:
                // Two horizontal lines on right part of vehicle
                line1 = {vehicleRect.x + vehicleRect.w - lineLength - 5.0f, vehicleRect.y + vehicleRect.h*0.33f, lineLength, lineWidth};
                line2 = {vehicleRect.x + vehicleRect.w - lineLength - 5.0f, vehicleRect.y + vehicleRect.h*0.67f, lineLength, lineWidth};
                break;

            case Direction::RIGHT:
                // Two horizontal lines on left part of vehicle
                line1 = {vehicleRect.x + 5.0f, vehicleRect.y + vehicleRect.h*0.33f, lineLength, lineWidth};
                line2 = {vehicleRect.x + 5.0f, vehicleRect.y + vehicleRect.h*0.67f, lineLength, lineWidth};
                break;
        }

        SDL_RenderFillRect(renderer, &line1);
        SDL_RenderFillRect(renderer, &line2);
    }

    // STEP 6: Add lane number indicators as distinctive marks
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255); // White for indicators

    float dotSize = 4.0f; // Larger dots
    float dotSpacing = 6.0f;

    // Draw dots corresponding to lane number
    for (int i = 0; i < laneNumber; i++) {
        SDL_FRect dot;

        // Position depends on vehicle orientation
        switch (currentDirection) {
            case Direction::DOWN:
                dot = {
                    vehicleRect.x + vehicleRect.w/2 - dotSize/2,
                    vehicleRect.y + vehicleRect.h - 10.0f - i * dotSpacing,
                    dotSize,
                    dotSize
                };
                break;

            case Direction::UP:
                dot = {
                    vehicleRect.x + vehicleRect.w/2 - dotSize/2,
                    vehicleRect.y + 10.0f + i * dotSpacing,
                    dotSize,
                    dotSize
                };
                break;

            case Direction::LEFT:
                dot = {
                    vehicleRect.x + 10.0f + i * dotSpacing,
                    vehicleRect.y + vehicleRect.h/2 - dotSize/2,
                    dotSize,
                    dotSize
                };
                break;

            case Direction::RIGHT:
                dot = {
                    vehicleRect.x + vehicleRect.w - 10.0f - i * dotSpacing,
                    vehicleRect.y + vehicleRect.h/2 - dotSize/2,
                    dotSize,
                    dotSize
                };
                break;
        }

        SDL_RenderFillRect(renderer, &dot);
    }

    // STEP 7: Emergency vehicle indicators (if applicable)
    if (isEmergency) {
        // Draw a cross symbol for emergency vehicles
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255); // White

        float crossSize = 8.0f;
        SDL_FRect crossV, crossH;

        crossH = {turnPosX - crossSize/2, turnPosY - 1.5f, crossSize, 3.0f};
        crossV = {turnPosX - 1.5f, turnPosY - crossSize/2, 3.0f, crossSize};

        SDL_RenderFillRect(renderer, &crossH);
        SDL_RenderFillRect(renderer, &crossV);
    }
}

// Helper for drawing triangles (SDL3 compatible)
void Vehicle::SDL_RenderFillTriangleF(SDL_Renderer* renderer, float x1, float y1, float x2, float y2, float x3, float y3) {
    // Create vertices for rendering with SDL_RenderGeometry
    SDL_Vertex vertices[3];

    // Create color with normalized values (0.0-1.0)
    SDL_FColor fcolor = {
        1.0f,  // r (normalized to 0.0-1.0)
        1.0f,  // g
        1.0f,  // b
        1.0f   // a
    };

    // Set vertices
    vertices[0].position.x = x1;
    vertices[0].position.y = y1;
    vertices[0].color = fcolor;

    vertices[1].position.x = x2;
    vertices[1].position.y = y2;
    vertices[1].color = fcolor;

    vertices[2].position.x = x3;
    vertices[2].position.y = y3;
    vertices[2].color = fcolor;

    // Draw the triangle
    SDL_RenderGeometry(renderer, NULL, vertices, 3, NULL, 0);
}


//===== END FILE: {file_path} =====//

//===== FILE: src/core/Lane.cpp =====//

// FILE: src/core/Lane.cpp
#include "core/Lane.h"
#include "utils/DebugLogger.h"
#include <sstream>
#include "core/Constants.h"

Lane::Lane(char laneId, int laneNumber)
    : laneId(laneId),
      laneNumber(laneNumber),
      isPriority(laneId == 'A' && laneNumber == 2), // AL2 is the priority lane
      priority(0) {

    std::ostringstream oss;
    oss << "Created lane " << laneId << laneNumber;
    DebugLogger::log(oss.str());
}

Lane::~Lane() {
    // Clean up vehicles
    while (!vehicleQueue.isEmpty()) {
        Vehicle* vehicle = vehicleQueue.dequeue();
        delete vehicle;
    }
}

void Lane::enqueue(Vehicle* vehicle) {
    if (!vehicle) {
        DebugLogger::log("Attempted to enqueue null vehicle", DebugLogger::LogLevel::ERROR);
        return;
    }

    vehicleQueue.enqueue(vehicle);
    int currentCount = vehicleQueue.size();

    // Log the action
    std::ostringstream oss;
    oss << "Vehicle " << vehicle->getId() << " added to lane " << laneId << laneNumber;
    DebugLogger::log(oss.str());

    // Update priority if this is the priority lane
    if (isPriority) {
        if (currentCount > Constants::PRIORITY_THRESHOLD_HIGH) {
            priority = 100; // High priority
            std::ostringstream priorityOss;
            priorityOss << "Lane " << laneId << laneNumber
                << " priority increased (vehicles: " << currentCount << ")";
            DebugLogger::log(priorityOss.str());
        }
        else if (currentCount < Constants::PRIORITY_THRESHOLD_LOW) {
            priority = 0; // Normal priority
            std::ostringstream priorityOss;
            priorityOss << "Lane " << laneId << laneNumber
                << " priority reset to normal (vehicles: " << currentCount << ")";
            DebugLogger::log(priorityOss.str());
        }
    }
}

Vehicle* Lane::dequeue() {
    if (vehicleQueue.isEmpty()) {
        return nullptr;
    }

    Vehicle* vehicle = vehicleQueue.dequeue();
    int currentCount = vehicleQueue.size();

    // Log the action
    std::ostringstream oss;
    oss << "Vehicle " << vehicle->getId() << " removed from lane " << laneId << laneNumber;
    DebugLogger::log(oss.str());

    // Update priority if this is the priority lane
    if (isPriority) {
        if (currentCount < Constants::PRIORITY_THRESHOLD_LOW && priority > 0) {
            priority = 0; // Normal priority
            std::ostringstream priorityOss;
            priorityOss << "Lane " << laneId << laneNumber
                << " priority reset to normal (vehicles: " << currentCount << ")";
            DebugLogger::log(priorityOss.str());
        }
    }

    return vehicle;
}

Vehicle* Lane::peek() const {
    if (vehicleQueue.isEmpty()) {
        return nullptr;
    }

    return vehicleQueue.peek();
}

bool Lane::isEmpty() const {
    return vehicleQueue.isEmpty();
}

int Lane::getVehicleCount() const {
    return vehicleQueue.size();
}

const std::vector<Vehicle*>& Lane::getVehicles() const {
    // Get all elements from the queue for rendering
    return vehicleQueue.getAllElements();
}

int Lane::getPriority() const {
    return priority;
}

void Lane::updatePriority() {
    int count = vehicleQueue.size();

    // Update priority based on vehicle count for AL2 lane
    if (isPriority) {
        if (count > Constants::PRIORITY_THRESHOLD_HIGH && priority == 0) {
            priority = 100; // High priority
            std::ostringstream oss;
            oss << "Lane " << laneId << laneNumber
                << " priority increased (vehicles: " << count << ")";
            DebugLogger::log(oss.str());
        }
        else if (count < Constants::PRIORITY_THRESHOLD_LOW && priority > 0) {
            priority = 0; // Normal priority
            std::ostringstream oss;
            oss << "Lane " << laneId << laneNumber
                << " priority reset to normal (vehicles: " << count << ")";
            DebugLogger::log(oss.str());
        }
    }
}

bool Lane::isPriorityLane() const {
    return isPriority;
}

char Lane::getLaneId() const {
    return laneId;
}

int Lane::getLaneNumber() const {
    return laneNumber;
}

std::string Lane::getName() const {
    std::string name;
    name += laneId;
    name += std::to_string(laneNumber);
    return name;
}


//===== END FILE: {file_path} =====//

//===== FILE: src/core/TrafficLight.cpp =====//

// FILE: src/core/TrafficLight.cpp
#include "core/TrafficLight.h"
#include "utils/DebugLogger.h"
#include <sstream>
#include <cmath>
#include <SDL3/SDL.h>
#include "core/Constants.h"

TrafficLight::TrafficLight()
    : currentState(State::ALL_RED),
      nextState(State::A_GREEN),
      lastStateChangeTime(SDL_GetTicks()),
      isPriorityMode(false),
      shouldResumeNormalMode(false) {

    DebugLogger::log("TrafficLight initialized");
}

TrafficLight::~TrafficLight() {
    DebugLogger::log("TrafficLight destroyed");
}

void TrafficLight::update(const std::vector<Lane*>& lanes) {
    uint32_t currentTime = SDL_GetTicks();
    uint32_t elapsedTime = currentTime - lastStateChangeTime;

    // Find AL2 lane to check priority
    Lane* al2Lane = nullptr;
    for (auto* lane : lanes) {
        if (lane->getLaneId() == 'A' && lane->getLaneNumber() == 2) {
            al2Lane = lane;
            break;
        }
    }

    // Check priority conditions with improved threshold handling
    if (al2Lane) {
        int vehicleCount = al2Lane->getVehicleCount();

        // Enter priority mode when vehicles > PRIORITY_THRESHOLD_HIGH
        if (!isPriorityMode && vehicleCount > Constants::PRIORITY_THRESHOLD_HIGH) {
            isPriorityMode = true;
            std::ostringstream oss;
            oss << "PRIORITY MODE ACTIVATED: A2 has " << vehicleCount << " vehicles";
            DebugLogger::log(oss.str(), DebugLogger::LogLevel::INFO);

            // Force transition to A_GREEN via ALL_RED if not already on A
            if (currentState != State::A_GREEN) {
                nextState = State::ALL_RED;
                // Force state change immediately if already at ALL_RED
                if (currentState == State::ALL_RED) {
                    lastStateChangeTime = 0; // Force duration elapsed
                }
            }
        }
        // Exit priority mode only when vehicles < PRIORITY_THRESHOLD_LOW
        else if (isPriorityMode && vehicleCount < Constants::PRIORITY_THRESHOLD_LOW) {
            shouldResumeNormalMode = true;
            std::ostringstream oss;
            oss << "PRIORITY MODE DEACTIVATED: A2 now has " << vehicleCount << " vehicles";
            DebugLogger::log(oss.str(), DebugLogger::LogLevel::INFO);
        }
    }

    // Calculate appropriate duration based on assignment formula
    int stateDuration;
    if (currentState == State::ALL_RED) {
        stateDuration = allRedDuration; // 2 seconds for ALL_RED
    } else {
        // Calculate average using lane counts
        float averageVehicleCount = calculateAverageVehicleCount(lanes);

        // Set duration using formula: Total time = |V| * t (2 seconds per vehicle)
        stateDuration = static_cast<int>(averageVehicleCount * 2000);

        // Apply minimum and maximum limits for reasonable times
        if (stateDuration < 3000) stateDuration = 3000; // Min 3 seconds
        if (stateDuration > 15000) stateDuration = 15000; // Max 15 seconds

        // Log the calculation
        std::ostringstream oss;
        oss << "Traffic light timing: |V| = " << averageVehicleCount
            << ", Duration = " << stateDuration / 1000.0f << " seconds";
        DebugLogger::log(oss.str());
    }

    // State transition with improved priority handling
    if (elapsedTime >= stateDuration) {
        // Change to next state
        currentState = nextState;

        // Handle priority mode properly
        if (isPriorityMode && !shouldResumeNormalMode) {
            // In priority mode: alternate between A_GREEN and ALL_RED only
            if (currentState == State::ALL_RED) {
                nextState = State::A_GREEN;
            } else {
                nextState = State::ALL_RED;
            }
        } else {
            // Exit priority mode if needed
            if (shouldResumeNormalMode) {
                isPriorityMode = false;
                shouldResumeNormalMode = false;
                DebugLogger::log("Resuming normal traffic light sequence");
            }

            // Normal rotation pattern: ALL_RED → A → ALL_RED → B → ALL_RED → C → ALL_RED → D → ...
            if (currentState == State::ALL_RED) {
                // Cycle through green states
                switch (nextState) {
                    case State::A_GREEN: nextState = State::B_GREEN; break;
                    case State::B_GREEN: nextState = State::C_GREEN; break;
                    case State::C_GREEN: nextState = State::D_GREEN; break;
                    case State::D_GREEN: nextState = State::A_GREEN; break;
                    default: nextState = State::A_GREEN; break;
                }
            } else {
                // Always go to ALL_RED after any green state
                nextState = State::ALL_RED;
            }
        }

        // Log state change clearly
        std::string stateStr;
        switch (currentState) {
            case State::ALL_RED: stateStr = "ALL_RED"; break;
            case State::A_GREEN: stateStr = "A_GREEN"; break;
            case State::B_GREEN: stateStr = "B_GREEN"; break;
            case State::C_GREEN: stateStr = "C_GREEN"; break;
            case State::D_GREEN: stateStr = "D_GREEN"; break;
        }

        std::ostringstream oss;
        oss << "Traffic light changed to: " << stateStr
            << (isPriorityMode ? " (PRIORITY MODE)" : "");
        DebugLogger::log(oss.str());

        lastStateChangeTime = currentTime;
    }
}

// Calculate average vehicle count with proper formula
float TrafficLight::calculateAverageVehicleCount(const std::vector<Lane*>& lanes) {
    int normalLaneCount = 0;
    int totalVehicleCount = 0;

    for (auto* lane : lanes) {
        // Only count lane 2 (normal lanes)
        // In priority mode, exclude the priority lane (A2) from calculation
        if (lane->getLaneNumber() == 2 &&
            !(isPriorityMode && lane->getLaneId() == 'A')) {
            normalLaneCount++;
            totalVehicleCount += lane->getVehicleCount();
        }
    }

    // Calculate average: |V| = (1/n) * Σ|Li|
    float average = (normalLaneCount > 0) ?
        static_cast<float>(totalVehicleCount) / normalLaneCount : 0.0f;

    // Return at least 1 to ensure some duration
    return std::max(1.0f, average);
}

void TrafficLight::setNextState(State state) {
    nextState = state;
}

bool TrafficLight::isGreen(char lane) const {
    switch (lane) {
        case 'A': return currentState == State::A_GREEN;
        case 'B': return currentState == State::B_GREEN;
        case 'C': return currentState == State::C_GREEN;
        case 'D': return currentState == State::D_GREEN;
        default: return false;
    }
}

// ENHANCED RENDERING METHODS

void TrafficLight::render(SDL_Renderer* renderer) {
    // Draw improved traffic light for each road with clearer visuals
    drawLightForA(renderer, !isGreen('A'));
    drawLightForB(renderer, !isGreen('B'));
    drawLightForC(renderer, !isGreen('C'));
    drawLightForD(renderer, !isGreen('D'));

    // Enhanced priority mode indicator
    if (isPriorityMode) {
        // Draw flashing priority mode indicator
        uint32_t currentTime = SDL_GetTicks();
        bool flashOn = (currentTime / 500) % 2 == 0; // Flash every 500ms

        if (flashOn) {
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255); // Orange
        } else {
            SDL_SetRenderDrawColor(renderer, 255, 100, 0, 200); // Darker orange
        }

        SDL_FRect priorityIndicator = {10, 10, 30, 30};
        SDL_RenderFillRect(renderer, &priorityIndicator);

        // Black border
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderRect(renderer, &priorityIndicator);

        // Add "P" to the indicator
        SDL_FRect vertLine = {20, 15, 3, 20};
        SDL_FRect horizLine1 = {20, 15, 10, 3};
        SDL_FRect horizLine2 = {20, 22, 8, 3};

        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderFillRect(renderer, &vertLine);
        SDL_RenderFillRect(renderer, &horizLine1);
        SDL_RenderFillRect(renderer, &horizLine2);
    }
}

void TrafficLight::drawLightForA(SDL_Renderer* renderer, bool isRed) {
    const int LIGHT_SIZE = 20;
    const int LIGHT_BOX_WIDTH = 40;
    const int LIGHT_BOX_HEIGHT = 80;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 800;
    const int ARROW_SIZE = 10;

    // Position for road A - move slightly for better visibility
    int x = WINDOW_WIDTH/2 + 40;
    int y = WINDOW_HEIGHT/2 - 120;

    // Enhanced traffic light box with 3D effect
    // Shadow
    SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255);
    SDL_FRect shadowBox = {(float)x + 3, (float)y + 3, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &shadowBox);

    // Main box (dark gray)
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 255);
    SDL_FRect lightBox = {(float)x, (float)y, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &lightBox);

    // Highlight edge
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_FRect highlight = {(float)x, (float)y, LIGHT_BOX_WIDTH, 2.0f};
    SDL_RenderFillRect(renderer, &highlight);
    SDL_FRect highlightSide = {(float)x, (float)y, 2.0f, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &highlightSide);

    // Black border
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &lightBox);

    // Red light with glow effect
    if (isRed) {
        // Glow
        SDL_SetRenderDrawColor(renderer, 150, 0, 0, 100);
        SDL_FRect redGlow = {(float)(x + LIGHT_BOX_WIDTH/2 - LIGHT_SIZE/2 - 3), (float)(y + 10 - 3),
                             LIGHT_SIZE + 6, LIGHT_SIZE + 6};
        SDL_RenderFillRect(renderer, &redGlow);
    }

    SDL_SetRenderDrawColor(renderer, isRed ? 255 : 50, 0, 0, 255);
    SDL_FRect redLight = {(float)(x + LIGHT_BOX_WIDTH/2 - LIGHT_SIZE/2), (float)(y + 10),
                         LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &redLight);

    // Green light with glow effect
    if (!isRed) {
        // Glow
        SDL_SetRenderDrawColor(renderer, 0, 150, 0, 100);
        SDL_FRect greenGlow = {(float)(x + LIGHT_BOX_WIDTH/2 - LIGHT_SIZE/2 - 3), (float)(y + 40 - 3),
                              LIGHT_SIZE + 6, LIGHT_SIZE + 6};
        SDL_RenderFillRect(renderer, &greenGlow);
    }

    SDL_SetRenderDrawColor(renderer, 0, isRed ? 50 : 255, 0, 255);
    SDL_FRect greenLight = {(float)(x + LIGHT_BOX_WIDTH/2 - LIGHT_SIZE/2), (float)(y + 40),
                           LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &greenLight);

    // Add straight arrow for green light
    if (!isRed) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

        // Draw arrow shape
        SDL_FRect arrowStem = {(float)(x + LIGHT_BOX_WIDTH/2 - 2), (float)(y + 50 - ARROW_SIZE/2),
                              4.0f, (float)ARROW_SIZE};
        SDL_RenderFillRect(renderer, &arrowStem);

        // Arrow head (triangle)
        SDL_Vertex vertices[3];
        SDL_FColor white = {1.0f, 1.0f, 1.0f, 1.0f};

        vertices[0].position.x = x + LIGHT_BOX_WIDTH/2;
        vertices[0].position.y = y + 50 - ARROW_SIZE/2 - 5;
        vertices[0].color = white;

        vertices[1].position.x = x + LIGHT_BOX_WIDTH/2 - 5;
        vertices[1].position.y = y + 50 - ARROW_SIZE/2;
        vertices[1].color = white;

        vertices[2].position.x = x + LIGHT_BOX_WIDTH/2 + 5;
        vertices[2].position.y = y + 50 - ARROW_SIZE/2;
        vertices[2].color = white;

        SDL_RenderGeometry(renderer, NULL, vertices, 3, NULL, 0);
    }

    // Black borders around lights
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}

void TrafficLight::drawLightForB(SDL_Renderer* renderer, bool isRed) {
    const int LIGHT_SIZE = 20;
    const int LIGHT_BOX_WIDTH = 80;
    const int LIGHT_BOX_HEIGHT = 40;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 800;
    const int ARROW_SIZE = 10;

    // Position for road B
    int x = WINDOW_WIDTH/2 - 60;
    int y = WINDOW_HEIGHT/2 + 40;

    // Enhanced traffic light box with 3D effect
    // Shadow
    SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255);
    SDL_FRect shadowBox = {(float)x + 3, (float)y + 3, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &shadowBox);

    // Main box (dark gray)
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 255);
    SDL_FRect lightBox = {(float)x, (float)y, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &lightBox);

    // Highlight edge
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_FRect highlight = {(float)x, (float)y, LIGHT_BOX_WIDTH, 2.0f};
    SDL_RenderFillRect(renderer, &highlight);
    SDL_FRect highlightSide = {(float)x, (float)y, 2.0f, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &highlightSide);

    // Black border
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &lightBox);

    // Red light with glow effect
    if (isRed) {
        // Glow
        SDL_SetRenderDrawColor(renderer, 150, 0, 0, 100);
        SDL_FRect redGlow = {(float)(x + 10 - 3), (float)(y + LIGHT_BOX_HEIGHT/2 - LIGHT_SIZE/2 - 3),
                            LIGHT_SIZE + 6, LIGHT_SIZE + 6};
        SDL_RenderFillRect(renderer, &redGlow);
    }

    SDL_SetRenderDrawColor(renderer, isRed ? 255 : 50, 0, 0, 255);
    SDL_FRect redLight = {(float)(x + 10), (float)(y + LIGHT_BOX_HEIGHT/2 - LIGHT_SIZE/2),
                         LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &redLight);

    // Green light with glow effect
    if (!isRed) {
        // Glow
        SDL_SetRenderDrawColor(renderer, 0, 150, 0, 100);
        SDL_FRect greenGlow = {(float)(x + 40 - 3), (float)(y + LIGHT_BOX_HEIGHT/2 - LIGHT_SIZE/2 - 3),
                              LIGHT_SIZE + 6, LIGHT_SIZE + 6};
        SDL_RenderFillRect(renderer, &greenGlow);
    }

    SDL_SetRenderDrawColor(renderer, 0, isRed ? 50 : 255, 0, 255);
    SDL_FRect greenLight = {(float)(x + 40), (float)(y + LIGHT_BOX_HEIGHT/2 - LIGHT_SIZE/2),
                           LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &greenLight);

    // Add straight arrow for green light
    if (!isRed) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

        // Draw arrow shape (horizontal)
        SDL_FRect arrowStem = {(float)(x + 50 - ARROW_SIZE/2), (float)(y + LIGHT_BOX_HEIGHT/2 - 2),
                              (float)ARROW_SIZE, 4.0f};
        SDL_RenderFillRect(renderer, &arrowStem);

        // Arrow head (triangle)
        SDL_Vertex vertices[3];
        SDL_FColor white = {1.0f, 1.0f, 1.0f, 1.0f};

        vertices[0].position.x = x + 50 - ARROW_SIZE/2 - 5;
        vertices[0].position.y = y + LIGHT_BOX_HEIGHT/2;
        vertices[0].color = white;

        vertices[1].position.x = x + 50 - ARROW_SIZE/2;
        vertices[1].position.y = y + LIGHT_BOX_HEIGHT/2 - 5;
        vertices[1].color = white;

        vertices[2].position.x = x + 50 - ARROW_SIZE/2;
        vertices[2].position.y = y + LIGHT_BOX_HEIGHT/2 + 5;
        vertices[2].color = white;

        SDL_RenderGeometry(renderer, NULL, vertices, 3, NULL, 0);
    }

    // Black borders around lights
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}

void TrafficLight::drawLightForC(SDL_Renderer* renderer, bool isRed) {
    const int LIGHT_SIZE = 20;
    const int LIGHT_BOX_WIDTH = 40;
    const int LIGHT_BOX_HEIGHT = 80;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 800;
    const int ARROW_SIZE = 10;

    // Position for road C - move slightly for better visibility
    int x = WINDOW_WIDTH/2 - 80;
    int y = WINDOW_HEIGHT/2 + 40;

    // Enhanced traffic light box with 3D effect
    // Shadow
    SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255);
    SDL_FRect shadowBox = {(float)x + 3, (float)y + 3, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &shadowBox);

    // Main box (dark gray)
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 255);
    SDL_FRect lightBox = {(float)x, (float)y, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &lightBox);

    // Highlight edge
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_FRect highlight = {(float)x, (float)y, LIGHT_BOX_WIDTH, 2.0f};
    SDL_RenderFillRect(renderer, &highlight);
    SDL_FRect highlightSide = {(float)x, (float)y, 2.0f, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &highlightSide);

    // Black border
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &lightBox);

    // Red light with glow effect
    if (isRed) {
        // Glow
        SDL_SetRenderDrawColor(renderer, 150, 0, 0, 100);
        SDL_FRect redGlow = {(float)(x + LIGHT_BOX_WIDTH/2 - LIGHT_SIZE/2 - 3), (float)(y + 10 - 3),
                             LIGHT_SIZE + 6, LIGHT_SIZE + 6};
        SDL_RenderFillRect(renderer, &redGlow);
    }

    SDL_SetRenderDrawColor(renderer, isRed ? 255 : 50, 0, 0, 255);
    SDL_FRect redLight = {(float)(x + LIGHT_BOX_WIDTH/2 - LIGHT_SIZE/2), (float)(y + 10),
                         LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &redLight);

    // Green light with glow effect
    if (!isRed) {
        // Glow
        SDL_SetRenderDrawColor(renderer, 0, 150, 0, 100);
        SDL_FRect greenGlow = {(float)(x + LIGHT_BOX_WIDTH/2 - LIGHT_SIZE/2 - 3), (float)(y + 40 - 3),
                              LIGHT_SIZE + 6, LIGHT_SIZE + 6};
        SDL_RenderFillRect(renderer, &greenGlow);
    }

    SDL_SetRenderDrawColor(renderer, 0, isRed ? 50 : 255, 0, 255);
    SDL_FRect greenLight = {(float)(x + LIGHT_BOX_WIDTH/2 - LIGHT_SIZE/2), (float)(y + 40),
                           LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &greenLight);

    // Add straight arrow for green light (pointing upward)
    if (!isRed) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

        // Draw arrow shape
        SDL_FRect arrowStem = {(float)(x + LIGHT_BOX_WIDTH/2 - 2), (float)(y + 50 - ARROW_SIZE/2),
                              4.0f, (float)ARROW_SIZE};
        SDL_RenderFillRect(renderer, &arrowStem);

        // Arrow head (triangle)
        SDL_Vertex vertices[3];
        SDL_FColor white = {1.0f, 1.0f, 1.0f, 1.0f};

        vertices[0].position.x = x + LIGHT_BOX_WIDTH/2;
        vertices[0].position.y = y + 50 - ARROW_SIZE/2 - 5;
        vertices[0].color = white;

        vertices[1].position.x = x + LIGHT_BOX_WIDTH/2 - 5;
        vertices[1].position.y = y + 50 - ARROW_SIZE/2;
        vertices[1].color = white;

        vertices[2].position.x = x + LIGHT_BOX_WIDTH/2 + 5;
        vertices[2].position.y = y + 50 - ARROW_SIZE/2;
        vertices[2].color = white;

        SDL_RenderGeometry(renderer, NULL, vertices, 3, NULL, 0);
    }

    // Black borders around lights
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}

void TrafficLight::drawLightForD(SDL_Renderer* renderer, bool isRed) {
    const int LIGHT_SIZE = 20;
    const int LIGHT_BOX_WIDTH = 80;
    const int LIGHT_BOX_HEIGHT = 40;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 800;
    const int ARROW_SIZE = 10;

    // Position for road D
    int x = WINDOW_WIDTH/2 - 120;
    int y = WINDOW_HEIGHT/2 - 80;

    // Enhanced traffic light box with 3D effect
    // Shadow
    SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255);
    SDL_FRect shadowBox = {(float)x + 3, (float)y + 3, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &shadowBox);

    // Main box (dark gray)
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 255);
    SDL_FRect lightBox = {(float)x, (float)y, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &lightBox);

    // Highlight edge
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
    SDL_FRect highlight = {(float)x, (float)y, LIGHT_BOX_WIDTH, 2.0f};
    SDL_RenderFillRect(renderer, &highlight);
    SDL_FRect highlightSide = {(float)x, (float)y, 2.0f, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &highlightSide);

    // Black border
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &lightBox);

    // Red light with glow effect
    if (isRed) {
        // Glow
        SDL_SetRenderDrawColor(renderer, 150, 0, 0, 100);
        SDL_FRect redGlow = {(float)(x + 10 - 3), (float)(y + LIGHT_BOX_HEIGHT/2 - LIGHT_SIZE/2 - 3),
                            LIGHT_SIZE + 6, LIGHT_SIZE + 6};
        SDL_RenderFillRect(renderer, &redGlow);
    }

    SDL_SetRenderDrawColor(renderer, isRed ? 255 : 50, 0, 0, 255);
    SDL_FRect redLight = {(float)(x + 10), (float)(y + LIGHT_BOX_HEIGHT/2 - LIGHT_SIZE/2),
                         LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &redLight);

    // Green light with glow effect
    if (!isRed) {
        // Glow
        SDL_SetRenderDrawColor(renderer, 0, 150, 0, 100);
        SDL_FRect greenGlow = {(float)(x + 40 - 3), (float)(y + LIGHT_BOX_HEIGHT/2 - LIGHT_SIZE/2 - 3),
                              LIGHT_SIZE + 6, LIGHT_SIZE + 6};
        SDL_RenderFillRect(renderer, &greenGlow);
    }

    SDL_SetRenderDrawColor(renderer, 0, isRed ? 50 : 255, 0, 255);
    SDL_FRect greenLight = {(float)(x + 40), (float)(y + LIGHT_BOX_HEIGHT/2 - LIGHT_SIZE/2),
                           LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &greenLight);

    // Add straight arrow for green light (horizontal pointing right)
    if (!isRed) {
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

        // Draw arrow shape
        SDL_FRect arrowStem = {(float)(x + 50 - ARROW_SIZE/2), (float)(y + LIGHT_BOX_HEIGHT/2 - 2),
                              (float)ARROW_SIZE, 4.0f};
        SDL_RenderFillRect(renderer, &arrowStem);

        // Arrow head (triangle)
        SDL_Vertex vertices[3];
        SDL_FColor white = {1.0f, 1.0f, 1.0f, 1.0f};

        vertices[0].position.x = x + 50 + ARROW_SIZE/2 + 5;
        vertices[0].position.y = y + LIGHT_BOX_HEIGHT/2;
        vertices[0].color = white;

        vertices[1].position.x = x + 50 + ARROW_SIZE/2;
        vertices[1].position.y = y + LIGHT_BOX_HEIGHT/2 - 5;
        vertices[1].color = white;

        vertices[2].position.x = x + 50 + ARROW_SIZE/2;
        vertices[2].position.y = y + LIGHT_BOX_HEIGHT/2 + 5;
        vertices[2].color = white;

        SDL_RenderGeometry(renderer, NULL, vertices, 3, NULL, 0);
    }

    // Black borders around lights
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}


//===== END FILE: {file_path} =====//

//===== FILE: src/managers/FileHandler.cpp =====//

// FILE: src/managers/FileHandler.cpp
#include "managers/FileHandler.h"
#include "utils/DebugLogger.h"
#include <fstream>
#include <sstream>
#include <filesystem>
#include <thread>
#include <chrono>

namespace fs = std::filesystem;

FileHandler::FileHandler(const std::string& dataPath)
    : dataPath(dataPath) {

    DebugLogger::log("FileHandler created with path: " + dataPath);
}

FileHandler::~FileHandler() {
    DebugLogger::log("FileHandler destroyed");
}

std::vector<Vehicle*> FileHandler::readVehiclesFromFiles() {
    std::lock_guard<std::mutex> lock(mutex);
    std::vector<Vehicle*> vehicles;

    // Ensure directory exists before trying to read
    if (!fs::exists(dataPath)) {
        DebugLogger::log("Data path doesn't exist: " + dataPath, DebugLogger::LogLevel::WARNING);
        return vehicles;
    }

    // Read from each lane file (A, B, C, D)
    for (char laneId : {'A', 'B', 'C', 'D'}) {
        std::string filePath = getLaneFilePath(laneId);

        // Only try to read if file exists
        if (fs::exists(filePath)) {
            auto laneVehicles = readVehiclesFromFile(laneId);
            vehicles.insert(vehicles.end(), laneVehicles.begin(), laneVehicles.end());
        }
    }

    // If we found any vehicles, log the total
    if (!vehicles.empty()) {
        std::ostringstream oss;
        oss << "Read " << vehicles.size() << " vehicles from lane files";
        DebugLogger::log(oss.str());
    }

    return vehicles;
}

std::vector<Vehicle*> FileHandler::readVehiclesFromFile(char laneId) {
    std::vector<Vehicle*> vehicles;
    std::string filePath = getLaneFilePath(laneId);

    // Multiple attempts to open file (addresses file locking issues)
    std::ifstream file;
    int attempts = 0;
    while (attempts < 3) {
        file.open(filePath);
        if (file.is_open()) {
            break;
        }
        // Wait and retry if file is locked
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        attempts++;
    }

    if (!file.is_open()) {
        return vehicles;
    }

    std::vector<std::string> lines;
    std::string line;

    // Read all lines from file
    while (std::getline(file, line)) {
        if (!line.empty()) {
            lines.push_back(line);
        }
    }
    file.close();

    // Don't modify file if no lines were read
    if (lines.empty()) {
        return vehicles;
    }

    // Process lines first before clearing file (prevents data loss if parsing fails)
    std::vector<Vehicle*> parsedVehicles;
    for (const auto& line : lines) {
        Vehicle* vehicle = parseVehicleLine(line);
        if (vehicle) {
            parsedVehicles.push_back(vehicle);
        }
    }

    // Clear the file after reading to prevent duplicates - with error handling
    bool fileClearedSuccessfully = false;
    attempts = 0;
    while (!fileClearedSuccessfully && attempts < 3) {
        try {
            std::ofstream clearFile(filePath, std::ios::trunc);
            if (clearFile.is_open()) {
                clearFile.close();
                fileClearedSuccessfully = true;
            } else {
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
                attempts++;
            }
        } catch (const std::exception& e) {
            DebugLogger::log("Error clearing file: " + std::string(e.what()), DebugLogger::LogLevel::ERROR);
            attempts++;
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    }

    if (!fileClearedSuccessfully) {
        DebugLogger::log("Failed to clear file after reading: " + filePath, DebugLogger::LogLevel::ERROR);
    }

    // Log number of vehicles read
    if (!parsedVehicles.empty()) {
        std::ostringstream oss;
        oss << "Read " << parsedVehicles.size() << " vehicles from lane " << laneId;
        DebugLogger::log(oss.str());
    }

    return parsedVehicles;
}

Vehicle* FileHandler::parseVehicleLine(const std::string& line) {
    // Expected formats:
    // "vehicleId_L{laneNumber}:laneId"
    // "vehicleId_L{laneNumber}_DIRECTION:laneId"
    size_t pos = line.find(":");
    if (pos == std::string::npos) {
        DebugLogger::log("Error parsing line (missing colon): " + line, DebugLogger::LogLevel::ERROR);
        return nullptr;
    }

    std::string vehicleId = line.substr(0, pos);

    // Ensure there's a lane ID after the colon
    if (pos + 1 >= line.length()) {
        DebugLogger::log("Error parsing line (missing lane ID): " + line, DebugLogger::LogLevel::ERROR);
        return nullptr;
    }

    char laneId = line[pos + 1];

    // Extract lane number from ID (format: V1_L2 where 2 is the lane number)
    int laneNumber = 2; // Default is lane 2
    size_t lanePos = vehicleId.find("_L");
    if (lanePos != std::string::npos && lanePos + 2 < vehicleId.length()) {
        char laneNumChar = vehicleId[lanePos + 2];
        if (laneNumChar >= '1' && laneNumChar <= '3') {
            laneNumber = laneNumChar - '0';
        }
    }

    // Don't spawn vehicles in Lane 1 (L1)
    if (laneNumber == 1) {
        DebugLogger::log("Ignoring vehicle in Lane 1: " + line, DebugLogger::LogLevel::WARNING);
        return nullptr;
    }

    // Determine direction from ID - important for vehicle behavior
    Destination destination = Destination::STRAIGHT; // Default

    if (laneNumber == 3) {
        // Lane 3 always turns LEFT
        destination = Destination::LEFT;
    } else if (laneNumber == 2) {
        // Check for direction in ID
        if (vehicleId.find("_LEFT") != std::string::npos) {
            destination = Destination::LEFT;
        } else if (vehicleId.find("_STRAIGHT") != std::string::npos) {
            destination = Destination::STRAIGHT;
        } else {
            // Default for L2 if not specified is STRAIGHT
            destination = Destination::STRAIGHT;
        }
    }

    // Determine if it's an emergency vehicle
    bool isEmergency = vehicleId.find("_E") != std::string::npos || vehicleId.find("E_") != std::string::npos;

    // Validate lane ID
    if (laneId != 'A' && laneId != 'B' && laneId != 'C' && laneId != 'D') {
        DebugLogger::log("Invalid lane ID in line: " + line, DebugLogger::LogLevel::ERROR);
        return nullptr;
    }

    // Create the vehicle with the specified destination
    Vehicle* vehicle = new Vehicle(vehicleId, laneId, laneNumber, isEmergency);
    vehicle->setDestination(destination);

    std::ostringstream oss;
    oss << "Created vehicle " << vehicleId << " for lane " << laneId << laneNumber;
    switch (destination) {
        case Destination::STRAIGHT: oss << " (STRAIGHT)"; break;
        case Destination::LEFT: oss << " (LEFT)"; break;
        case Destination::RIGHT: oss << " (RIGHT)"; break;
    }
    if (isEmergency) {
        oss << " [EMERGENCY]";
    }
    DebugLogger::log(oss.str());

    return vehicle;
}

void FileHandler::writeLaneStatus(char laneId, int laneNumber, int vehicleCount, bool isPriority) {
    std::lock_guard<std::mutex> lock(mutex);
    std::string statusPath = getLaneStatusFilePath();

    // Make sure the directory exists
    fs::path dir = fs::path(statusPath).parent_path();
    if (!fs::exists(dir)) {
        try {
            fs::create_directories(dir);
        } catch (const std::exception& e) {
            DebugLogger::log("Error creating directory: " + std::string(e.what()),
                           DebugLogger::LogLevel::ERROR);
            return;
        }
    }

    std::ofstream file(statusPath, std::ios::app);
    if (file.is_open()) {
        file << laneId << laneNumber << ": " << vehicleCount << " vehicles"
             << (isPriority ? " (PRIORITY)" : "") << std::endl;
        file.close();
    } else {
        DebugLogger::log("Warning: Could not open lane status file for writing",
                       DebugLogger::LogLevel::WARNING);
    }
}

bool FileHandler::checkFilesExist() {
    // Make sure data directory exists
    if (!fs::exists(dataPath)) {
        DebugLogger::log("Data directory doesn't exist: " + dataPath, DebugLogger::LogLevel::WARNING);
        return false;
    }

    // Check for lane files
    bool allFilesExist = true;
    for (char laneId : {'A', 'B', 'C', 'D'}) {
        std::string filePath = getLaneFilePath(laneId);
        if (!fs::exists(filePath)) {
            DebugLogger::log("Lane file doesn't exist: " + filePath, DebugLogger::LogLevel::WARNING);
            allFilesExist = false;
        }
    }

    return allFilesExist;
}

bool FileHandler::initializeFiles() {
    std::lock_guard<std::mutex> lock(mutex);

    try {
        // Create data directory if it doesn't exist
        if (!fs::exists(dataPath)) {
            if (!fs::create_directories(dataPath)) {
                DebugLogger::log("Error: Failed to create directory " + dataPath,
                               DebugLogger::LogLevel::ERROR);
                return false;
            }
            DebugLogger::log("Created directory: " + dataPath);
        }

        // Create lane files if they don't exist
        for (char laneId : {'A', 'B', 'C', 'D'}) {
            std::string filePath = getLaneFilePath(laneId);
            if (!fs::exists(filePath)) {
                std::ofstream file(filePath);
                if (!file.is_open()) {
                    DebugLogger::log("Error: Failed to create file " + filePath,
                                   DebugLogger::LogLevel::ERROR);
                    return false;
                }
                file.close();
                DebugLogger::log("Created file: " + filePath);
            }
        }

        // Create or clear lane status file
        std::string statusPath = getLaneStatusFilePath();
        std::ofstream statusFile(statusPath, std::ios::trunc);
        if (!statusFile.is_open()) {
            DebugLogger::log("Error: Failed to create lane status file",
                           DebugLogger::LogLevel::ERROR);
            return false;
        }
        statusFile << "=== Lane Status Log ===\n";
        statusFile.close();

        DebugLogger::log("All files initialized successfully");
        return true;
    } catch (const std::exception& e) {
        DebugLogger::log("Error initializing files: " + std::string(e.what()),
                       DebugLogger::LogLevel::ERROR);
        return false;
    }
}

std::string FileHandler::getLaneFilePath(char laneId) const {
    return dataPath + "/lane" + laneId + ".txt";
}

std::string FileHandler::getLaneStatusFilePath() const {
    return dataPath + "/lane_status.txt";
}


//===== END FILE: {file_path} =====//

//===== FILE: src/managers/TrafficManager.cpp =====//

// FILE: src/managers/TrafficManager.cpp
#include "managers/TrafficManager.h"
#include "utils/DebugLogger.h"
#include <sstream>
#include <algorithm>
#include <wchar.h>
#include "core/Constants.h"

TrafficManager::TrafficManager()
    : trafficLight(nullptr),
      fileHandler(nullptr),
      lastFileCheckTime(0),
      lastPriorityUpdateTime(0),
      running(false) {

    DebugLogger::log("TrafficManager created");
}

TrafficManager::~TrafficManager() {
    // Clean up resources
    for (auto* lane : lanes) {
        delete lane;
    }
    lanes.clear();

    if (trafficLight) {
        delete trafficLight;
        trafficLight = nullptr;
    }

    if (fileHandler) {
        delete fileHandler;
        fileHandler = nullptr;
    }

    DebugLogger::log("TrafficManager destroyed");
}

bool TrafficManager::initialize() {
    // Create file handler with consistent path
    fileHandler = new FileHandler(Constants::DATA_PATH);
    if (!fileHandler->initializeFiles()) {
        DebugLogger::log("Failed to initialize lane files", DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Create lanes for each road and lane number
    for (char road : {'A', 'B', 'C', 'D'}) {
        for (int laneNum = 1; laneNum <= 3; laneNum++) {
            Lane* lane = new Lane(road, laneNum);
            lanes.push_back(lane);

            // Add to priority queue with initial priority
            lanePriorityQueue.enqueue(lane, lane->getPriority());
        }
    }

    // Create traffic light
    trafficLight = new TrafficLight();

    std::ostringstream oss;
    oss << "TrafficManager initialized with " << lanes.size() << " lanes";
    DebugLogger::log(oss.str());

    return true;
}

void TrafficManager::start() {
    running = true;
    DebugLogger::log("TrafficManager started");
}

void TrafficManager::stop() {
    running = false;
    DebugLogger::log("TrafficManager stopped");
}

void TrafficManager::update(uint32_t delta) {
    if (!running) return;

    uint32_t currentTime = SDL_GetTicks();

    // Check for new vehicles more frequently (every 200ms)
    if (currentTime - lastFileCheckTime >= 200) {
        readVehicles();
        lastFileCheckTime = currentTime;
    }

    // Update lane priorities regularly
    if (currentTime - lastPriorityUpdateTime >= 300) {
        updatePriorities();
        lastPriorityUpdateTime = currentTime;
    }

    // NEW: Limit vehicles per lane to prevent overcrowding
    limitVehiclesPerLane();

    // Process vehicles based on traffic light state
    processVehicles(delta);

    // NEW: Prevent vehicles from overlapping
    preventVehicleOverlap();

    // Check for vehicles leaving the simulation
    checkVehicleBoundaries();

    // Update traffic light
    if (trafficLight) {
        trafficLight->update(lanes);
    }
}

void TrafficManager::readVehicles() {
    if (!fileHandler) {
        DebugLogger::log("FileHandler not initialized", DebugLogger::LogLevel::ERROR);
        return;
    }

    // Ensure directories exist before reading
    if (!fileHandler->checkFilesExist()) {
        if (!fileHandler->initializeFiles()) {
            DebugLogger::log("Failed to initialize files", DebugLogger::LogLevel::ERROR);
            return;
        }
    }

    // Read new vehicles from files
    std::vector<Vehicle*> newVehicles = fileHandler->readVehiclesFromFiles();

    if (!newVehicles.empty()) {
        std::ostringstream oss;
        oss << "Read " << newVehicles.size() << " new vehicles from files";
        DebugLogger::log(oss.str());

        // Add vehicles to appropriate lanes
        for (auto* vehicle : newVehicles) {
            addVehicle(vehicle);
        }
    }

    // Write status to file periodically for monitoring
    static uint32_t lastStatusTime = 0;
    uint32_t currentTime = SDL_GetTicks();

    if (currentTime - lastStatusTime >= 5000) { // Every 5 seconds
        for (auto* lane : lanes) {
            if (fileHandler && lane->getVehicleCount() > 0) {
                fileHandler->writeLaneStatus(
                    lane->getLaneId(),
                    lane->getLaneNumber(),
                    lane->getVehicleCount(),
                    lane->isPriorityLane() && lane->getPriority() > 0
                );
            }
        }
        lastStatusTime = currentTime;
    }
}

void TrafficManager::addVehicle(Vehicle* vehicle) {
    if (!vehicle) return;

    Lane* targetLane = findLane(vehicle->getLane(), vehicle->getLaneNumber());
    if (targetLane) {
        targetLane->enqueue(vehicle);

        // Log the action
        std::ostringstream oss;
        oss << "Added vehicle " << vehicle->getId() << " to lane "
            << vehicle->getLane() << vehicle->getLaneNumber();
        DebugLogger::log(oss.str());
    } else {
        // Clean up if lane not found
        delete vehicle;
        DebugLogger::log("Error: No matching lane found for vehicle", DebugLogger::LogLevel::ERROR);
    }
}

void TrafficManager::updatePriorities() {
    // Use lambda for comparing lanes
    auto compareLanes = [](const Lane* a, const Lane* b) -> bool {
        return a == b;
    };

    for (auto* lane : lanes) {
        // Store old priority
        int oldPriority = lane->getPriority();

        // Update priority
        lane->updatePriority();

        // If priority changed, update in the priority queue
        if (oldPriority != lane->getPriority()) {
            lanePriorityQueue.updatePriority(lane, lane->getPriority(), compareLanes);

            // Log the priority change
            std::ostringstream oss;
            oss << "Updated priority for lane " << lane->getName()
                << " from " << oldPriority << " to " << lane->getPriority();
            DebugLogger::log(oss.str());

            // For AL2 lane, log special messages when crossing thresholds
            if (lane->getLaneId() == 'A' && lane->getLaneNumber() == 2) {
                if (oldPriority == 0 && lane->getPriority() > 0) {
                    DebugLogger::log("PRIORITY MODE ACTIVATED for lane A2", DebugLogger::LogLevel::INFO);
                } else if (oldPriority > 0 && lane->getPriority() == 0) {
                    DebugLogger::log("PRIORITY MODE DEACTIVATED for lane A2", DebugLogger::LogLevel::INFO);
                }
            }
        }
    }
}

void TrafficManager::processVehicles(uint32_t delta) {
    // Determine active lanes based on traffic light state
    char activeLaneId = ' ';
    if (trafficLight) {
        if (trafficLight->getCurrentState() == TrafficLight::State::A_GREEN) activeLaneId = 'A';
        else if (trafficLight->getCurrentState() == TrafficLight::State::B_GREEN) activeLaneId = 'B';
        else if (trafficLight->getCurrentState() == TrafficLight::State::C_GREEN) activeLaneId = 'C';
        else if (trafficLight->getCurrentState() == TrafficLight::State::D_GREEN) activeLaneId = 'D';
    }

    // Process vehicles in all lanes
    for (auto* lane : lanes) {
        bool isGreenLight = (lane->getLaneId() == activeLaneId) ||
                           (lane->getLaneNumber() == 3); // L3 is free lane

        // Get all vehicles in this lane
        const auto& vehicles = lane->getVehicles();
        int queuePos = 0;

        // Update each vehicle with proper queue position for spacing
        for (auto* vehicle : vehicles) {
            if (vehicle) {
                // Update vehicle position based on traffic light
                vehicle->update(delta, isGreenLight, 0.0f); // targetPos not used with new queue positioning

                // Update queue position for visualization
                queuePos++;
            }
        }
    }
}

void TrafficManager::checkVehicleBoundaries() {
    for (auto* lane : lanes) {
        // Check each vehicle
        while (!lane->isEmpty()) {
            Vehicle* vehicle = lane->peek();

            if (vehicle && vehicle->hasExited()) {
                // Remove the vehicle from the queue
                Vehicle* removedVehicle = lane->dequeue();

                // Log vehicle exit with lane info
                std::ostringstream oss;
                oss << "Vehicle " << removedVehicle->getId() << " exited the simulation from lane "
                    << removedVehicle->getLane() << removedVehicle->getLaneNumber();
                DebugLogger::log(oss.str());

                // Delete the vehicle
                delete removedVehicle;
            } else {
                // If the first vehicle hasn't exited, the rest haven't either
                break;
            }
        }
    }
}

Lane* TrafficManager::findLane(char laneId, int laneNumber) const {
    for (auto* lane : lanes) {
        if (lane->getLaneId() == laneId && lane->getLaneNumber() == laneNumber) {
            return lane;
        }
    }
    return nullptr;
}

const std::vector<Lane*>& TrafficManager::getLanes() const {
    return lanes;
}

TrafficLight* TrafficManager::getTrafficLight() const {
    return trafficLight;
}

bool TrafficManager::isLanePrioritized(char laneId, int laneNumber) const {
    Lane* lane = findLane(laneId, laneNumber);
    return lane && lane->isPriorityLane() && lane->getPriority() > 0;
}

Lane* TrafficManager::getPriorityLane() const {
    return findLane('A', 2); // AL2 is the priority lane
}

std::string TrafficManager::getStatistics() const {
    std::ostringstream stats;
    stats << "Lane Statistics:\n";
    int totalVehicles = 0;

    for (auto* lane : lanes) {
        int count = lane->getVehicleCount();
        totalVehicles += count;

        stats << lane->getName() << ": " << count << " vehicles";
        if (lane->isPriorityLane() && lane->getPriority() > 0) {
            stats << " (PRIORITY)";
        }
        stats << "\n";
    }

    stats << "Total Vehicles: " << totalVehicles << "\n";

    // Add traffic light status
    if (trafficLight) {
        stats << "Traffic Light: ";
        switch (trafficLight->getCurrentState()) {
            case TrafficLight::State::ALL_RED: stats << "ALL RED"; break;
            case TrafficLight::State::A_GREEN: stats << "A GREEN"; break;
            case TrafficLight::State::B_GREEN: stats << "B GREEN"; break;
            case TrafficLight::State::C_GREEN: stats << "C GREEN"; break;
            case TrafficLight::State::D_GREEN: stats << "D GREEN"; break;
        }
        stats << "\n";
    }

    return stats.str();
}


void TrafficManager::limitVehiclesPerLane() {
    const int MAX_VEHICLES_PER_LANE = 12; // Maximum vehicles allowed in a single lane

    for (auto* lane : lanes) {
        int count = lane->getVehicleCount();

        // If lane has too many vehicles, remove some from the end (farthest from intersection)
        if (count > MAX_VEHICLES_PER_LANE) {
            int toRemove = count - MAX_VEHICLES_PER_LANE;

            DebugLogger::log("Lane " + lane->getName() + " has " + std::to_string(count) +
                           " vehicles (max " + std::to_string(MAX_VEHICLES_PER_LANE) +
                           ") - removing " + std::to_string(toRemove),
                           DebugLogger::LogLevel::WARNING);

            // Get all vehicles
            const auto& vehicles = lane->getVehicles();

            // Remove vehicles starting from the end of the queue (furthest from intersection)
            for (int i = 0; i < toRemove && !lane->isEmpty(); i++) {
                // We have to dequeue all vehicles and re-enqueue except the last one
                std::vector<Vehicle*> tempVehicles;
                int keepCount = count - (i + 1);

                // Dequeue all vehicles except the one to remove
                for (int j = 0; j < keepCount; j++) {
                    if (!lane->isEmpty()) {
                        Vehicle* v = lane->dequeue();
                        if (v) {
                            tempVehicles.push_back(v);
                        }
                    }
                }

                // Now remove the target vehicle
                if (!lane->isEmpty()) {
                    Vehicle* toDelete = lane->dequeue();
                    if (toDelete) {
                        delete toDelete;
                    }
                }

                // Re-enqueue the kept vehicles
                for (auto* v : tempVehicles) {
                    lane->enqueue(v);
                }
            }
        }
    }
}



void TrafficManager::preventVehicleOverlap() {
    // For each lane, check for vehicles that are too close to each other
    for (auto* lane : lanes) {
        const auto& vehicles = lane->getVehicles();

        // Skip if fewer than 2 vehicles
        if (vehicles.size() < 2) continue;

        // Check each vehicle against others in the lane
        for (size_t i = 0; i < vehicles.size() - 1; i++) {
            Vehicle* current = vehicles[i];
            Vehicle* next = vehicles[i+1];

            if (!current || !next) continue;

            // Calculate distance between vehicles
            float dx = current->getTurnPosX() - next->getTurnPosX();
            float dy = current->getTurnPosY() - next->getTurnPosY();
            float distance = std::sqrt(dx*dx + dy*dy);

            // Minimum distance between vehicles
            const float MIN_DISTANCE = 35.0f;

            // If too close, adjust next vehicle position
            if (distance < MIN_DISTANCE) {
                // Normalize direction vector
                float normalize = distance > 0 ? distance : 1.0f;
                dx /= normalize;
                dy /= normalize;

                // Move next vehicle back to maintain spacing
                float moveDistance = MIN_DISTANCE - distance;
                next->setTurnPosX(next->getTurnPosX() - dx * moveDistance);
                next->setTurnPosY(next->getTurnPosY() - dy * moveDistance);
            }
        }
    }
}


//===== END FILE: {file_path} =====//

//===== FILE: src/visualization/Renderer.cpp =====//

// FILE: src/visualization/Renderer.cpp
#include "visualization/Renderer.h"
#include "core/Lane.h"
#include "core/Vehicle.h"
#include "core/TrafficLight.h"
#include "managers/TrafficManager.h"
#include "utils/DebugLogger.h"
#include "core/Constants.h"

#include <sstream>
#include <algorithm>
#include <cmath>

Renderer::Renderer()
    : window(nullptr),
      renderer(nullptr),
      carTexture(nullptr),
      surface(nullptr),
      active(false),
      showDebugOverlay(true),
      frameRateLimit(60),
      lastFrameTime(0),
      windowWidth(800),
      windowHeight(800),
      trafficManager(nullptr) {}

Renderer::~Renderer() {
    cleanup();
}

bool Renderer::initialize(int width, int height, const std::string& title) {
    windowWidth = width;
    windowHeight = height;

    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        DebugLogger::log("Failed to initialize SDL: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Create window
    window = SDL_CreateWindow(title.c_str(), width, height, SDL_WINDOW_OPENGL);
    if (!window) {
        DebugLogger::log("Failed to create window: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Create renderer
    renderer = SDL_CreateRenderer(window, NULL);
    if (!renderer) {
        DebugLogger::log("Failed to create renderer: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Load textures
    if (!loadTextures()) {
        DebugLogger::log("Failed to load textures", DebugLogger::LogLevel::ERROR);
        return false;
    }

    active = true;
    DebugLogger::log("Renderer initialized successfully");

    return true;
}

bool Renderer::loadTextures() {
    // Create a simple surface directly with a solid color to avoid SDL_MapRGB issues
    surface = SDL_CreateSurface(20, 10, SDL_PIXELFORMAT_RGBA8888);
    if (!surface) {
        DebugLogger::log("Failed to create surface: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Fill with blue color using a simpler approach
    // Create a color value manually
    Uint32 blueColor = 0x0000FFFF; // RGBA format: blue with full alpha

    // Fill the entire surface with this color
    SDL_FillSurfaceRect(surface, NULL, blueColor);

    carTexture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_DestroySurface(surface);
    surface = nullptr;

    if (!carTexture) {
        DebugLogger::log("Failed to create car texture: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    return true;
}

void Renderer::startRenderLoop() {
    if (!active || !trafficManager) {
        DebugLogger::log("Cannot start render loop - renderer not active or trafficManager not set", DebugLogger::LogLevel::ERROR);
        return;
    }

    DebugLogger::log("Starting render loop");

    uint32_t lastUpdate = SDL_GetTicks();
    const int updateInterval = 16; // ~60 FPS

    while (active) {
        uint32_t currentTime = SDL_GetTicks();
        uint32_t deltaTime = currentTime - lastUpdate;

        if (deltaTime >= updateInterval) {
            // Process events
            active = processEvents();

            // Update traffic manager
            trafficManager->update(deltaTime);

            // Render frame
            renderFrame();

            lastUpdate = currentTime;
        }

        // Delay to maintain frame rate
        uint32_t frameDuration = SDL_GetTicks() - currentTime;
        if (frameRateLimit > 0) {
            uint32_t targetFrameTime = 1000 / frameRateLimit;
            if (frameDuration < targetFrameTime) {
                SDL_Delay(targetFrameTime - frameDuration);
            }
        }
    }
}

bool Renderer::processEvents() {
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
            case SDL_EVENT_QUIT:
                return false;

            case SDL_EVENT_KEY_DOWN: {
                // Check based on the key scancode instead of using SDLK constants
                SDL_Scancode scancode = event.key.scancode;

                // D key scancode is usually 7 (for SDL_SCANCODE_D)
                if (scancode == SDL_SCANCODE_D) {
                    toggleDebugOverlay();
                }
                // Escape key scancode is usually 41 (for SDL_SCANCODE_ESCAPE)
                else if (scancode == SDL_SCANCODE_ESCAPE) {
                    return false;
                }
                break;
            }
        }
    }

    return true;
}

void Renderer::renderFrame() {
    if (!active || !renderer || !trafficManager) {
        return;
    }

    // Clear screen
    SDL_SetRenderDrawColor(renderer, 40, 40, 40, 255); // Darker background
    SDL_RenderClear(renderer);

    // Draw roads and lanes
    drawRoadsAndLanes();

    // Draw traffic lights
    drawTrafficLights();

    // Draw vehicles
    drawVehicles();

    // Draw lane labels and direction indicators
    drawLaneLabels();

    // Draw debug overlay if enabled
    if (showDebugOverlay) {
        drawDebugOverlay();
    }

    // Present render
    SDL_RenderPresent(renderer);

    // Update frame time
    lastFrameTime = SDL_GetTicks();
}


void Renderer::drawRoadsAndLanes() {
    const int ROAD_WIDTH = Constants::ROAD_WIDTH;
    const int LANE_WIDTH = Constants::LANE_WIDTH;

    // Draw dark gray background for the whole road network
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);
    SDL_FRect intersectionRect = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2),
        static_cast<float>(ROAD_WIDTH),
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &intersectionRect);

    // Draw horizontal road (dark gray)
    SDL_FRect horizontalRoad = {
        0, static_cast<float>(windowHeight/2 - ROAD_WIDTH/2),
        static_cast<float>(windowWidth), static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &horizontalRoad);

    // Draw vertical road (dark gray)
    SDL_FRect verticalRoad = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2), 0,
        static_cast<float>(ROAD_WIDTH), static_cast<float>(windowHeight)
    };
    SDL_RenderFillRect(renderer, &verticalRoad);

    // Draw clear lane dividers for all roads
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255); // White for lane dividers

    // Draw road labels - A, B, C, D for better orientation
    int textSize = 16;

    // Road A (North)
    drawText("A (North)", windowWidth/2 - 40, 10, {255, 255, 255, 255});

    // Road B (East)
    drawText("B (East)", windowWidth - 80, windowHeight/2 - 10, {255, 255, 255, 255});

    // Road C (South)
    drawText("C (South)", windowWidth/2 - 40, windowHeight - 30, {255, 255, 255, 255});

    // Road D (West)
    drawText("D (West)", 10, windowHeight/2 - 10, {255, 255, 255, 255});

    // Horizontal lane dividers (3 lanes per road)
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    // Draw center double-yellow line
    SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255); // Yellow

    // Horizontal center double line
    SDL_FRect hCenterLine1 = {
        0, static_cast<float>(windowHeight/2 - 1),
        static_cast<float>(windowWidth), 2.0f
    };
    SDL_FRect hCenterLine2 = {
        0, static_cast<float>(windowHeight/2 - 5),
        static_cast<float>(windowWidth), 2.0f
    };
    SDL_RenderFillRect(renderer, &hCenterLine1);
    SDL_RenderFillRect(renderer, &hCenterLine2);

    // Vertical center double line
    SDL_FRect vCenterLine1 = {
        static_cast<float>(windowWidth/2 - 1), 0,
        2.0f, static_cast<float>(windowHeight)
    };
    SDL_FRect vCenterLine2 = {
        static_cast<float>(windowWidth/2 - 5), 0,
        2.0f, static_cast<float>(windowHeight)
    };
    SDL_RenderFillRect(renderer, &vCenterLine1);
    SDL_RenderFillRect(renderer, &vCenterLine2);

    // Switch back to white for lane dividers
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    // Horizontal lane dividers
    for (int i = 1; i < 3; i++) {
        float y1 = windowHeight/2 - ROAD_WIDTH/2 + i * LANE_WIDTH;
        float y2 = windowHeight/2 + i * LANE_WIDTH;

        // Top road lanes (going down)
        for (int x = 0; x < windowWidth/2 - ROAD_WIDTH/2; x += 30) {
            SDL_RenderLine(renderer, x, y1, x + 15, y1);
        }

        // Bottom road lanes (going up)
        for (int x = windowWidth/2 + ROAD_WIDTH/2; x < windowWidth; x += 30) {
            SDL_RenderLine(renderer, x, y2, x + 15, y2);
        }
    }

    // Vertical lane dividers
    for (int i = 1; i < 3; i++) {
        float x1 = windowWidth/2 - ROAD_WIDTH/2 + i * LANE_WIDTH;
        float x2 = windowWidth/2 + i * LANE_WIDTH;

        // Left road lanes (going right)
        for (int y = 0; y < windowHeight/2 - ROAD_WIDTH/2; y += 30) {
            SDL_RenderLine(renderer, x1, y, x1, y + 15);
        }

        // Right road lanes (going left)
        for (int y = windowHeight/2 + ROAD_WIDTH/2; y < windowHeight; y += 30) {
            SDL_RenderLine(renderer, x2, y, x2, y + 15);
        }
    }

    // Highlight lane types with subtle background colors
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

    // A2 (Priority Lane) - light orange highlight
    if (trafficManager && trafficManager->isLanePrioritized('A', 2)) {
        SDL_SetRenderDrawColor(renderer, 255, 165, 0, 80); // Semi-transparent orange
        SDL_FRect priorityLane = {
            static_cast<float>(windowWidth/2),
            0,
            static_cast<float>(LANE_WIDTH),
            static_cast<float>(windowHeight/2 - ROAD_WIDTH/2)
        };
        SDL_RenderFillRect(renderer, &priorityLane);
    }

    // Free Lanes (L3) - light green highlights
    SDL_SetRenderDrawColor(renderer, 0, 255, 0, 50); // Semi-transparent green

    // A3 (North Road)
    SDL_FRect freeALane = {
        static_cast<float>(windowWidth/2 + LANE_WIDTH),
        0,
        static_cast<float>(LANE_WIDTH),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2)
    };
    SDL_RenderFillRect(renderer, &freeALane);

    // B3 (East Road)
    SDL_FRect freeBLane = {
        static_cast<float>(windowWidth/2 + ROAD_WIDTH/2),
        static_cast<float>(windowHeight/2 + LANE_WIDTH),
        static_cast<float>(windowWidth - (windowWidth/2 + ROAD_WIDTH/2)),
        static_cast<float>(LANE_WIDTH)
    };
    SDL_RenderFillRect(renderer, &freeBLane);

    // C3 (South Road)
    SDL_FRect freeCLane = {
        static_cast<float>(windowWidth/2 - 2*LANE_WIDTH),
        static_cast<float>(windowHeight/2 + ROAD_WIDTH/2),
        static_cast<float>(LANE_WIDTH),
        static_cast<float>(windowHeight - (windowHeight/2 + ROAD_WIDTH/2))
    };
    SDL_RenderFillRect(renderer, &freeCLane);

    // D3 (West Road)
    SDL_FRect freeDLane = {
        0,
        static_cast<float>(windowHeight/2 - 2*LANE_WIDTH),
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2),
        static_cast<float>(LANE_WIDTH)
    };
    SDL_RenderFillRect(renderer, &freeDLane);

    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    // Draw lane labels directly on the road
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    // A Road (North) lane labels
    drawText("A1", windowWidth/2 - LANE_WIDTH/2 - 10, windowHeight/4, {255, 255, 255, 255});
    drawText("A2", windowWidth/2 + LANE_WIDTH/2 - 10, windowHeight/4, {255, 255, 255, 255});
    drawText("A3", windowWidth/2 + LANE_WIDTH + LANE_WIDTH/2 - 10, windowHeight/4, {255, 255, 255, 255});

    // B Road (East) lane labels
    drawText("B1", 3*windowWidth/4, windowHeight/2 - LANE_WIDTH/2 - 10, {255, 255, 255, 255});
    drawText("B2", 3*windowWidth/4, windowHeight/2 + LANE_WIDTH/2 - 10, {255, 255, 255, 255});
    drawText("B3", 3*windowWidth/4, windowHeight/2 + LANE_WIDTH + LANE_WIDTH/2 - 10, {255, 255, 255, 255});

    // C Road (South) lane labels
    drawText("C1", windowWidth/2 + LANE_WIDTH/2 - 10, 3*windowHeight/4, {255, 255, 255, 255});
    drawText("C2", windowWidth/2 - LANE_WIDTH/2 - 10, 3*windowHeight/4, {255, 255, 255, 255});
    drawText("C3", windowWidth/2 - LANE_WIDTH - LANE_WIDTH/2 - 10, 3*windowHeight/4, {255, 255, 255, 255});

    // D Road (West) lane labels
    drawText("D1", windowWidth/4, windowHeight/2 + LANE_WIDTH/2 - 10, {255, 255, 255, 255});
    drawText("D2", windowWidth/4, windowHeight/2 - LANE_WIDTH/2 - 10, {255, 255, 255, 255});
    drawText("D3", windowWidth/4, windowHeight/2 - LANE_WIDTH - LANE_WIDTH/2 - 10, {255, 255, 255, 255});

    // Draw small arrows indicating traffic direction for each lane
    // North road (A) - traffic going down
    drawDirectionArrow(windowWidth/2 - LANE_WIDTH/2, windowHeight/4, Direction::DOWN, {255, 255, 255, 255}); // A1
    drawDirectionArrow(windowWidth/2 + LANE_WIDTH/2, windowHeight/4, Direction::DOWN, {255, 255, 255, 255}); // A2
    drawDirectionArrow(windowWidth/2 + LANE_WIDTH + LANE_WIDTH/2, windowHeight/4, Direction::DOWN, {255, 255, 255, 255}); // A3

    // East road (B) - traffic going left
    drawDirectionArrow(3*windowWidth/4, windowHeight/2 - LANE_WIDTH/2, Direction::LEFT, {255, 255, 255, 255}); // B1
    drawDirectionArrow(3*windowWidth/4, windowHeight/2 + LANE_WIDTH/2, Direction::LEFT, {255, 255, 255, 255}); // B2
    drawDirectionArrow(3*windowWidth/4, windowHeight/2 + LANE_WIDTH + LANE_WIDTH/2, Direction::LEFT, {255, 255, 255, 255}); // B3

    // South road (C) - traffic going up
    drawDirectionArrow(windowWidth/2 + LANE_WIDTH/2, 3*windowHeight/4, Direction::UP, {255, 255, 255, 255}); // C1
    drawDirectionArrow(windowWidth/2 - LANE_WIDTH/2, 3*windowHeight/4, Direction::UP, {255, 255, 255, 255}); // C2
    drawDirectionArrow(windowWidth/2 - LANE_WIDTH - LANE_WIDTH/2, 3*windowHeight/4, Direction::UP, {255, 255, 255, 255}); // C3

    // West road (D) - traffic going right
    drawDirectionArrow(windowWidth/4, windowHeight/2 + LANE_WIDTH/2, Direction::RIGHT, {255, 255, 255, 255}); // D1
    drawDirectionArrow(windowWidth/4, windowHeight/2 - LANE_WIDTH/2, Direction::RIGHT, {255, 255, 255, 255}); // D2
    drawDirectionArrow(windowWidth/4, windowHeight/2 - LANE_WIDTH - LANE_WIDTH/2, Direction::RIGHT, {255, 255, 255, 255}); // D3

    // Draw stop lines at intersection
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    // Top stop line (A road)
    SDL_FRect topStop = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2 - 4),
        static_cast<float>(ROAD_WIDTH),
        4.0f
    };
    SDL_RenderFillRect(renderer, &topStop);

    // Bottom stop line (C road)
    SDL_FRect bottomStop = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2),
        static_cast<float>(windowHeight/2 + ROAD_WIDTH/2),
        static_cast<float>(ROAD_WIDTH),
        4.0f
    };
    SDL_RenderFillRect(renderer, &bottomStop);

    // Left stop line (D road)
    SDL_FRect leftStop = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2 - 4),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2),
        4.0f,
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &leftStop);

    // Right stop line (B road)
    SDL_FRect rightStop = {
        static_cast<float>(windowWidth/2 + ROAD_WIDTH/2),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2),
        4.0f,
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &rightStop);
}



// Helper method to draw direction arrows
// FILE: src/visualization/Renderer.cpp
// Implementation of drawDirectionArrow method

// FILE: src/visualization/Renderer.cpp
// Corrected implementation of drawDirectionArrow method

void Renderer::drawDirectionArrow(int x, int y, Direction dir, SDL_Color color) {
    SDL_SetRenderDrawColor(this->renderer, color.r, color.g, color.b, color.a);

    const int arrowSize = 12;

    SDL_FPoint points[3];

    switch (dir) {
        case Direction::UP:
            points[0] = {static_cast<float>(x), static_cast<float>(y - arrowSize/2)};
            points[1] = {static_cast<float>(x - arrowSize/2), static_cast<float>(y + arrowSize/2)};
            points[2] = {static_cast<float>(x + arrowSize/2), static_cast<float>(y + arrowSize/2)};
            break;

        case Direction::DOWN:
            points[0] = {static_cast<float>(x), static_cast<float>(y + arrowSize/2)};
            points[1] = {static_cast<float>(x - arrowSize/2), static_cast<float>(y - arrowSize/2)};
            points[2] = {static_cast<float>(x + arrowSize/2), static_cast<float>(y - arrowSize/2)};
            break;

        case Direction::LEFT:
            points[0] = {static_cast<float>(x - arrowSize/2), static_cast<float>(y)};
            points[1] = {static_cast<float>(x + arrowSize/2), static_cast<float>(y - arrowSize/2)};
            points[2] = {static_cast<float>(x + arrowSize/2), static_cast<float>(y + arrowSize/2)};
            break;

        case Direction::RIGHT:
            points[0] = {static_cast<float>(x + arrowSize/2), static_cast<float>(y)};
            points[1] = {static_cast<float>(x - arrowSize/2), static_cast<float>(y - arrowSize/2)};
            points[2] = {static_cast<float>(x - arrowSize/2), static_cast<float>(y + arrowSize/2)};
            break;
    }

    // Draw outline
    SDL_RenderLine(this->renderer, points[0].x, points[0].y, points[1].x, points[1].y);
    SDL_RenderLine(this->renderer, points[1].x, points[1].y, points[2].x, points[2].y);
    SDL_RenderLine(this->renderer, points[2].x, points[2].y, points[0].x, points[0].y);

    // Create SDL vertices for filled triangle
    SDL_Vertex vertices[3];
    SDL_FColor fcolor = {
        static_cast<float>(color.r) / 255.0f,
        static_cast<float>(color.g) / 255.0f,
        static_cast<float>(color.b) / 255.0f,
        static_cast<float>(color.a) / 255.0f
    };

    // Set vertices
    for (int i = 0; i < 3; i++) {
        vertices[i].position = points[i];
        vertices[i].color = fcolor;
    }

    // Draw filled triangle
    SDL_RenderGeometry(this->renderer, NULL, vertices, 3, NULL, 0);
}

void Renderer::drawLaneLabels() {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const int ROAD_WIDTH = Constants::ROAD_WIDTH;
    const int LANE_WIDTH = Constants::LANE_WIDTH;

    // Road A (North - Top) labels
    drawText("A (North)", windowWidth/2, 10, {255, 255, 255, 255});
    drawText("A1", windowWidth/2 - LANE_WIDTH, windowHeight/4, {0, 140, 255, 255});
    drawText("A2 (Priority)", windowWidth/2, windowHeight/4, {255, 140, 0, 255});
    drawText("A3 (Free)", windowWidth/2 + LANE_WIDTH, windowHeight/4, {0, 220, 60, 255});

    // Road B (East - Right) labels
    drawText("B (East)", windowWidth - 60, windowHeight/2, {255, 255, 255, 255});
    drawText("B1", 3*windowWidth/4, windowHeight/2 - LANE_WIDTH, {0, 140, 255, 255});
    drawText("B2", 3*windowWidth/4, windowHeight/2, {255, 255, 255, 255});
    drawText("B3 (Free)", 3*windowWidth/4, windowHeight/2 + LANE_WIDTH, {0, 220, 60, 255});

    // Road C (South - Bottom) labels
    drawText("C (South)", windowWidth/2, windowHeight - 30, {255, 255, 255, 255});
    drawText("C1", windowWidth/2 + LANE_WIDTH, 3*windowHeight/4, {0, 140, 255, 255});
    drawText("C2", windowWidth/2, 3*windowHeight/4, {255, 255, 255, 255});
    drawText("C3 (Free)", windowWidth/2 - LANE_WIDTH, 3*windowHeight/4, {0, 220, 60, 255});

    // Road D (West - Left) labels
    drawText("D (West)", 50, windowHeight/2, {255, 255, 255, 255});
    drawText("D1", windowWidth/4, windowHeight/2 + LANE_WIDTH, {0, 140, 255, 255});
    drawText("D2", windowWidth/4, windowHeight/2, {255, 255, 255, 255});
    drawText("D3 (Free)", windowWidth/4, windowHeight/2 - LANE_WIDTH, {0, 220, 60, 255});

    // Draw direction arrows
    // North (Road A) direction arrows
    drawArrow(windowWidth/2 - LANE_WIDTH*1.5, windowHeight/4 + 15, // Lane A1 arrow (straight)
             windowWidth/2 - LANE_WIDTH*1.5, windowHeight/4 + 30,
             windowWidth/2 - LANE_WIDTH*1.5 - 5, windowHeight/4 + 25,
             {0, 140, 255, 255});

    // Draw split arrows for Lane A2 (priority) - straight or right
    drawArrow(windowWidth/2, windowHeight/4 + 15, // Lane A2 arrow straight
             windowWidth/2, windowHeight/4 + 30,
             windowWidth/2 - 5, windowHeight/4 + 25,
             {255, 140, 0, 255});
    drawArrow(windowWidth/2 + 10, windowHeight/4 + 15, // Lane A2 arrow right
             windowWidth/2 + 20, windowHeight/4 + 20,
             windowWidth/2 + 15, windowHeight/4 + 10,
             {255, 140, 0, 255});

    // Draw left arrow for Lane A3 (free)
    drawArrow(windowWidth/2 + LANE_WIDTH*1.5 - 10, windowHeight/4 + 15, // Lane A3 arrow left
             windowWidth/2 + LANE_WIDTH*1.5 - 20, windowHeight/4 + 20,
             windowWidth/2 + LANE_WIDTH*1.5 - 15, windowHeight/4 + 10,
             {0, 220, 60, 255});

    // East (Road B) direction arrows - similar logic
    drawArrow(3*windowWidth/4 - 15, windowHeight/2 - LANE_WIDTH*1.5, // Lane B1 arrow (straight)
             3*windowWidth/4 - 30, windowHeight/2 - LANE_WIDTH*1.5,
             3*windowWidth/4 - 25, windowHeight/2 - LANE_WIDTH*1.5 - 5,
             {0, 140, 255, 255});

    // Draw split arrows for Lane B2 - straight or right
    drawArrow(3*windowWidth/4 - 15, windowHeight/2, // Lane B2 arrow straight
             3*windowWidth/4 - 30, windowHeight/2,
             3*windowWidth/4 - 25, windowHeight/2 - 5,
             {255, 255, 255, 255});
    drawArrow(3*windowWidth/4 - 15, windowHeight/2 + 10, // Lane B2 arrow right
             3*windowWidth/4 - 20, windowHeight/2 + 20,
             3*windowWidth/4 - 10, windowHeight/2 + 15,
             {255, 255, 255, 255});

    // Draw left arrow for Lane B3 (free)
    drawArrow(3*windowWidth/4 - 15, windowHeight/2 + LANE_WIDTH*1.5 - 10, // Lane B3 arrow left
             3*windowWidth/4 - 20, windowHeight/2 + LANE_WIDTH*1.5 - 20,
             3*windowWidth/4 - 10, windowHeight/2 + LANE_WIDTH*1.5 - 15,
             {0, 220, 60, 255});

    // South (Road C) direction arrows
    drawArrow(windowWidth/2 + LANE_WIDTH*1.5, 3*windowHeight/4 - 15, // Lane C1 arrow (straight)
             windowWidth/2 + LANE_WIDTH*1.5, 3*windowHeight/4 - 30,
             windowWidth/2 + LANE_WIDTH*1.5 + 5, 3*windowHeight/4 - 25,
             {0, 140, 255, 255});

    // Draw split arrows for Lane C2 - straight or right
    drawArrow(windowWidth/2, 3*windowHeight/4 - 15, // Lane C2 arrow straight
             windowWidth/2, 3*windowHeight/4 - 30,
             windowWidth/2 + 5, 3*windowHeight/4 - 25,
             {255, 255, 255, 255});
    drawArrow(windowWidth/2 - 10, 3*windowHeight/4 - 15, // Lane C2 arrow right
             windowWidth/2 - 20, 3*windowHeight/4 - 20,
             windowWidth/2 - 15, 3*windowHeight/4 - 10,
             {255, 255, 255, 255});

    // Draw left arrow for Lane C3 (free)
    drawArrow(windowWidth/2 - LANE_WIDTH*1.5 + 10, 3*windowHeight/4 - 15, // Lane C3 arrow left
             windowWidth/2 - LANE_WIDTH*1.5 + 20, 3*windowHeight/4 - 20,
             windowWidth/2 - LANE_WIDTH*1.5 + 15, 3*windowHeight/4 - 10,
             {0, 220, 60, 255});

    // West (Road D) direction arrows
    drawArrow(windowWidth/4 + 15, windowHeight/2 + LANE_WIDTH*1.5, // Lane D1 arrow (straight)
             windowWidth/4 + 30, windowHeight/2 + LANE_WIDTH*1.5,
             windowWidth/4 + 25, windowHeight/2 + LANE_WIDTH*1.5 + 5,
             {0, 140, 255, 255});

    // Draw split arrows for Lane D2 - straight or right
    drawArrow(windowWidth/4 + 15, windowHeight/2, // Lane D2 arrow straight
             windowWidth/4 + 30, windowHeight/2,
             windowWidth/4 + 25, windowHeight/2 + 5,
             {255, 255, 255, 255});
    drawArrow(windowWidth/4 + 15, windowHeight/2 - 10, // Lane D2 arrow right
             windowWidth/4 + 20, windowHeight/2 - 20,
             windowWidth/4 + 10, windowHeight/2 - 15,
             {255, 255, 255, 255});

    // Draw left arrow for Lane D3 (free)
    drawArrow(windowWidth/4 + 15, windowHeight/2 - LANE_WIDTH*1.5 + 10, // Lane D3 arrow left
             windowWidth/4 + 20, windowHeight/2 - LANE_WIDTH*1.5 + 20,
             windowWidth/4 + 10, windowHeight/2 - LANE_WIDTH*1.5 + 15,
             {0, 220, 60, 255});
}

void Renderer::drawTrafficLights() {
    if (!trafficManager) {
        return;
    }

    TrafficLight* trafficLight = trafficManager->getTrafficLight();
    if (!trafficLight) {
        return;
    }

    // Draw traffic lights
    trafficLight->render(renderer);
}

void Renderer::drawVehicles() {
    if (!trafficManager) {
        return;
    }

    // Get all lanes from traffic manager
    const std::vector<Lane*>& lanes = trafficManager->getLanes();

    // Draw vehicles in each lane
    for (Lane* lane : lanes) {
        if (!lane) {
            continue;
        }

        const std::vector<Vehicle*>& vehicles = lane->getVehicles();
        int queuePos = 0;

        for (Vehicle* vehicle : vehicles) {
            if (vehicle) {
                vehicle->render(renderer, carTexture, queuePos);
                queuePos++;
            }
        }
    }
}

void Renderer::drawDebugOverlay() {
    // Draw semi-transparent background
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200); // More opaque background
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
    SDL_FRect overlayRect = {10, 10, 280, 180}; // Larger overlay
    SDL_RenderFillRect(renderer, &overlayRect);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    // Add border
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderRect(renderer, &overlayRect);

    // Draw statistics
    drawStatistics();

    // Draw title
    drawText("Traffic Junction Simulator", 20, 20, {255, 255, 255, 255});
    drawText("Press D to toggle debug overlay", 20, 40, {200, 200, 200, 255});

    // Draw recent logs
    std::vector<std::string> logs = DebugLogger::getRecentLogs(5);
    int y = 170;

    for (const auto& log : logs) {
        std::string truncatedLog = log.length() > 50 ? log.substr(0, 47) + "..." : log;
        drawText(truncatedLog, 10, y, {200, 200, 200, 255});
        y += 20;
    }
}

void Renderer::drawStatistics() {
    if (!trafficManager) {
        return;
    }

    // Get statistics from traffic manager
    std::string stats = trafficManager->getStatistics();

    // Split into lines
    std::istringstream stream(stats);
    std::string line;
    int y = 60;

    while (std::getline(stream, line)) {
        // Check if line contains priority info
        if (line.find("PRIORITY") != std::string::npos) {
            drawText(line, 20, y, {255, 140, 0, 255}); // Highlight priority lanes
        } else if (line.find("A2") != std::string::npos) {
            drawText(line, 20, y, {255, 200, 0, 255}); // Highlight A2 lane
        } else {
            drawText(line, 20, y, {255, 255, 255, 255});
        }
        y += 20;
    }

    // Show current traffic light state
    SDL_Color stateColor = {255, 255, 255, 255};
    std::string stateText = "Traffic Light: ";

    auto* trafficLight = trafficManager->getTrafficLight();
    if (trafficLight) {
        auto currentState = trafficLight->getCurrentState();
        switch (currentState) {
            case TrafficLight::State::ALL_RED:
                stateText += "All Red";
                stateColor = {255, 100, 100, 255};
                break;
            case TrafficLight::State::A_GREEN:
                stateText += "A Green (North)";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::B_GREEN:
                stateText += "B Green (East)";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::C_GREEN:
                stateText += "C Green (South)";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::D_GREEN:
                stateText += "D Green (West)";
                stateColor = {100, 255, 100, 255};
                break;
        }
    }

    drawText(stateText, 20, y, stateColor);
}

void Renderer::drawText(const std::string& text, int x, int y, SDL_Color color) {
    // Since we don't have SDL_ttf configured, draw a colored rectangle
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);
    SDL_FRect textRect = {static_cast<float>(x), static_cast<float>(y),
                         static_cast<float>(8 * text.length()), 15};

    // Draw colored rectangle representing text
    SDL_RenderFillRect(renderer, &textRect);

    // Draw text outline
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &textRect);
}

void Renderer::drawArrow(int x1, int y1, int x2, int y2, int x3, int y3, SDL_Color color) {
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);

    // Draw triangle outline
    SDL_RenderLine(renderer, x1, y1, x2, y2);
    SDL_RenderLine(renderer, x2, y2, x3, y3);
    SDL_RenderLine(renderer, x3, y3, x1, y1);

    // Create vertices for filled triangle with SDL_FColor for SDL3 compatibility
    SDL_Vertex vertices[3];

    // Convert SDL_Color to SDL_FColor for vertices
    SDL_FColor fcolor = {
        static_cast<float>(color.r) / 255.0f,
        static_cast<float>(color.g) / 255.0f,
        static_cast<float>(color.b) / 255.0f,
        static_cast<float>(color.a) / 255.0f
    };

    // First vertex
    vertices[0].position.x = x1;
    vertices[0].position.y = y1;
    vertices[0].color = fcolor;

    // Second vertex
    vertices[1].position.x = x2;
    vertices[1].position.y = y2;
    vertices[1].color = fcolor;

    // Third vertex
    vertices[2].position.x = x3;
    vertices[2].position.y = y3;
    vertices[2].color = fcolor;

    // Draw the filled triangle
    SDL_RenderGeometry(renderer, NULL, vertices, 3, NULL, 0);
}

void Renderer::cleanup() {
    if (carTexture) {
        SDL_DestroyTexture(carTexture);
        carTexture = nullptr;
    }

    if (renderer) {
        SDL_DestroyRenderer(renderer);
        renderer = nullptr;
    }

    if (window) {
        SDL_DestroyWindow(window);
        window = nullptr;
    }

    DebugLogger::log("Renderer resources cleaned up");
}

bool Renderer::isActive() const {
    return active;
}

void Renderer::toggleDebugOverlay() {
    showDebugOverlay = !showDebugOverlay;
    DebugLogger::log("Debug overlay " + std::string(showDebugOverlay ? "enabled" : "disabled"));
}

void Renderer::setFrameRateLimit(int fps) {
    frameRateLimit = fps;
}

void Renderer::setTrafficManager(TrafficManager* manager) {
    trafficManager = manager;
}


//===== END FILE: {file_path} =====//

//===== FILE: src/utils/DebugLogger.cpp =====//

#include "utils/DebugLogger.h"
#include <iostream>
#include <fstream>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <sstream>

// Static class members initialization
std::string DebugLogger::logFilePath = "traffic_simulator.log";
std::vector<std::string> DebugLogger::recentLogs;
std::mutex DebugLogger::logMutex;
bool DebugLogger::initialized = false;

void DebugLogger::initialize(const std::string& path) {
    std::lock_guard<std::mutex> lock(logMutex);
    logFilePath = path;

    // Create/clear the log file
    std::ofstream file(logFilePath, std::ios::trunc);
    if (file.is_open()) {
        file << "=== Traffic Simulator Log ===\n";
        file.close();
    }

    initialized = true;
}

void DebugLogger::log(const std::string& message, LogLevel level) {
    if (!initialized) {
        initialize(); // Initialize with default path if not done already
    }

    std::string levelStr;
    switch (level) {
        case LogLevel::INFO:    levelStr = "INFO"; break;
        case LogLevel::WARNING: levelStr = "WARNING"; break;
        case LogLevel::ERROR:   levelStr = "ERROR"; break;
        case LogLevel::DEBUG:   levelStr = "DEBUG"; break;
        default:                levelStr = "INFO"; break;
    }

    std::string timestamp = getTimestamp();
    std::string formattedMessage = "[" + timestamp + "] [" + levelStr + "] " + message;

    // Store in recent logs (limited to last 100)
    {
        std::lock_guard<std::mutex> lock(logMutex);
        recentLogs.push_back(formattedMessage);
        if (recentLogs.size() > 100) {
            recentLogs.erase(recentLogs.begin());
        }
    }

    // Write to file
    writeToFile(formattedMessage);

    // Also output to console
    std::cout << formattedMessage << std::endl;
}

std::vector<std::string> DebugLogger::getRecentLogs(int count) {
    std::lock_guard<std::mutex> lock(logMutex);

    if (count <= 0 || recentLogs.empty()) {
        return {};
    }

    if (count >= static_cast<int>(recentLogs.size())) {
        return recentLogs;
    }

    // Return last 'count' logs
    return std::vector<std::string>(
        recentLogs.end() - count,
        recentLogs.end()
    );
}

void DebugLogger::clearLogs() {
    std::lock_guard<std::mutex> lock(logMutex);
    recentLogs.clear();

    // Clear the log file
    std::ofstream file(logFilePath, std::ios::trunc);
    if (file.is_open()) {
        file << "=== Traffic Simulator Log (Cleared) ===\n";
        file.close();
    }
}

void DebugLogger::shutdown() {
    std::lock_guard<std::mutex> lock(logMutex);

    if (!initialized) {
        return;
    }

    writeToFile("[" + getTimestamp() + "] [INFO] Logger shutdown");
    initialized = false;
}

std::string DebugLogger::getTimestamp() {
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;

    std::stringstream ss;
    ss << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S")
       << '.' << std::setfill('0') << std::setw(3) << ms.count();

    return ss.str();
}

void DebugLogger::writeToFile(const std::string& message) {
    std::ofstream file(logFilePath, std::ios::app);
    if (file.is_open()) {
        file << message << std::endl;
        file.close();
    }
}


//===== END FILE: {file_path} =====//

//===== FILE: src/main.cpp =====//

#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <SDL3/SDL.h>
#include <fstream>
#include <filesystem>
#include <vector>
#include <map>
#include <algorithm>
#include <random>
#include <cmath>

// Include the necessary headers
#include "core/Vehicle.h"
#include "core/Lane.h"
#include "core/TrafficLight.h"
#include "managers/TrafficManager.h"
#include "managers/FileHandler.h"
#include "visualization/Renderer.h"
#include "utils/DebugLogger.h"

namespace fs = std::filesystem;

// Constants
const int WINDOW_WIDTH = 800;
const int WINDOW_HEIGHT = 800;
const std::string DATA_DIR = "data/lanes";
const int PRIORITY_THRESHOLD_HIGH = 10;
const int PRIORITY_THRESHOLD_LOW = 5;

// Car colors for variety
const SDL_Color CAR_COLORS[] = {
    {200, 0, 0, 255},    // Red
    {0, 0, 200, 255},    // Blue
    {0, 150, 0, 255},    // Green
    {150, 150, 0, 255},  // Yellow
    {100, 100, 100, 255},// Gray
    {0, 150, 150, 255},  // Teal
    {150, 0, 150, 255},  // Purple
    {200, 100, 0, 255},  // Orange
    {0, 0, 0, 255}       // Black
};
const int NUM_CAR_COLORS = 9;

// Road colors
const SDL_Color ROAD_COLOR = {60, 60, 60, 255};
const SDL_Color LANE_MARKER_COLOR = {255, 255, 255, 255};
const SDL_Color YELLOW_MARKER_COLOR = {255, 255, 0, 255};
const SDL_Color INTERSECTION_COLOR = {50, 50, 50, 255};
const SDL_Color SIDEWALK_COLOR = {180, 180, 180, 255};
const SDL_Color GRASS_COLOR = {100, 200, 100, 255};

// Simple logging function
void log_message(const std::string& msg) {
    std::cout << "[Simulator] " << msg << std::endl;

    // Also log to file
    std::ofstream log("simulator_debug.log", std::ios::app);
    if (log.is_open()) {
        log << "[Simulator] " << msg << std::endl;
        log.close();
    }

    // Also use DebugLogger
    DebugLogger::log(msg);
}

// Ensure data directories exist
bool ensure_directories() {
    try {
        if (!fs::exists(DATA_DIR)) {
            fs::create_directories(DATA_DIR);
            log_message("Created directory: " + DATA_DIR);
        }
        return true;
    } catch (const std::exception& e) {
        log_message("Error creating directories: " + std::string(e.what()));
        return false;
    }
}

// Create a random number generator
std::mt19937 rng(std::random_device{}());

// Direction enum
enum class VehicleDirection {
    STRAIGHT = 0,
    LEFT = 1,
    RIGHT = 2
};

// The RenderSystem class for main visualization
class RenderSystem {
public:
    SDL_Window* window;
    SDL_Renderer* rendererSDL;
    int windowWidth;
    int windowHeight;
    bool active;
    bool showDebug;
    TrafficManager* trafficMgr;

    RenderSystem()
        : window(nullptr),
          rendererSDL(nullptr),
          windowWidth(800),
          windowHeight(800),
          active(false),
          showDebug(false), // Set to false to disable debug overlay
          trafficMgr(nullptr) {}

    ~RenderSystem() {
        cleanup();
    }

    // Initialize renderer
    bool initialize(int width, int height, const std::string& title) {
        windowWidth = width;
        windowHeight = height;

        // Create window
        window = SDL_CreateWindow(title.c_str(), width, height, SDL_WINDOW_OPENGL);
        if (!window) {
            log_message("Failed to create window: " + std::string(SDL_GetError()));
            return false;
        }

        // Create renderer
        rendererSDL = SDL_CreateRenderer(window, NULL);
        if (!rendererSDL) {
            log_message("Failed to create renderer: " + std::string(SDL_GetError()));
            return false;
        }

        active = true;
        log_message("Renderer initialized successfully");
        return true;
    }

    // Set traffic manager
    void setTrafficManager(TrafficManager* manager) {
        trafficMgr = manager;
    }

    // Draw a realistic road layout
    void drawRoadLayout() {
        const int ROAD_WIDTH = 150;
        const int LANE_WIDTH = 50;
        const int SIDEWALK_WIDTH = 20;

        // Draw grass background
        SDL_SetRenderDrawColor(rendererSDL, GRASS_COLOR.r, GRASS_COLOR.g, GRASS_COLOR.b, GRASS_COLOR.a);
        SDL_RenderClear(rendererSDL);

        // Draw sidewalks
        SDL_SetRenderDrawColor(rendererSDL, SIDEWALK_COLOR.r, SIDEWALK_COLOR.g, SIDEWALK_COLOR.b, SIDEWALK_COLOR.a);

        // Horizontal sidewalks
        SDL_FRect hSidewalk1 = {0, (float)(windowHeight/2 - ROAD_WIDTH/2 - SIDEWALK_WIDTH),
                               (float)windowWidth, (float)SIDEWALK_WIDTH};
        SDL_FRect hSidewalk2 = {0, (float)(windowHeight/2 + ROAD_WIDTH/2),
                               (float)windowWidth, (float)SIDEWALK_WIDTH};
        SDL_RenderFillRect(rendererSDL, &hSidewalk1);
        SDL_RenderFillRect(rendererSDL, &hSidewalk2);

        // Vertical sidewalks
        SDL_FRect vSidewalk1 = {(float)(windowWidth/2 - ROAD_WIDTH/2 - SIDEWALK_WIDTH), 0,
                               (float)SIDEWALK_WIDTH, (float)windowHeight};
        SDL_FRect vSidewalk2 = {(float)(windowWidth/2 + ROAD_WIDTH/2), 0,
                               (float)SIDEWALK_WIDTH, (float)windowHeight};
        SDL_RenderFillRect(rendererSDL, &vSidewalk1);
        SDL_RenderFillRect(rendererSDL, &vSidewalk2);

        // Draw main roads (dark gray)
        SDL_SetRenderDrawColor(rendererSDL, ROAD_COLOR.r, ROAD_COLOR.g, ROAD_COLOR.b, ROAD_COLOR.a);

        // Horizontal road
        SDL_FRect hRoad = {0, (float)(windowHeight/2 - ROAD_WIDTH/2),
                          (float)windowWidth, (float)ROAD_WIDTH};
        SDL_RenderFillRect(rendererSDL, &hRoad);

        // Vertical road
        SDL_FRect vRoad = {(float)(windowWidth/2 - ROAD_WIDTH/2), 0,
                          (float)ROAD_WIDTH, (float)windowHeight};
        SDL_RenderFillRect(rendererSDL, &vRoad);

        // Draw intersection (slightly darker)
        SDL_SetRenderDrawColor(rendererSDL, INTERSECTION_COLOR.r, INTERSECTION_COLOR.g, INTERSECTION_COLOR.b, INTERSECTION_COLOR.a);
        SDL_FRect intersection = {(float)(windowWidth/2 - ROAD_WIDTH/2), (float)(windowHeight/2 - ROAD_WIDTH/2),
                                 (float)ROAD_WIDTH, (float)ROAD_WIDTH};
        SDL_RenderFillRect(rendererSDL, &intersection);

        // Draw lane dividers
        // Horizontal lane dividers
        for (int i = 1; i < 3; i++) {
            int y = windowHeight/2 - ROAD_WIDTH/2 + i * LANE_WIDTH;

            if (i == 1) {
                // Center line (yellow)
                SDL_SetRenderDrawColor(rendererSDL, YELLOW_MARKER_COLOR.r, YELLOW_MARKER_COLOR.g,
                                     YELLOW_MARKER_COLOR.b, YELLOW_MARKER_COLOR.a);
            } else {
                // Other lane dividers (white)
                SDL_SetRenderDrawColor(rendererSDL, LANE_MARKER_COLOR.r, LANE_MARKER_COLOR.g,
                                     LANE_MARKER_COLOR.b, LANE_MARKER_COLOR.a);
            }

            // Draw dashed lines outside intersection
            for (int x = 0; x < windowWidth; x += 30) {
                if (x < windowWidth/2 - ROAD_WIDTH/2 || x > windowWidth/2 + ROAD_WIDTH/2) {
                    SDL_FRect line = {(float)x, (float)y - 2, 15, 4};
                    SDL_RenderFillRect(rendererSDL, &line);
                }
            }
        }

        // Vertical lane dividers
        for (int i = 1; i < 3; i++) {
            int x = windowWidth/2 - ROAD_WIDTH/2 + i * LANE_WIDTH;

            if (i == 1) {
                // Center line (yellow)
                SDL_SetRenderDrawColor(rendererSDL, YELLOW_MARKER_COLOR.r, YELLOW_MARKER_COLOR.g,
                                     YELLOW_MARKER_COLOR.b, YELLOW_MARKER_COLOR.a);
            } else {
                // Other lane dividers (white)
                SDL_SetRenderDrawColor(rendererSDL, LANE_MARKER_COLOR.r, LANE_MARKER_COLOR.g,
                                     LANE_MARKER_COLOR.b, LANE_MARKER_COLOR.a);
            }

            // Draw dashed lines outside intersection
            for (int y = 0; y < windowHeight; y += 30) {
                if (y < windowHeight/2 - ROAD_WIDTH/2 || y > windowHeight/2 + ROAD_WIDTH/2) {
                    SDL_FRect line = {(float)x - 2, (float)y, 4, 15};
                    SDL_RenderFillRect(rendererSDL, &line);
                }
            }
        }

        // Draw crosswalks
        SDL_SetRenderDrawColor(rendererSDL, 255, 255, 255, 255);

        // North crosswalk
        for (int i = 0; i < 10; i++) {
            SDL_FRect stripe = {(float)(windowWidth/2 - ROAD_WIDTH/2 + 15*i),
                               (float)(windowHeight/2 - ROAD_WIDTH/2 - 15), 10, 15};
            SDL_RenderFillRect(rendererSDL, &stripe);
        }

        // South crosswalk
        for (int i = 0; i < 10; i++) {
            SDL_FRect stripe = {(float)(windowWidth/2 - ROAD_WIDTH/2 + 15*i),
                               (float)(windowHeight/2 + ROAD_WIDTH/2), 10, 15};
            SDL_RenderFillRect(rendererSDL, &stripe);
        }

        // East crosswalk
        for (int i = 0; i < 10; i++) {
            SDL_FRect stripe = {(float)(windowWidth/2 + ROAD_WIDTH/2),
                               (float)(windowHeight/2 - ROAD_WIDTH/2 + 15*i), 15, 10};
            SDL_RenderFillRect(rendererSDL, &stripe);
        }

        // West crosswalk
        for (int i = 0; i < 10; i++) {
            SDL_FRect stripe = {(float)(windowWidth/2 - ROAD_WIDTH/2 - 15),
                               (float)(windowHeight/2 - ROAD_WIDTH/2 + 15*i), 15, 10};
            SDL_RenderFillRect(rendererSDL, &stripe);
        }
    }

    // Render a frame
    void renderFrame() {
        if (!active || !rendererSDL || !trafficMgr) {
            return;
        }

        // Draw realistic road layout
        drawRoadLayout();

        // Draw traffic lights
        if (trafficMgr->getTrafficLight()) {
            trafficMgr->getTrafficLight()->render(rendererSDL);
        }

        // Draw vehicles
        for (auto* lane : trafficMgr->getLanes()) {
            for (auto* vehicle : lane->getVehicles()) {
                if (vehicle) {
                    // Create default parameters for vehicle rendering
                    int queuePos = 0; // Not important for this call
                    vehicle->render(rendererSDL, nullptr, queuePos);
                }
            }
        }

        // Draw debug overlay only if enabled
        if (showDebug) {
            drawDebugOverlay();
        }

        // Present render
        SDL_RenderPresent(rendererSDL);
    }

    // Start render loop
    void startRenderLoop() {
        if (!active) {
            return;
        }

        log_message("Starting render loop");

        bool running = true;
        uint32_t lastUpdateTime = SDL_GetTicks();

        while (running) {
            // Process events
            SDL_Event event;
            while (SDL_PollEvent(&event)) {
                if (event.type == SDL_EVENT_QUIT) {
                    running = false;
                } else if (event.type == SDL_EVENT_KEY_DOWN) {
                    // Fixed SDL3 key handling
                    int key = event.key.which;

                    if (key == SDL_SCANCODE_D) {
                        showDebug = !showDebug;
                        log_message("Debug overlay " + std::string(showDebug ? "enabled" : "disabled"));
                    } else if (key == SDL_SCANCODE_ESCAPE) {
                        running = false;
                    }
                }
            }

            // Calculate delta time
            uint32_t currentTime = SDL_GetTicks();
            uint32_t deltaTime = currentTime - lastUpdateTime;

            // Update traffic manager
            if (trafficMgr) {
                trafficMgr->update(deltaTime);
            }

            // Render frame
            renderFrame();

            // Limit frame rate
            SDL_Delay(16); // ~60 FPS

            lastUpdateTime = currentTime;
        }
    }

    // Draw debug overlay - now much smaller and less intrusive
    void drawDebugOverlay() {
        if (!trafficMgr) return;

        // Draw semi-transparent background
        SDL_SetRenderDrawColor(rendererSDL, 0, 0, 0, 180);
        SDL_SetRenderDrawBlendMode(rendererSDL, SDL_BLENDMODE_BLEND);
        SDL_FRect overlayRect = {10, 10, 200, 100}; // Much smaller overlay
        SDL_RenderFillRect(rendererSDL, &overlayRect);
        SDL_SetRenderDrawBlendMode(rendererSDL, SDL_BLENDMODE_NONE);

        // Draw border
        SDL_SetRenderDrawColor(rendererSDL, 255, 255, 255, 255);
        SDL_RenderRect(rendererSDL, &overlayRect);

        // Function to draw text (simplified with rectangles)
        auto drawText = [this](const std::string& text, float x, float y, SDL_Color color) {
            SDL_SetRenderDrawColor(rendererSDL, color.r, color.g, color.b, color.a);
            SDL_FRect rect = {x, y, text.length() * 7.0f, 16.0f};
            SDL_RenderFillRect(rendererSDL, &rect);

            // Black border
            SDL_SetRenderDrawColor(rendererSDL, 0, 0, 0, 255);
            SDL_RenderRect(rendererSDL, &rect);
        };

        // Title
        drawText("Traffic Simulator", 20, 20, {255, 255, 255, 255});

        // Traffic light state
        std::string stateStr = "Light: ";
        SDL_Color stateColor = {255, 255, 255, 255};

        auto currentState = trafficMgr->getTrafficLight()->getCurrentState();

        switch (currentState) {
            case TrafficLight::State::ALL_RED:
                stateStr += "All Red";
                stateColor = {255, 100, 100, 255};
                break;
            case TrafficLight::State::A_GREEN:
                stateStr += "A Green";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::B_GREEN:
                stateStr += "B Green";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::C_GREEN:
                stateStr += "C Green";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::D_GREEN:
                stateStr += "D Green";
                stateColor = {100, 255, 100, 255};
                break;
        }

        drawText(stateStr, 20, 45, stateColor);

        // Priority status
        bool isPriorityMode = false;
        Lane* priorityLane = trafficMgr->getPriorityLane();
        if (priorityLane && priorityLane->getPriority() > 0) {
            isPriorityMode = true;
            drawText("PRIORITY MODE", 20, 70, {255, 165, 0, 255});
        }
    }

    // Clean up resources
    void cleanup() {
        if (rendererSDL) {
            SDL_DestroyRenderer(rendererSDL);
            rendererSDL = nullptr;
        }

        if (window) {
            SDL_DestroyWindow(window);
            window = nullptr;
        }

        active = false;
    }
};

// Main function
int main(int argc, char* argv[]) {
    try {
        // Initialize debug logger
        DebugLogger::initialize();
        log_message("Starting Traffic Junction Simulator");


        // Create traffic manager
        TrafficManager trafficManager;
        if (!trafficManager.initialize()) {
            log_message("Failed to initialize traffic manager");
            SDL_Quit();
            return 1;
        }

        // Create renderer
        RenderSystem renderer;
        if (!renderer.initialize(WINDOW_WIDTH, WINDOW_HEIGHT, "Traffic Junction Simulator")) {
            log_message("Failed to initialize renderer");
            SDL_Quit();
            return 1;
        }

        // Connect traffic manager to renderer
        renderer.setTrafficManager(&trafficManager);

        // Start traffic manager
        trafficManager.start();

        // Start render loop
        renderer.startRenderLoop();

        // Cleanup
        trafficManager.stop();
        renderer.cleanup();
        SDL_Quit();

        log_message("Simulator shutdown complete");
        return 0;
    }
    catch (const std::exception& e) {
        log_message("Unhandled exception: " + std::string(e.what()));
        SDL_Quit();
        return 1;
    }
}


//===== END FILE: {file_path} =====//

//===== FILE: src/traffic_generator.cpp =====//

// F// FILE: src/traffic_generator.cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <random>
#include <chrono>
#include <thread>
#include <filesystem>
#include <ctime>
#include <mutex>
#include <iomanip>
#include <atomic>
#include <csignal>
#include <map>

// Include Windows-specific headers if on Windows
#ifdef _WIN32
#include <windows.h>
#endif

// Namespaces
namespace fs = std::filesystem;

// Constants for the generator - MODIFIED VALUES HERE
const std::string DATA_DIR = "data/lanes";
const int GENERATION_INTERVAL_MS = 2000;  // Increased from 800ms to 2000ms
const int MAX_VEHICLES_PER_BATCH = 30;    // Reduced from 50 to 30
const int MAX_TOTAL_VEHICLES = 60;        // New: Global limit
const int PRIORITY_THRESHOLD_HIGH = 10;
const int PRIORITY_THRESHOLD_LOW = 5;

// Vehicle direction (for lane assignment)
enum class Direction {
    LEFT,
    STRAIGHT,
    RIGHT
};

// Global atomic flag to control continuous generation
std::atomic<bool> keepRunning(true);

// Signal handler for clean shutdown
void signalHandler(int signum) {
    keepRunning = false;
    std::cout << "\nReceived termination signal. Stopping generator...\n";
}

// Set up colored console output
void setupConsole() {
#ifdef _WIN32
    // Enable ANSI escape codes on Windows
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD dwMode = 0;
    GetConsoleMode(hOut, &dwMode);
    SetConsoleMode(hOut, dwMode | ENABLE_VIRTUAL_TERMINAL_PROCESSING);
#endif
}

// Simple console log with color
void console_log(const std::string& message, const std::string& color = "\033[1;36m") {
    std::time_t now = std::time(nullptr);
    std::tm timeinfo;

#ifdef _WIN32
    localtime_s(&timeinfo, &now);
#else
    localtime_r(&now, &timeinfo);
#endif

    char timestamp[64];
    std::strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", &timeinfo);

    std::cout << color << "[" << timestamp << "]\033[0m " << message << std::endl;
}

// Ensure data directories exist
void ensure_directories() {
    if (!fs::exists(DATA_DIR)) {
        fs::create_directories(DATA_DIR);
        console_log("Created directory: " + DATA_DIR);
    }
}

// Write a vehicle to lane file with updated turn directions
void write_vehicle(const std::string& id, char lane, int laneNumber, Direction dir = Direction::LEFT) {
    static std::mutex fileMutex;
    std::lock_guard<std::mutex> lock(fileMutex);

    // Skip invalid lane numbers and Lane 1 (shouldn't spawn here)
    if (laneNumber < 1 || laneNumber > 3 || laneNumber == 1) {
        return;
    }

    std::string filepath = DATA_DIR + "/lane" + lane + ".txt";
    std::ofstream file(filepath, std::ios::app);

    if (file.is_open()) {
        // Format: vehicleId_L{laneNumber}:lane
        file << id << "_L" << laneNumber;

        // Add direction info based on lane and specific rules
        if (laneNumber == 3) {
            // Lane 3 always turns left
            file << "_LEFT";
        } else if (laneNumber == 2) {
            // Lane 2 can go straight or left (changed from right to left)
            if (dir == Direction::STRAIGHT) {
                file << "_STRAIGHT";
            } else {
                file << "_LEFT"; // Changed from _RIGHT to _LEFT
            }
        }

        file << ":" << lane << std::endl;
        file.close();

        // Format log message with colors based on lane type
        std::string color = "\033[1;32m"; // Default green
        std::string dirStr = "";

        if (laneNumber == 3) {
            color = "\033[1;32m"; // Green for free lane
            dirStr = " (LEFT turn)";
        } else if (laneNumber == 2 && lane == 'A') {
            color = "\033[1;33m"; // Yellow for priority lane
            dirStr = (dir == Direction::STRAIGHT) ? " (STRAIGHT)" : " (LEFT turn)";
        } else if (laneNumber == 2) {
            color = "\033[1;37m"; // White for normal lane 2
            dirStr = (dir == Direction::STRAIGHT) ? " (STRAIGHT)" : " (LEFT turn)";
        }

        console_log("Added " + id + " to lane " + lane + std::to_string(laneNumber) + dirStr, color);
    } else {
        console_log("ERROR: Could not open file " + filepath, "\033[1;31m");
    }
}

// Generate a random lane (A, B, C, D) - North, East, South, West
char random_lane() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_int_distribution<int> dist(0, 3);
    return 'A' + dist(gen);
}

// Generate a lane number - only Lane 2 or 3 (never Lane 1)
int random_lane_number() {
    static std::random_device rd;
    static std::mt19937 gen(rd());

    // Only generate Lane 2 (60%) or Lane 3 (40%) - never Lane 1
    std::vector<double> weights = {0.0, 0.6, 0.4}; // Weights for lanes 1, 2, 3
    std::discrete_distribution<int> dist(weights.begin(), weights.end());

    return dist(gen) + 1; // Returns 2 or 3
}

// Generate direction (LEFT or STRAIGHT) based on lane rules
Direction random_direction(int laneNumber) {
    static std::random_device rd;
    static std::mt19937 gen(rd());

    if (laneNumber == 3) {
        // Lane 3 always goes left
        return Direction::LEFT;
    } else if (laneNumber == 2) {
        // Lane 2 can go straight (60%) or left (40%) - changed from right to left
        std::vector<double> weights = {0.4, 0.6, 0.0}; // [LEFT, STRAIGHT, RIGHT]
        std::discrete_distribution<int> dist(weights.begin(), weights.end());
        return static_cast<Direction>(dist(gen));
    } else {
        // Lane 1 is incoming lane (shouldn't generate vehicles)
        return Direction::STRAIGHT;
    }
}

// Clear existing files
void clear_files() {
    for (char lane = 'A'; lane <= 'D'; lane++) {
        std::string filepath = DATA_DIR + "/lane" + lane + ".txt";
        std::ofstream file(filepath, std::ios::trunc);
        file.close();
        console_log("Cleared file: " + filepath);
    }
}

// Display status of current generation
void display_status(int current, int total, int a2_count) {
    const int barWidth = 40;
    float progress = static_cast<float>(current) / total;
    int pos = static_cast<int>(barWidth * progress);

    std::cout << "\r\033[1;33m[";
    for (int i = 0; i < barWidth; ++i) {
        if (i < pos) std::cout << "=";
        else if (i == pos) std::cout << ">";
        else std::cout << " ";
    }

    std::cout << "] " << int(progress * 100.0) << "% "
              << "Vehicles: " << current << "/" << total
              << " (A2: " << a2_count << ")\033[0m" << std::flush;
}

// Count current vehicles in each lane from files
std::map<std::string, int> count_vehicles_in_lanes() {
    std::map<std::string, int> counts;

    for (char lane = 'A'; lane <= 'D'; lane++) {
        std::string filepath = DATA_DIR + "/lane" + lane + ".txt";
        std::ifstream file(filepath);

        if (file.is_open()) {
            std::string line;
            while (std::getline(file, line)) {
                // Extract lane number
                size_t lanePos = line.find("_L");
                if (lanePos != std::string::npos && lanePos + 2 < line.length()) {
                    char laneNumChar = line[lanePos + 2];
                    if (laneNumChar >= '1' && laneNumChar <= '3') {
                        std::string laneKey = std::string(1, lane) + laneNumChar;
                        counts[laneKey]++;
                    }
                }
            }
            file.close();
        }
    }

    return counts;
}

// Display current lane statistics
void display_lane_stats() {
    auto counts = count_vehicles_in_lanes();

    std::cout << "\033[1;34m";
    std::cout << "┌────────────────────────────────────┐\n";
    std::cout << "│          Lane Statistics           │\n";
    std::cout << "├────────┬───────┬───────┬───────────┤\n";
    std::cout << "│  Road  │  L1   │  L2   │  L3(Free) │\n";
    std::cout << "├────────┼───────┼───────┼───────────┤\n";

    int total = 0;
    for (char lane = 'A'; lane <= 'D'; lane++) {
        std::string laneLabel;
        switch (lane) {
            case 'A': laneLabel = "A(North)"; break;
            case 'B': laneLabel = "B(East) "; break;
            case 'C': laneLabel = "C(South)"; break;
            case 'D': laneLabel = "D(West) "; break;
        }

        std::cout << "│ " << laneLabel << " │";

        for (int i = 1; i <= 3; i++) {
            std::string laneKey = std::string(1, lane) + std::to_string(i);
            int count = counts[laneKey];
            total += count;

            // Highlight A2 (priority lane) if over threshold
            if (lane == 'A' && i == 2 && count > PRIORITY_THRESHOLD_HIGH) {
                std::cout << " \033[1;33m" << std::setw(5) << count << "\033[1;34m │";
            } else {
                std::cout << " " << std::setw(5) << count << " │";
            }
        }
        std::cout << "\n";
    }

    std::cout << "├────────┴───────┴───────┴───────────┤\n";
    std::cout << "│ Total vehicles: " << std::setw(20) << total << " │\n";
    std::cout << "└────────────────────────────────────┘\033[0m\n";
}

int main() {
    try {
        // Set up signal handler for clean termination
        std::signal(SIGINT, signalHandler);

        // Set up console for colored output
        setupConsole();

        console_log("✅ Traffic generator starting", "\033[1;35m");

        // Create directories and clear files
        ensure_directories();
        clear_files();

        // Random generators
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> delay_dist(0.7, 1.3); // For randomized intervals

        // Global tracking variables
        int total_vehicles = 0;
        int a2_count = 0;
        int current_batch = 0;

        // First generate A2 priority lane vehicles
        console_log("🚦 Generating priority lane vehicles (A2)", "\033[1;33m");
        for (int i = 0; i < 12 && keepRunning; i++) {
            std::string id = "V" + std::to_string(total_vehicles + 1);

            // Alternate between straight and left turns for lane A2
            Direction dir = (i % 2 == 0) ? Direction::STRAIGHT : Direction::LEFT;
            write_vehicle(id, 'A', 2, dir); // Lane A2 with direction

            total_vehicles++;
            a2_count++;
            current_batch++;

            // Display progress
            display_status(current_batch, MAX_VEHICLES_PER_BATCH, a2_count);

            // Wait between vehicles with slight randomization
            std::this_thread::sleep_for(
                std::chrono::milliseconds(
                    static_cast<int>(GENERATION_INTERVAL_MS * delay_dist(gen))
                )
            );
        }

        std::cout << std::endl;
        console_log("🚗 Generating continuous traffic flow", "\033[1;34m");

        // Display starting lane stats
        display_lane_stats();

        // Stats display timer
        auto lastStatsTime = std::chrono::steady_clock::now();
        bool in_priority_mode = false;

        // Continuous generation until terminated
        while (keepRunning) {
            // NEW: Check total vehicle count before generating more
            auto counts = count_vehicles_in_lanes();
            int totalVehiclesInSystem = 0;

            for (char lane = 'A'; lane <= 'D'; lane++) {
                for (int i = 1; i <= 3; i++) {
                    std::string laneKey = std::string(1, lane) + std::to_string(i);
                    totalVehiclesInSystem += counts[laneKey];
                }
            }

            // Only generate new vehicles if below the maximum limit
            if (totalVehiclesInSystem < MAX_TOTAL_VEHICLES) {
                char lane = random_lane();
                int lane_num = random_lane_number(); // Will only return 2 or 3
                Direction dir = random_direction(lane_num);

                // For testing priority condition, occasionally bias toward lane A2
                if (gen() % 10 == 0) {
                    lane = 'A';
                    lane_num = 2;
                    dir = (gen() % 2 == 0) ? Direction::STRAIGHT : Direction::LEFT;
                }

                // Also ensure good distribution for lane 3 (free lane)
                if (gen() % 15 == 0) {
                    lane = random_lane();
                    lane_num = 3; // Force lane 3 (free lane)
                    dir = Direction::LEFT; // Lane 3 always turns left
                }

                std::string id = "V" + std::to_string(total_vehicles + 1);

                // Write vehicle to file with appropriate direction
                write_vehicle(id, lane, lane_num, dir);

                // Update counters
                total_vehicles++;
                current_batch++;
                if (lane == 'A' && lane_num == 2) {
                    a2_count++;
                }

                // Display progress
                display_status(current_batch, MAX_VEHICLES_PER_BATCH, a2_count);
            } else {
                // Skip generation this cycle and wait for vehicles to clear
                console_log("Vehicle limit reached (" + std::to_string(totalVehiclesInSystem) +
                          "/" + std::to_string(MAX_TOTAL_VEHICLES) + ") - waiting", "\033[1;33m");

                // Wait longer between generation attempts when system is full
                std::this_thread::sleep_for(std::chrono::milliseconds(1000));
            }

            // Periodically display lane stats (every 5 seconds)
            auto currentTime = std::chrono::steady_clock::now();
            if (std::chrono::duration_cast<std::chrono::seconds>(currentTime - lastStatsTime).count() >= 5) {
                std::cout << std::endl;
                display_lane_stats();
                lastStatsTime = currentTime;
            }

            // Reset batch counter when it reaches max
            if (current_batch >= MAX_VEHICLES_PER_BATCH) {
                current_batch = 0;
                std::cout << std::endl;
                console_log("♻️ New batch starting", "\033[1;34m");
                display_lane_stats();
            }

            // Check priority lane count and log state changes
            auto currentCounts = count_vehicles_in_lanes();
            int a2_count_current = currentCounts["A2"];

            if (!in_priority_mode && a2_count_current > PRIORITY_THRESHOLD_HIGH) {
                in_priority_mode = true;
                console_log("⚠️ Priority mode activated (A2: " + std::to_string(a2_count_current) +
                          " vehicles)", "\033[1;31m");
            } else if (in_priority_mode && a2_count_current < PRIORITY_THRESHOLD_LOW) {
                in_priority_mode = false;
                console_log("✅ Priority mode deactivated (A2: " + std::to_string(a2_count_current) +
                          " vehicles)", "\033[1;32m");
            }

            // Wait between vehicles with slight randomization
            std::this_thread::sleep_for(
                std::chrono::milliseconds(
                    static_cast<int>(GENERATION_INTERVAL_MS * delay_dist(gen))
                )
            );
        }

        std::cout << std::endl;
        console_log("✅ Traffic generator completed. Generated " +
                   std::to_string(total_vehicles) + " vehicles.", "\033[1;35m");

        return 0;
    }
    catch (const std::exception& e) {
        std::cerr << "\033[1;31mError: " << e.what() << "\033[0m" << std::endl;
        return 1;
    }
}


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\traffic_generator.h =====//

// include/traffic_generator.h
#pragma once
#include <string>
#include <random>
#include <map>
#include <filesystem>
#include <fstream>
#include <thread>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <mutex>

// Define constants similar to those in the main project
namespace Constants {
    static constexpr int MAX_QUEUE_SIZE = 100;
    static constexpr int PRIORITY_THRESHOLD = 10;
    static constexpr int NORMAL_THRESHOLD = 5;

    // Lane IDs (matching the main project)
    enum class LaneId {
        AL1_INCOMING = 0,
        AL2_PRIORITY = 1,
        AL3_FREELANE = 2,
        BL1_INCOMING = 3,
        BL2_NORMAL = 4,
        BL3_FREELANE = 5,
        CL1_INCOMING = 6,
        CL2_NORMAL = 7,
        CL3_FREELANE = 8,
        DL1_INCOMING = 9,
        DL2_NORMAL = 10,
        DL3_FREELANE = 11
    };

    // Direction values
    enum class Direction {
        STRAIGHT = 0,
        LEFT = 1,
        RIGHT = 2
    };
}

// Generator class to create vehicle data
class Generator {
private:
    std::mt19937 rng;  // Random number generator
    std::map<Constants::LaneId, std::filesystem::path> laneFiles;  // Lane file paths
    uint32_t nextVehicleId;  // ID counter for vehicles
    std::filesystem::path dataDir;  // Directory for data files
    std::mutex fileMutex;  // Thread safety for file operations

    // Settings for each lane
    struct LaneConfig {
        double spawnRate;
        int maxVehicles;
        bool canGoStraight;
        bool canGoLeft;
        bool canGoRight;
    };
    std::map<Constants::LaneId, LaneConfig> laneConfigs;

    // Private helper methods
    void initializeLaneFiles();
    void setupLaneConfigs();
    Constants::Direction getRandomDirection(const LaneConfig& config);
    size_t countVehiclesInFile(const std::filesystem::path& filepath) const;
    void writeVehicleToFile(const std::filesystem::path& filepath, uint32_t id,
                          Constants::Direction dir);
    void writeVehicleToCombinedFile(Constants::LaneId lane, uint32_t id);
    bool shouldGenerateVehicle(const LaneConfig& config, size_t currentCount);
    void clearAllFiles();
    void logGeneration(Constants::LaneId lane, uint32_t vehicleId, Constants::Direction dir,
                     size_t currentCount, int maxCount);

public:
    Generator();

    // Generate traffic for all lanes
    void generateTraffic();

    // Display generator status
    void displayStatus() const;
};


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\core\Constants.h =====//

// FILE: include/core/Constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

#include <string>
#include <SDL3/SDL.h>

namespace Constants {
    // Window settings
    constexpr int WINDOW_WIDTH = 800;
    constexpr int WINDOW_HEIGHT = 800;
    const std::string WINDOW_TITLE = "Traffic Junction Simulator";
    constexpr float SCALE = 1.1f;

    // Road settings
    constexpr int ROAD_WIDTH = 150;
    constexpr int LANE_WIDTH = 50;
    constexpr int ARROW_SIZE = 15;

    // Vehicle settings
    constexpr int MAX_VEHICLE_ID = 9999;
    constexpr float VEHICLE_LENGTH = 12.0f;
    constexpr float VEHICLE_WIDTH = 6.0f;
    constexpr float VEHICLE_GAP = 15.0f;
    constexpr float TURN_DURATION = 1500.0f;
    constexpr float BEZIER_CONTROL_OFFSET = 80.0f;
    constexpr float TURN_SPEED = 0.0008f;
    constexpr float MOVE_SPEED = 0.2f;

    // Traffic light settings
    constexpr int ALL_RED_DURATION = 2000; // 2 seconds
    constexpr int GREEN_DURATION_BASE = 3000;   // 3 seconds

    // Queue settings
    constexpr int MAX_QUEUE_SIZE = 100;

    // Priority settings
    constexpr int PRIORITY_THRESHOLD_HIGH = 10; // Enter priority mode when > 10 vehicles
    constexpr int PRIORITY_THRESHOLD_LOW = 5;   // Exit priority mode when < 5 vehicles

    // File paths
    const std::string DATA_PATH = "data/lanes";
    const std::string LOG_FILE = "traffic_simulator.log";

    // Colors
    constexpr SDL_Color ROAD_COLOR = {50, 50, 50, 255};
    constexpr SDL_Color LANE_MARKER_COLOR = {255, 255, 255, 255};
    constexpr SDL_Color YELLOW_MARKER_COLOR = {255, 255, 0, 255};
    constexpr SDL_Color RED_LIGHT_COLOR = {255, 0, 0, 255};
    constexpr SDL_Color GREEN_LIGHT_COLOR = {0, 255, 0, 255};
    constexpr SDL_Color NORMAL_VEHICLE_COLOR = {0, 0, 255, 255};
    constexpr SDL_Color EMERGENCY_VEHICLE_COLOR = {255, 0, 0, 255};
    constexpr SDL_Color PRIORITY_VEHICLE_COLOR = {255, 140, 0, 255}; // Orange for priority lane
    constexpr SDL_Color FREE_LANE_VEHICLE_COLOR = {0, 220, 60, 255}; // Green for free lane
    constexpr SDL_Color PRIORITY_INDICATOR_COLOR = {255, 165, 0, 255};
    constexpr SDL_Color TEXT_COLOR = {255, 255, 255, 255};
    constexpr SDL_Color DEBUG_BACKGROUND_COLOR = {0, 0, 0, 128};
}

#endif // CONSTANTS_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\core\Lane.h =====//

// FILE: include/core/Lane.h
#ifndef LANE_H
#define LANE_H

#include <vector>
#include <string>
#include "core/Vehicle.h"
#include "utils/Queue.h"

class Lane {
public:
    Lane(char laneId, int laneNumber);
    ~Lane();

    // Queue operations
    void enqueue(Vehicle* vehicle);
    Vehicle* dequeue();
    Vehicle* peek() const;
    bool isEmpty() const;
    int getVehicleCount() const;

    // Priority related operations
    int getPriority() const;
    void updatePriority();
    bool isPriorityLane() const;

    // Lane identification
    char getLaneId() const;
    int getLaneNumber() const;
    std::string getName() const;

    // For iteration through vehicles (for rendering)
    const std::vector<Vehicle*>& getVehicles() const;

private:
    char laneId;               // A, B, C, or D
    int laneNumber;            // 1, 2, or 3
    bool isPriority;           // Is this a priority lane (AL2)
    int priority;              // Current priority (higher means served first)
    Queue<Vehicle*> vehicleQueue; // Queue for vehicles in the lane
};

#endif // LANE_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\core\TrafficLight.h =====//

// FILE: include/core/TrafficLight.h
#ifndef TRAFFIC_LIGHT_H
#define TRAFFIC_LIGHT_H

#include <cstdint>
#include <vector>
#include <string>
#include <SDL3/SDL.h>
#include "core/Lane.h"

class TrafficLight {
public:
    enum class State {
        ALL_RED = 0,
        A_GREEN = 1,
        B_GREEN = 2,
        C_GREEN = 3,
        D_GREEN = 4
    };

    TrafficLight();
    ~TrafficLight();

    // Updates the traffic light state based on lane priorities
    void update(const std::vector<Lane*>& lanes);

    // Renders the traffic lights
    void render(SDL_Renderer* renderer);

    // Returns the current traffic light state
    State getCurrentState() const { return currentState; }

    // Returns the next traffic light state
    State getNextState() const { return nextState; }

    // Sets the next traffic light state
    void setNextState(State state);

    // Checks if the specific lane gets green light
    bool isGreen(char lane) const;

private:
    State currentState;
    State nextState;

    // Timing for the green and red states
    const int allRedDuration = 2000; // 2 seconds for all red

    // Last state change time in milliseconds
    uint32_t lastStateChangeTime;

    // Priority mode flag
    bool isPriorityMode;

    // Track when normal mode should resume (after priority mode drops to 5 vehicles)
    bool shouldResumeNormalMode;

    // Helper function to calculate average vehicle count
    float calculateAverageVehicleCount(const std::vector<Lane*>& lanes);

    // Helper drawing functions
    void drawLightForA(SDL_Renderer* renderer, bool isRed);
    void drawLightForB(SDL_Renderer* renderer, bool isRed);
    void drawLightForC(SDL_Renderer* renderer, bool isRed);
    void drawLightForD(SDL_Renderer* renderer, bool isRed);
};

#endif // TRAFFIC_LIGHT_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\core\Vehicle.h =====//

// FILE: include/c// FILE: include/core/Vehicle.h
#ifndef VEHICLE_H
#define VEHICLE_H

#include <string>
#include <SDL3/SDL.h>
#include <ctime>
#include <vector>
#include <sstream>
#include "utils/DebugLogger.h"

// Define all enums here instead of just forward declaring them
enum class Destination {
    STRAIGHT,
    LEFT,
    RIGHT
};

enum class Direction {
    UP,
    DOWN,
    LEFT,
    RIGHT
};

enum class VehicleState {
    APPROACHING,
    IN_INTERSECTION,
    EXITING,
    EXITED
};

// Point structure for waypoints
struct Point {
    float x;
    float y;
};

class Vehicle {
public:
    Vehicle(const std::string& id, char lane, int laneNumber, bool isEmergency = false);
    ~Vehicle();

    // Getters and setters
    std::string getId() const;
    char getLane() const;
    void setLane(char lane);
    int getLaneNumber() const;
    void setLaneNumber(int number);
    bool isEmergencyVehicle() const;
    time_t getArrivalTime() const;

    // Destination control
    void setDestination(Destination dest);
    Destination getDestination() const;

    // Animation related
    float getAnimationPos() const;
    void setAnimationPos(float pos);
    bool isTurning() const;
    void setTurning(bool turning);
    float getTurnProgress() const;
    void setTurnProgress(float progress);
    float getTurnPosX() const;
    void setTurnPosX(float x);
    float getTurnPosY() const;
    void setTurnPosY(float y);

    // Update vehicle position
    void update(uint32_t delta, bool isGreenLight, float targetPos);

    // Render vehicle
    void render(SDL_Renderer* renderer, SDL_Texture* vehicleTexture, int queuePos);

    // Calculate turn path
    void calculateTurnPath(float startX, float startY, float controlX, float controlY,
                          float endX, float endY, float progress);

    // Initialize waypoints for movement path
    void initializeWaypoints();

    // Check if vehicle has exited the screen
    bool hasExited() const { return state == VehicleState::EXITED; }

private:
    std::string id;
    char lane;
    int laneNumber;
    bool isEmergency;
    time_t arrivalTime;

    // Animation properties
    float animPos;
    bool turning;
    float turnProgress;
    float turnPosX;
    float turnPosY;
    int queuePos; // Position in the queue for proper spacing

    // Destination (where the vehicle is heading)
    Destination destination;

    // Current direction of travel
    Direction currentDirection;

    // Vehicle state
    VehicleState state;

    // Waypoints for movement
    std::vector<Point> waypoints;
    size_t currentWaypoint;

    // Helper methods
    float easeInOutQuad(float t) const;

    // Helper for drawing triangles (SDL3 compatible)
    void SDL_RenderFillTriangleF(SDL_Renderer* renderer, float x1, float y1, float x2, float y2, float x3, float y3);
};

#endif // VEHICLE_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\managers\FileHandler.h =====//

// FILE: include/managers/FileHandler.h
#ifndef FILE_HANDLER_H
#define FILE_HANDLER_H

#include <string>
#include <vector>
#include <mutex>
#include "core/Vehicle.h"

class FileHandler {
public:
    FileHandler(const std::string& dataPath = "data/lanes");
    ~FileHandler();

    // Read vehicles from lane files
    std::vector<Vehicle*> readVehiclesFromFiles();

    // Write lane status to file (for debugging/monitoring)
    void writeLaneStatus(char laneId, int laneNumber, int vehicleCount, bool isPriority);

    // Check if files exist/are readable
    bool checkFilesExist();

    // Create directories and empty files if they don't exist
    bool initializeFiles();

private:
    std::string dataPath;
    std::mutex mutex;

    // Lane file paths
    std::string getLaneFilePath(char laneId) const;

    // Read vehicles from a specific lane file
    std::vector<Vehicle*> readVehiclesFromFile(char laneId);

    // Parse a vehicle line from the file
    Vehicle* parseVehicleLine(const std::string& line);

    // Get the lane status file path
    std::string getLaneStatusFilePath() const;
};

#endif // FILE_HANDLER_Hendif // FILE_HANDLER_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\managers\TrafficManager.h =====//

// FILE: include/managers/TrafficManager.h
#ifndef TRAFFIC_MANAGER_H
#define TRAFFIC_MANAGER_H

#include <vector>
#include <map>
#include <atomic>
#include <memory>
#include <string>
#include <SDL3/SDL.h>

#include "core/Lane.h"
#include "core/TrafficLight.h"
#include "managers/FileHandler.h"
#include "utils/PriorityQueue.h"

class TrafficManager {
public:
    TrafficManager();
    ~TrafficManager();

    // Initialize the manager
    bool initialize();

    // Start the manager
    void start();

    // Stop the manager
    void stop();

    // Update the traffic state
    void update(uint32_t delta);

    // Get the lanes for rendering
    const std::vector<Lane*>& getLanes() const;

    // Get the traffic light
    TrafficLight* getTrafficLight() const;

    // Check if a lane is being prioritized
    bool isLanePrioritized(char laneId, int laneNumber) const;

    // Get the priority lane
    Lane* getPriorityLane() const;

    // Get statistics for display
    std::string getStatistics() const;

    // Find lane by ID and number
    Lane* findLane(char laneId, int laneNumber) const;

private:
    // Lanes for each road
    std::vector<Lane*> lanes;

    // Priority queue for lane management
    PriorityQueue<Lane*> lanePriorityQueue;

    // Traffic light
    TrafficLight* trafficLight;

    // File handler for reading vehicle data
    FileHandler* fileHandler;

    // Flag to indicate if the manager is running
    std::atomic<bool> running;

    // Time tracking for periodic operations
    uint32_t lastFileCheckTime;
    uint32_t lastPriorityUpdateTime;

    // Read vehicles from files
    void readVehicles();

  void limitVehiclesPerLane();
  void preventVehicleOverlap();

    // Update lane priorities
    void updatePriorities();

    // Add a vehicle to the appropriate lane
    void addVehicle(Vehicle* vehicle);

    // Process vehicles in lanes
    void processVehicles(uint32_t delta);

    // Check for vehicles leaving the simulation
    void checkVehicleBoundaries();
};

#endif // TRAFFIC_MANAGER_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\utils\DebugLogger.h =====//

#ifndef DEBUG_LOGGER_H
#define DEBUG_LOGGER_H

#include <string>
#include <vector>
#include <mutex>

class DebugLogger {
public:
    // Log levels
    enum class LogLevel {
        INFO,
        WARNING,
        ERROR,
        DEBUG
    };

    // Initialize the logger
    static void initialize(const std::string& logFilePath = "traffic_simulator.log");

    // Log a message with a specific level
    static void log(const std::string& message, LogLevel level = LogLevel::INFO);

    // Get recent log messages for display
    static std::vector<std::string> getRecentLogs(int count = 10);

    // Clear all logs
    static void clearLogs();

    // Shutdown the logger
    static void shutdown();

private:
    static std::string logFilePath;
    static std::vector<std::string> recentLogs;
    static std::mutex logMutex;
    static bool initialized;

    // Get timestamp for log messages
    static std::string getTimestamp();

    // Write to log file
    static void writeToFile(const std::string& message);
};

#endif // DEBUG_LOGGER_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\utils\PriorityQueue.h =====//

// FILE: include/utils/PriorityQueue.h
#ifndef PRIORITY_QUEUE_H
#define PRIORITY_QUEUE_H

#include <vector>
#include <algorithm>
#include <functional>
#include <mutex>

// A priority queue implementation for the traffic simulation
template<typename T>
class PriorityQueue {
public:
    // Element with priority
    struct PriorityElement {
        T element;
        int priority;

        // Constructor
        PriorityElement(const T& e, int p) : element(e), priority(p) {}

        // Comparison operator for std::sort
        bool operator<(const PriorityElement& other) const {
            return priority < other.priority;
        }

        bool operator>(const PriorityElement& other) const {
            return priority > other.priority;
        }
    };

    PriorityQueue() = default;
    ~PriorityQueue() = default;

    // Add element with priority
    void enqueue(const T& element, int priority) {
        std::lock_guard<std::mutex> lock(mutex);

        // Add element with priority
        elements.push_back(PriorityElement(element, priority));

        // Sort in descending order (higher priority first)
        std::sort(elements.begin(), elements.end(), std::greater<PriorityElement>());
    }

    // Get the highest priority element
    T dequeue() {
        std::lock_guard<std::mutex> lock(mutex);

        if (elements.empty()) {
            throw std::runtime_error("PriorityQueue is empty");
        }

        // Get the highest priority element
        T element = elements.front().element;
        elements.erase(elements.begin());

        return element;
    }

    // Peek at the highest priority element without removing it
    T peek() const {
        std::lock_guard<std::mutex> lock(mutex);

        if (elements.empty()) {
            throw std::runtime_error("PriorityQueue is empty");
        }

        return elements.front().element;
    }

    // Update the priority of an element if it exists
    bool updatePriority(const T& element, int newPriority, std::function<bool(const T&, const T&)> comparator) {
        std::lock_guard<std::mutex> lock(mutex);

        // Find the element
        auto it = std::find_if(elements.begin(), elements.end(),
                             [&](const PriorityElement& pe) {
                                 return comparator(pe.element, element);
                             });

        if (it != elements.end()) {
            // Update the priority
            it->priority = newPriority;

            // Re-sort the elements
            std::sort(elements.begin(), elements.end(), std::greater<PriorityElement>());

            return true;
        }

        return false;
    }

    // Check if the queue is empty
    bool isEmpty() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements.empty();
    }

    // Get the size of the queue
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements.size();
    }

    // Clear the queue
    void clear() {
        std::lock_guard<std::mutex> lock(mutex);
        elements.clear();
    }

    // Get all elements in priority order
    std::vector<T> getAllElements() const {
        std::lock_guard<std::mutex> lock(mutex);

        std::vector<T> result;
        result.reserve(elements.size());

        for (const auto& pe : elements) {
            result.push_back(pe.element);
        }

        return result;
    }

private:
    std::vector<PriorityElement> elements;
    mutable std::mutex mutex;
};

#endif // PRIORITY_QUEUE_Hendif // PRIORITY_QUEUE_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\utils\Queue.h =====//

// FILE: include/utils/Queue.h
#ifndef QUEUE_H
#define QUEUE_H

#include <vector>
#include <mutex>
#include <stdexcept>
#include <algorithm>
#include <string>
#include <functional>

// A thread-safe queue implementation for the traffic simulation
template<typename T>
class Queue {
public:
    Queue() = default;
    ~Queue() = default;

    // Add element to the queue
    void enqueue(const T& element) {
        std::lock_guard<std::mutex> lock(mutex);
        elements.push_back(element);
    }

    // Remove and return the front element
    T dequeue() {
        std::lock_guard<std::mutex> lock(mutex);

        if (elements.empty()) {
            throw std::runtime_error("Queue is empty");
        }

        T element = elements.front();
        elements.erase(elements.begin());

        return element;
    }

    // Peek at the front element without removing it
    T peek() const {
        std::lock_guard<std::mutex> lock(mutex);

        if (elements.empty()) {
            throw std::runtime_error("Queue is empty");
        }

        return elements.front();
    }

    // Check if the queue is empty
    bool isEmpty() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements.empty();
    }

    // Get the size of the queue
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements.size();
    }

    // Clear the queue
    void clear() {
        std::lock_guard<std::mutex> lock(mutex);
        elements.clear();
    }

    // Remove a specific element from anywhere in the queue (used for vehicle removal by ID)
    bool remove(const T& element, std::function<bool(const T&, const T&)> comparator) {
        std::lock_guard<std::mutex> lock(mutex);

        auto it = std::find_if(elements.begin(), elements.end(),
                             [&](const T& e) {
                                 return comparator(e, element);
                             });

        if (it != elements.end()) {
            elements.erase(it);
            return true;
        }

        return false;
    }

    // Get all elements for iteration (e.g., for rendering)
    const std::vector<T>& getAllElements() const {
        // Note: This returns a const reference, so caller must not modify the vector
        // This avoids copying the entire vector while still providing access for iteration
        return elements;
    }

private:
    std::vector<T> elements;
    mutable std::mutex mutex;
};

#endif // QUEUE_Hendif // QUEUE_Hendif // QUEUE_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\visualization\DebugOverlay.h =====//

#ifndef DEBUG_OVERLAY_H
#define DEBUG_OVERLAY_H

#include <vector>
#include <string>
#include <SDL3/SDL.h>

// Forward declarations
class TrafficManager;

class DebugOverlay {
public:
    DebugOverlay();
    ~DebugOverlay();

    // Initialize the overlay
    void initialize(TrafficManager* trafficManager);

    // Update overlay data
    void update();

    // Render the overlay
    void render(SDL_Renderer* renderer);

    // Toggle overlay visibility
    void toggleVisibility();

    // Check if overlay is visible
    bool isVisible() const;

    // Add a message to the overlay
    void addMessage(const std::string& message);

    // Clear all messages
    void clearMessages();

private:
    bool visible;
    TrafficManager* trafficManager;
    std::vector<std::string> messages;

    // Render vehicle counts for each lane
    void renderVehicleCounts(SDL_Renderer* renderer);

    // Render traffic light state
    void renderTrafficLightState(SDL_Renderer* renderer);

    // Render priority lane information
    void renderPriorityInfo(SDL_Renderer* renderer);

    // Render custom messages
    void renderMessages(SDL_Renderer* renderer);

    // Helper to render text
    void renderText(SDL_Renderer* renderer, const std::string& text, int x, int y, SDL_Color color);
};

#endif // DEBUG_OVERLAY_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\visualization\Renderer.h =====//

// FILE: include/visualization/Renderer.h
#ifndef RENDERER_H
#define RENDERER_H

#include <SDL3/SDL.h>
#include <string>
#include <vector>
#include <memory>
#include "core/Vehicle.h" // Add this to include Direction enum

class Lane;
class TrafficLight;
class TrafficManager;

class Renderer {
public:
    Renderer();
    ~Renderer();

    // Initialize renderer with window dimensions
    bool initialize(int width, int height, const std::string& title);

    // Start rendering loop
    void startRenderLoop();

    // Set traffic manager to render
    void setTrafficManager(TrafficManager* manager);

    // Render a single frame
    void renderFrame();

    // Clean up resources
    void cleanup();

    // Check if rendering is active
    bool isActive() const;

    // Toggle debug overlay
    void toggleDebugOverlay();

    // Set frame rate limiter
    void setFrameRateLimit(int fps);

private:
    // SDL components
    SDL_Window* window;
    SDL_Renderer* renderer;
    SDL_Texture* carTexture;
    SDL_Surface* surface;

    // Rendering state
    bool active;
    bool showDebugOverlay;
    int frameRateLimit;
    uint32_t lastFrameTime;

    // Window dimensions
    int windowWidth;
    int windowHeight;

    // Traffic manager
    TrafficManager* trafficManager;

    // Helper drawing functions
    void drawRoadsAndLanes();
    void drawTrafficLights();
    void drawVehicles();
    void drawDebugOverlay();
    void drawLaneLabels();
    void drawStatistics();

    // Text rendering (simplified without TTF)
    void drawText(const std::string& text, int x, int y, SDL_Color color);

    // Load textures
    bool loadTextures();

    // Process SDL events
    bool processEvents();

    // Helper to draw a filled road arrow
    void drawArrow(int x1, int y1, int x2, int y2, int x3, int y3, SDL_Color color);

    // Helper to draw a direction arrow - this declaration was missing
    void drawDirectionArrow(int x, int y, Direction dir, SDL_Color color);
};

#endif // RENDERER_Hendif // RENDERER_Hendif // RENDERER_Hendif // RENDERER_H


//===== END FILE: {file_path} =====//

