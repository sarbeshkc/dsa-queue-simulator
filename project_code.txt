// Project Code from CMakeLists.txt
// Total files: 21

//===== FILE: src/core/Vehicle.cpp =====//

// FILE: src/core/Vehicle.cpp
#include "core/Vehicle.h"
#include "core/Constants.h"
#include "utils/DebugLogger.h"
#include <cmath>
#include <sstream>

Vehicle::Vehicle(const std::string& id, char lane, int laneNumber, bool isEmergency)
    : id(id),
      lane(lane),
      laneNumber(laneNumber),
      isEmergency(isEmergency),
      arrivalTime(time(nullptr)),
      animPos(0.0f),
      turning(false),
      turnProgress(0.0f),
      turnPosX(0.0f),
      turnPosY(0.0f),
      destination(Destination::STRAIGHT),
      currentDirection(Direction::DOWN),
      state(VehicleState::APPROACHING),
      currentWaypoint(0) {

    // Log creation
    std::ostringstream oss;
    oss << "Created vehicle " << id << " in lane " << lane << laneNumber;
    DebugLogger::log(oss.str());

    // Window dimensions
    const int windowWidth = 800;
    const int windowHeight = 800;
    const int centerX = windowWidth / 2;
    const int centerY = windowHeight / 2;

    // Determine current direction based on lane
    // A is North (top), B is East (right), C is South (bottom), D is West (left)
    switch (lane) {
        case 'A': currentDirection = Direction::DOWN; break;  // Coming from North, moving South
        case 'B': currentDirection = Direction::LEFT; break;  // Coming from East, moving West
        case 'C': currentDirection = Direction::UP; break;    // Coming from South, moving North
        case 'D': currentDirection = Direction::RIGHT; break; // Coming from West, moving East
    }

    // Adjust lane offsets for better spacing
    const float laneOffset = 15.0f;

    // Set initial position based on lane and direction
    switch (currentDirection) {
        case Direction::DOWN: // From North (A)
            turnPosX = centerX + (laneNumber - 2) * laneOffset;
            turnPosY = 20.0f;  // Start at top of screen
            break;
        case Direction::UP: // From South (C)
            turnPosX = centerX - (laneNumber - 2) * laneOffset;
            turnPosY = windowHeight - 20.0f;  // Start at bottom of screen
            break;
        case Direction::LEFT: // From East (B)
            turnPosX = windowWidth - 20.0f;  // Start at right of screen
            turnPosY = centerY + (laneNumber - 2) * laneOffset;
            break;
        case Direction::RIGHT: // From West (D)
            turnPosX = 20.0f;  // Start at left of screen
            turnPosY = centerY - (laneNumber - 2) * laneOffset;
            break;
    }

    // Set initial animation position
    animPos = (currentDirection == Direction::UP || currentDirection == Direction::DOWN) ?
              turnPosY : turnPosX;

    // Determine destination based on lane number and rules from assignment
    if (laneNumber == 3) {
        // Free lane (L3) always turns left
        destination = Destination::LEFT;

        // Log the left turn for L3
        std::ostringstream ossL3;
        ossL3 << "Vehicle " << id << " on lane " << lane << laneNumber << " will turn LEFT (free lane rule)";
        DebugLogger::log(ossL3.str());
    }
    else if (laneNumber == 2) {
        // Lane 2 can go straight or turn right (based on vehicle ID hash)
        // Use the last digit of the id for randomization (this ensures reproducibility)
        int idHash = 0;
        for (char c : id) idHash += c;

        // 60% straight, 40% right turn
        destination = (idHash % 10 < 6) ? Destination::STRAIGHT : Destination::RIGHT;

        // Log the chosen direction
        std::ostringstream ossL2;
        ossL2 << "Vehicle " << id << " on lane " << lane << laneNumber << " will go "
             << (destination == Destination::STRAIGHT ? "STRAIGHT" : "RIGHT");
        DebugLogger::log(ossL2.str());
    }
    else if (laneNumber == 1) {
        // Lane 1 is incoming lane, doesn't affect behavior
        destination = Destination::STRAIGHT;
    }

    // Initialize waypoints for path planning
    initializeWaypoints();
}

Vehicle::~Vehicle() {
    std::ostringstream oss;
    oss << "Destroyed vehicle " << id;
    DebugLogger::log(oss.str());
}

void Vehicle::initializeWaypoints() {
    // Window dimensions
    const int windowWidth = 800;
    const int windowHeight = 800;
    const int centerX = windowWidth / 2;
    const int centerY = windowHeight / 2;

    // Clear existing waypoints
    waypoints.clear();

    // Adjust intersection boundaries for better visualization
    const float intersectionHalf = 50.0f;
    const float leftEdge = centerX - intersectionHalf;
    const float rightEdge = centerX + intersectionHalf;
    const float topEdge = centerY - intersectionHalf;
    const float bottomEdge = centerY + intersectionHalf;

    // Lane offsets - more spacing for better visualization
    const float laneOffset = 15.0f;

    // Add the starting position as first waypoint
    waypoints.push_back({turnPosX, turnPosY});

    // Add approach to intersection waypoint
    switch (currentDirection) {
        case Direction::DOWN: // From North (A)
            waypoints.push_back({turnPosX, topEdge - 5.0f});
            break;
        case Direction::UP: // From South (C)
            waypoints.push_back({turnPosX, bottomEdge + 5.0f});
            break;
        case Direction::LEFT: // From East (B)
            waypoints.push_back({rightEdge + 5.0f, turnPosY});
            break;
        case Direction::RIGHT: // From West (D)
            waypoints.push_back({leftEdge - 5.0f, turnPosY});
            break;
    }

    // Add path through intersection based on destination and rules from assignment
    if (destination == Destination::STRAIGHT) {
        // For going straight: From L2 to opposite road's L1
        switch (currentDirection) {
            case Direction::DOWN:  // A to C (North to South)
                waypoints.push_back({turnPosX, bottomEdge + 5.0f});  // Exit point
                waypoints.push_back({turnPosX, windowHeight + 30.0f});  // Off screen
                break;
            case Direction::UP:    // C to A (South to North)
                waypoints.push_back({turnPosX, topEdge - 5.0f});
                waypoints.push_back({turnPosX, -30.0f});
                break;
            case Direction::LEFT:  // B to D (East to West)
                waypoints.push_back({leftEdge - 5.0f, turnPosY});
                waypoints.push_back({-30.0f, turnPosY});
                break;
            case Direction::RIGHT: // D to B (West to East)
                waypoints.push_back({rightEdge + 5.0f, turnPosY});
                waypoints.push_back({windowWidth + 30.0f, turnPosY});
                break;
        }
    }
    else if (destination == Destination::LEFT) {
        // For L3 left turns: Always goes to the target road's L1
        float centerPointX, centerPointY, exitPointX, exitPointY;

        switch (currentDirection) {
            case Direction::DOWN:  // A to D - From North to West's L1
                centerPointX = centerX - 20.0f;
                centerPointY = centerY - 20.0f;
                exitPointX = leftEdge - 5.0f;
                exitPointY = centerY - laneOffset;  // Lane 1 position (D)

                waypoints.push_back({centerPointX, centerPointY});  // Turn center
                waypoints.push_back({exitPointX, exitPointY});      // Exit point
                waypoints.push_back({-30.0f, exitPointY});          // Off screen
                break;

            case Direction::UP:    // C to B - From South to East's L1
                centerPointX = centerX + 20.0f;
                centerPointY = centerY + 20.0f;
                exitPointX = rightEdge + 5.0f;
                exitPointY = centerY + laneOffset;  // Lane 1 position (B)

                waypoints.push_back({centerPointX, centerPointY});
                waypoints.push_back({exitPointX, exitPointY});
                waypoints.push_back({windowWidth + 30.0f, exitPointY});
                break;

            case Direction::LEFT:  // B to A - From East to North's L1
                centerPointX = centerX + 20.0f;
                centerPointY = centerY - 20.0f;
                exitPointX = centerX + laneOffset;  // Lane 1 position (A)
                exitPointY = topEdge - 5.0f;

                waypoints.push_back({centerPointX, centerPointY});
                waypoints.push_back({exitPointX, exitPointY});
                waypoints.push_back({exitPointX, -30.0f});
                break;

            case Direction::RIGHT: // D to C - From West to South's L1
                centerPointX = centerX - 20.0f;
                centerPointY = centerY + 20.0f;
                exitPointX = centerX - laneOffset;  // Lane 1 position (C)
                exitPointY = bottomEdge + 5.0f;

                waypoints.push_back({centerPointX, centerPointY});
                waypoints.push_back({exitPointX, exitPointY});
                waypoints.push_back({exitPointX, windowHeight + 30.0f});
                break;
        }
    }
    else if (destination == Destination::RIGHT) {
        // For L2 right turns: Goes to the clockwise road's L1
        float centerPointX, centerPointY, exitPointX, exitPointY;

        switch (currentDirection) {
            case Direction::DOWN:  // A to B - From North to East's L1
                centerPointX = centerX + 20.0f;
                centerPointY = centerY - 20.0f;
                exitPointX = rightEdge + 5.0f;
                exitPointY = centerY - laneOffset;  // Lane 1 position (B)

                waypoints.push_back({centerPointX, centerPointY});
                waypoints.push_back({exitPointX, exitPointY});
                waypoints.push_back({windowWidth + 30.0f, exitPointY});
                break;

            case Direction::UP:    // C to D - From South to West's L1
                centerPointX = centerX - 20.0f;
                centerPointY = centerY + 20.0f;
                exitPointX = leftEdge - 5.0f;
                exitPointY = centerY + laneOffset;  // Lane 1 position (D)

                waypoints.push_back({centerPointX, centerPointY});
                waypoints.push_back({exitPointX, exitPointY});
                waypoints.push_back({-30.0f, exitPointY});
                break;

            case Direction::LEFT:  // B to C - From East to South's L1
                centerPointX = centerX + 20.0f;
                centerPointY = centerY + 20.0f;
                exitPointX = centerX + laneOffset;  // Lane 1 position (C)
                exitPointY = bottomEdge + 5.0f;

                waypoints.push_back({centerPointX, centerPointY});
                waypoints.push_back({exitPointX, exitPointY});
                waypoints.push_back({exitPointX, windowHeight + 30.0f});
                break;

            case Direction::RIGHT: // D to A - From West to North's L1
                centerPointX = centerX - 20.0f;
                centerPointY = centerY - 20.0f;
                exitPointX = centerX - laneOffset;  // Lane 1 position (A)
                exitPointY = topEdge - 5.0f;

                waypoints.push_back({centerPointX, centerPointY});
                waypoints.push_back({exitPointX, exitPointY});
                waypoints.push_back({exitPointX, -30.0f});
                break;
        }
    }

    // Set current waypoint index
    currentWaypoint = 0;
    turning = false;
}

std::string Vehicle::getId() const {
    return id;
}

char Vehicle::getLane() const {
    return lane;
}

void Vehicle::setLane(char lane) {
    this->lane = lane;
}

int Vehicle::getLaneNumber() const {
    return laneNumber;
}

void Vehicle::setLaneNumber(int number) {
    this->laneNumber = number;
}

bool Vehicle::isEmergencyVehicle() const {
    return isEmergency;
}

time_t Vehicle::getArrivalTime() const {
    return arrivalTime;
}

float Vehicle::getAnimationPos() const {
    return animPos;
}

void Vehicle::setAnimationPos(float pos) {
    this->animPos = pos;
}

bool Vehicle::isTurning() const {
    return turning;
}

void Vehicle::setTurning(bool turning) {
    this->turning = turning;
}

float Vehicle::getTurnProgress() const {
    return turnProgress;
}

void Vehicle::setTurnProgress(float progress) {
    this->turnProgress = progress;
}

float Vehicle::getTurnPosX() const {
    return turnPosX;
}

void Vehicle::setTurnPosX(float x) {
    this->turnPosX = x;
}

float Vehicle::getTurnPosY() const {
    return turnPosY;
}

void Vehicle::setTurnPosY(float y) {
    this->turnPosY = y;
}

float Vehicle::easeInOutQuad(float t) const {
    return t < 0.5f ? 2.0f * t * t : -1.0f + (4.0f - 2.0f * t) * t;
}

void Vehicle::update(uint32_t delta, bool isGreenLight, float targetPos) {
    // Fine-tune speed for smoother animation
    const float SPEED = 0.02f * delta;

    // Free lane (lane 3) always has green light
    bool canMove = isGreenLight || laneNumber == 3;

    if (canMove) {
        // We have more waypoints to travel
        if (currentWaypoint < waypoints.size() - 1) {
            // Get current and next waypoint
            auto& current = waypoints[currentWaypoint];
            auto& next = waypoints[currentWaypoint + 1];

            // Calculate direction vector
            float dx = next.x - turnPosX;
            float dy = next.y - turnPosY;

            // Calculate distance to next waypoint
            float distance = std::sqrt(dx*dx + dy*dy);

            // If close enough to waypoint, move to next
            if (distance < 3.0f) {
                currentWaypoint++;

                // If entering the intersection and turning, flag as turning
                if (currentWaypoint == 2 &&
                    (destination == Destination::LEFT || destination == Destination::RIGHT)) {
                    turning = true;
                    turnProgress = 0.0f;
                    state = VehicleState::IN_INTERSECTION;

                    // Log turn start
                    std::ostringstream oss;
                    oss << "Vehicle " << id << " is now turning "
                        << (destination == Destination::LEFT ? "LEFT" : "RIGHT");
                    DebugLogger::log(oss.str());
                }

                // If exiting the intersection
                if (currentWaypoint == 3) {
                    turning = false;
                    state = VehicleState::EXITING;

                    // Update lane and number based on destination and direction
                    // This follows the assignment rules for lane changes
                    switch (currentDirection) {
                        case Direction::DOWN:  // From North (A)
                            if (destination == Destination::LEFT) {
                                lane = 'D';  // Go to West
                                laneNumber = 1;
                                currentDirection = Direction::RIGHT;
                                DebugLogger::log("Vehicle " + id + " now on D1 (turned LEFT from A)");
                            }
                            else if (destination == Destination::RIGHT) {
                                lane = 'B';  // Go to East
                                laneNumber = 1;
                                currentDirection = Direction::LEFT;
                                DebugLogger::log("Vehicle " + id + " now on B1 (turned RIGHT from A)");
                            }
                            else {
                                // Going straight to South
                                lane = 'C';
                                laneNumber = 1;
                                DebugLogger::log("Vehicle " + id + " now on C1 (going STRAIGHT from A)");
                            }
                            break;

                        case Direction::UP:    // From South (C)
                            if (destination == Destination::LEFT) {
                                lane = 'B';  // Go to East
                                laneNumber = 1;
                                currentDirection = Direction::LEFT;
                                DebugLogger::log("Vehicle " + id + " now on B1 (turned LEFT from C)");
                            }
                            else if (destination == Destination::RIGHT) {
                                lane = 'D';  // Go to West
                                laneNumber = 1;
                                currentDirection = Direction::RIGHT;
                                DebugLogger::log("Vehicle " + id + " now on D1 (turned RIGHT from C)");
                            }
                            else {
                                // Going straight to North
                                lane = 'A';
                                laneNumber = 1;
                                DebugLogger::log("Vehicle " + id + " now on A1 (going STRAIGHT from C)");
                            }
                            break;

                        case Direction::LEFT:  // From East (B)
                            if (destination == Destination::LEFT) {
                                lane = 'A';  // Go to North
                                laneNumber = 1;
                                currentDirection = Direction::DOWN;
                                DebugLogger::log("Vehicle " + id + " now on A1 (turned LEFT from B)");
                            }
                            else if (destination == Destination::RIGHT) {
                                lane = 'C';  // Go to South
                                laneNumber = 1;
                                currentDirection = Direction::UP;
                                DebugLogger::log("Vehicle " + id + " now on C1 (turned RIGHT from B)");
                            }
                            else {
                                // Going straight to West
                                lane = 'D';
                                laneNumber = 1;
                                DebugLogger::log("Vehicle " + id + " now on D1 (going STRAIGHT from B)");
                            }
                            break;

                        case Direction::RIGHT: // From West (D)
                            if (destination == Destination::LEFT) {
                                lane = 'C';  // Go to South
                                laneNumber = 1;
                                currentDirection = Direction::UP;
                                DebugLogger::log("Vehicle " + id + " now on C1 (turned LEFT from D)");
                            }
                            else if (destination == Destination::RIGHT) {
                                lane = 'A';  // Go to North
                                laneNumber = 1;
                                currentDirection = Direction::DOWN;
                                DebugLogger::log("Vehicle " + id + " now on A1 (turned RIGHT from D)");
                            }
                            else {
                                // Going straight to East
                                lane = 'B';
                                laneNumber = 1;
                                DebugLogger::log("Vehicle " + id + " now on B1 (going STRAIGHT from D)");
                            }
                            break;
                    }
                }
            }

            // Move toward next waypoint
            if (distance > 0) {
                // Normalize direction vector
                dx /= distance;
                dy /= distance;

                // Move toward waypoint
                turnPosX += dx * SPEED;
                turnPosY += dy * SPEED;

                // Update animation position for future reference
                animPos = (currentDirection == Direction::UP || currentDirection == Direction::DOWN) ?
                         turnPosY : turnPosX;
            }

            // Update turn progress for visualization
            if (turning) {
                turnProgress = std::min(1.0f, turnProgress + 0.002f * delta);
            }
        }

        // Check if we've reached the last waypoint
        if (currentWaypoint == waypoints.size() - 1) {
            // Get screen dimensions
            const int windowWidth = 800;
            const int windowHeight = 800;

            // Check if off-screen
            if (turnPosX < -30.0f || turnPosX > windowWidth + 30.0f ||
                turnPosY < -30.0f || turnPosY > windowHeight + 30.0f) {
                // Flag for removal
                state = VehicleState::EXITED;
            }
        }
    }
    else {
        // Red light - move until we reach the stop line
        if (currentWaypoint == 0) {
            // Get the stop line waypoint
            auto& stopLine = waypoints[1];

            // Calculate direction and distance to stop line
            float dx = stopLine.x - turnPosX;
            float dy = stopLine.y - turnPosY;
            float distance = std::sqrt(dx*dx + dy*dy);

            // Only approach if not too close to stop line
            if (distance > 5.0f) {
                // Normalize direction
                dx /= distance;
                dy /= distance;

                // Move toward stop line
                turnPosX += dx * SPEED;
                turnPosY += dy * SPEED;

                // Update animation position
                animPos = (currentDirection == Direction::UP || currentDirection == Direction::DOWN) ?
                         turnPosY : turnPosX;
            }
        }
    }
}

void Vehicle::calculateTurnPath(float startX, float startY, float controlX, float controlY,
                              float endX, float endY, float progress) {
    // Quadratic bezier curve calculation for smooth turning
    float oneMinusT = 1.0f - progress;

    // Calculate position on the curve
    turnPosX = oneMinusT * oneMinusT * startX +
               2.0f * oneMinusT * progress * controlX +
               progress * progress * endX;

    turnPosY = oneMinusT * oneMinusT * startY +
               2.0f * oneMinusT * progress * controlY +
               progress * progress * endY;
}

void Vehicle::render(SDL_Renderer* renderer, SDL_Texture* vehicleTexture, int queuePos) {
    // Set vehicle color based on lane, lane number, and turning status
    SDL_Color color;

    if (isEmergency) {
        color = {255, 0, 0, 255}; // Red for emergency
    }
    else if (laneNumber == 2 && lane == 'A') {
        // AL2 is priority lane - highlight with orange
        color = {255, 140, 0, 255}; // Brighter orange for priority lane
    }
    else if (laneNumber == 3) {
        // Free lane - green
        color = {0, 220, 60, 255}; // Brighter green for free lane
    }
    else if (laneNumber == 1) {
        // Lane 1 - blue/cyan
        color = {0, 140, 255, 255}; // Bright blue for lane 1
    }
    else {
        // Regular vehicles, choose by destination
        switch (static_cast<int>(destination)) {
            case static_cast<int>(Destination::STRAIGHT):
                color = {120, 120, 200, 255}; break; // Light blue for straight
            case static_cast<int>(Destination::LEFT):
                color = {200, 120, 120, 255}; break; // Light red for left turn
            case static_cast<int>(Destination::RIGHT):
                color = {120, 200, 120, 255}; break; // Light green for right turn
            default:
                color = {180, 180, 180, 255}; break; // Gray default
        }
    }

    // If turning, make the color a bit brighter
    if (turning) {
        color.r = std::min(255, color.r + 40);
        color.g = std::min(255, color.g + 40);
        color.b = std::min(255, color.b + 40);
    }

    // Set color for vehicle
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);

    // Enhanced vehicle dimensions for better visibility
    float vehicleWidth = 7.0f;
    float vehicleLength = 14.0f;

    // Draw vehicle rectangle based on orientation
    SDL_FRect vehicleRect;

    if (turning) {
        // For turning vehicles, adjust dimensions gradually
        float progress = turnProgress;
        float width = vehicleWidth;
        float length = vehicleLength;

        // During turn, gradually change dimensions for smoother appearance
        if (currentDirection == Direction::UP || currentDirection == Direction::DOWN) {
            // Transitioning from vertical to horizontal
            if (destination == Destination::LEFT || destination == Destination::RIGHT) {
                width = vehicleWidth * (1.0f - progress) + vehicleLength * progress;
                length = vehicleLength * (1.0f - progress) + vehicleWidth * progress;
            }
        } else {
            // Transitioning from horizontal to vertical
            if (destination == Destination::LEFT || destination == Destination::RIGHT) {
                width = vehicleLength * (1.0f - progress) + vehicleWidth * progress;
                length = vehicleWidth * (1.0f - progress) + vehicleLength * progress;
            }
        }

        vehicleRect = {turnPosX - width/2, turnPosY - length/2, width, length};
    } else {
        // Non-turning vehicles have fixed orientation based on direction
        switch (currentDirection) {
            case Direction::DOWN:
            case Direction::UP:
                // Vertical roads (taller than wide)
                vehicleRect = {turnPosX - vehicleWidth/2, turnPosY - vehicleLength/2, vehicleWidth, vehicleLength};
                break;
            case Direction::LEFT:
            case Direction::RIGHT:
                // Horizontal roads (wider than tall)
                vehicleRect = {turnPosX - vehicleLength/2, turnPosY - vehicleWidth/2, vehicleLength, vehicleWidth};
                break;
        }
    }

    // Draw the vehicle
    SDL_RenderFillRect(renderer, &vehicleRect);

    // Add a darker front to the vehicle for better visibility
    SDL_SetRenderDrawColor(renderer,
                          color.r * 0.7f,
                          color.g * 0.7f,
                          color.b * 0.7f,
                          color.a);

    SDL_FRect frontRect;
    if (!turning) {
        switch (currentDirection) {
            case Direction::DOWN:
                // Front of vehicle (bottom part for downward movement)
                frontRect = {vehicleRect.x, vehicleRect.y + vehicleRect.h * 0.6f, vehicleRect.w, vehicleRect.h * 0.4f};
                break;
            case Direction::UP:
                // Front of vehicle (top part for upward movement)
                frontRect = {vehicleRect.x, vehicleRect.y, vehicleRect.w, vehicleRect.h * 0.4f};
                break;
            case Direction::LEFT:
                // Front of vehicle (left part for leftward movement)
                frontRect = {vehicleRect.x, vehicleRect.y, vehicleRect.w * 0.4f, vehicleRect.h};
                break;
            case Direction::RIGHT:
                // Front of vehicle (right part for rightward movement)
                frontRect = {vehicleRect.x + vehicleRect.w * 0.6f, vehicleRect.y, vehicleRect.w * 0.4f, vehicleRect.h};
                break;
        }

        SDL_RenderFillRect(renderer, &frontRect);
    }

    // Add enhanced indicator based on destination
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255); // White

    float indicatorSize = 2.0f; // Bigger for better visibility
    float indicatorOffset = 3.0f;

    if (destination == Destination::LEFT) {
        // Left turn indicator (small white triangle)
        // Position depends on direction
        SDL_FPoint leftIndicator[3];

        switch (currentDirection) {
            case Direction::DOWN:
                leftIndicator[0] = {vehicleRect.x + indicatorOffset, vehicleRect.y + indicatorOffset};
                leftIndicator[1] = {vehicleRect.x + indicatorOffset + indicatorSize*2, vehicleRect.y + indicatorOffset};
                leftIndicator[2] = {vehicleRect.x + indicatorOffset, vehicleRect.y + indicatorOffset + indicatorSize*2};
                break;
            case Direction::UP:
                leftIndicator[0] = {vehicleRect.x + vehicleRect.w - indicatorOffset, vehicleRect.y + indicatorOffset};
                leftIndicator[1] = {vehicleRect.x + vehicleRect.w - indicatorOffset - indicatorSize*2, vehicleRect.y + indicatorOffset};
                leftIndicator[2] = {vehicleRect.x + vehicleRect.w - indicatorOffset, vehicleRect.y + indicatorOffset + indicatorSize*2};
                break;
            case Direction::LEFT:
                leftIndicator[0] = {vehicleRect.x + indicatorOffset, vehicleRect.y + vehicleRect.h - indicatorOffset};
                leftIndicator[1] = {vehicleRect.x + indicatorOffset, vehicleRect.y + vehicleRect.h - indicatorOffset - indicatorSize*2};
                leftIndicator[2] = {vehicleRect.x + indicatorOffset + indicatorSize*2, vehicleRect.y + vehicleRect.h - indicatorOffset};
                break;
            case Direction::RIGHT:
                leftIndicator[0] = {vehicleRect.x + indicatorOffset, vehicleRect.y + indicatorOffset};
                leftIndicator[1] = {vehicleRect.x + indicatorOffset, vehicleRect.y + indicatorOffset + indicatorSize*2};
                leftIndicator[2] = {vehicleRect.x + indicatorOffset + indicatorSize*2, vehicleRect.y + indicatorOffset};
                break;
        }

        // Draw triangle
        SDL_RenderFillTriangleF(renderer,
                               leftIndicator[0].x, leftIndicator[0].y,
                               leftIndicator[1].x, leftIndicator[1].y,
                               leftIndicator[2].x, leftIndicator[2].y);
    }
    else if (destination == Destination::RIGHT) {
        // Right turn indicator (small white triangle pointing right)
        SDL_FPoint rightIndicator[3];

        switch (currentDirection) {
            case Direction::DOWN:
                rightIndicator[0] = {vehicleRect.x + vehicleRect.w - indicatorOffset, vehicleRect.y + indicatorOffset};
                rightIndicator[1] = {vehicleRect.x + vehicleRect.w - indicatorOffset - indicatorSize*2, vehicleRect.y + indicatorOffset};
                rightIndicator[2] = {vehicleRect.x + vehicleRect.w - indicatorOffset, vehicleRect.y + indicatorOffset + indicatorSize*2};
                break;
            case Direction::UP:
                rightIndicator[0] = {vehicleRect.x + indicatorOffset, vehicleRect.y + indicatorOffset};
                rightIndicator[1] = {vehicleRect.x + indicatorOffset + indicatorSize*2, vehicleRect.y + indicatorOffset};
                rightIndicator[2] = {vehicleRect.x + indicatorOffset, vehicleRect.y + indicatorOffset + indicatorSize*2};
                break;
            case Direction::LEFT:
                rightIndicator[0] = {vehicleRect.x + indicatorOffset, vehicleRect.y + indicatorOffset};
                rightIndicator[1] = {vehicleRect.x + indicatorOffset, vehicleRect.y + indicatorOffset + indicatorSize*2};
                rightIndicator[2] = {vehicleRect.x + indicatorOffset + indicatorSize*2, vehicleRect.y + indicatorOffset};
                break;
            case Direction::RIGHT:
                rightIndicator[0] = {vehicleRect.x + indicatorOffset, vehicleRect.y + vehicleRect.h - indicatorOffset};
                rightIndicator[1] = {vehicleRect.x + indicatorOffset, vehicleRect.y + vehicleRect.h - indicatorOffset - indicatorSize*2};
                rightIndicator[2] = {vehicleRect.x + indicatorOffset + indicatorSize*2, vehicleRect.y + vehicleRect.h - indicatorOffset};
                break;
        }

        // Draw triangle
        SDL_RenderFillTriangleF(renderer,
                               rightIndicator[0].x, rightIndicator[0].y,
                               rightIndicator[1].x, rightIndicator[1].y,
                               rightIndicator[2].x, rightIndicator[2].y);
    }
    else {
        // Straight indicator (center line)
        SDL_FRect indicator;

        switch (currentDirection) {
            case Direction::DOWN:
            case Direction::UP:
                indicator = {
                    vehicleRect.x + vehicleRect.w/2 - indicatorSize/2,
                    vehicleRect.y + indicatorOffset,
                    indicatorSize,
                    indicatorSize*3
                };
                break;
            case Direction::LEFT:
            case Direction::RIGHT:
                indicator = {
                    vehicleRect.x + indicatorOffset,
                    vehicleRect.y + vehicleRect.h/2 - indicatorSize/2,
                    indicatorSize*3,
                    indicatorSize
                };
                break;
        }

        SDL_RenderFillRect(renderer, &indicator);
    }

    // Add lane number indicator (for better visibility of which lane it's in)
    SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255); // Yellow

    SDL_FRect laneIndicator;
    const float indicatorSize2 = 3.0f;

    // Position at the rear of vehicle
    switch (currentDirection) {
        case Direction::DOWN:
            laneIndicator = {
                vehicleRect.x + vehicleRect.w/2 - indicatorSize2/2,
                vehicleRect.y + 2.0f,
                indicatorSize2,
                indicatorSize2
            };
            break;
        case Direction::UP:
            laneIndicator = {
                vehicleRect.x + vehicleRect.w/2 - indicatorSize2/2,
                vehicleRect.y + vehicleRect.h - indicatorSize2 - 2.0f,
                indicatorSize2,
                indicatorSize2
            };
            break;
        case Direction::LEFT:
            laneIndicator = {
                vehicleRect.x + vehicleRect.w - indicatorSize2 - 2.0f,
                vehicleRect.y + vehicleRect.h/2 - indicatorSize2/2,
                indicatorSize2,
                indicatorSize2
            };
            break;
        case Direction::RIGHT:
            laneIndicator = {
                vehicleRect.x + 2.0f,
                vehicleRect.y + vehicleRect.h/2 - indicatorSize2/2,
                indicatorSize2,
                indicatorSize2
            };
            break;
    }

    // Draw one, two, or three dots based on lane number
    for (int i = 0; i < laneNumber; i++) {
        SDL_RenderFillRect(renderer, &laneIndicator);

        // Move the indicator for next dot
        switch (currentDirection) {
            case Direction::DOWN:
            case Direction::UP:
                laneIndicator.x += indicatorSize2 * 1.5f;
                break;
            case Direction::LEFT:
            case Direction::RIGHT:
                laneIndicator.y += indicatorSize2 * 1.5f;
                break;
        }
    }
}

// Helper for drawing triangles (SDL3 compatible)
void Vehicle::SDL_RenderFillTriangleF(SDL_Renderer* renderer, float x1, float y1, float x2, float y2, float x3, float y3) {
    // Convert to array of SDL_Vertex for SDL_RenderGeometry
    SDL_Vertex vertices[3];

    // Create a white color in SDL_FColor format
    SDL_FColor fcolor = {
        1.0f,  // r (normalized to 0.0-1.0)
        1.0f,  // g
        1.0f,  // b
        1.0f   // a
    };

    // First vertex
    vertices[0].position.x = x1;
    vertices[0].position.y = y1;
    vertices[0].color = fcolor;

    // Second vertex
    vertices[1].position.x = x2;
    vertices[1].position.y = y2;
    vertices[1].color = fcolor;

    // Third vertex
    vertices[2].position.x = x3;
    vertices[2].position.y = y3;
    vertices[2].color = fcolor;

    // Draw the triangle
    SDL_RenderGeometry(renderer, NULL, vertices, 3, NULL, 0);
}


//===== END FILE: {file_path} =====//

//===== FILE: src/core/Lane.cpp =====//

// FILE: src/core/Lane.cpp
#include "core/Lane.h"
#include "utils/DebugLogger.h"
#include <sstream>
#include "core/Constants.h"

Lane::Lane(char laneId, int laneNumber)
    : laneId(laneId),
      laneNumber(laneNumber),
      isPriority(laneId == 'A' && laneNumber == 2), // AL2 is the priority lane
      priority(0) {

    std::ostringstream oss;
    oss << "Created lane " << laneId << laneNumber;
    DebugLogger::log(oss.str());
}

Lane::~Lane() {
    std::lock_guard<std::mutex> lock(mutex);
    // Clean up vehicles
    for (auto* vehicle : vehicles) {
        delete vehicle;
    }
    vehicles.clear();
}

void Lane::enqueue(Vehicle* vehicle) {
    int currentCount;
    {
        std::lock_guard<std::mutex> lock(mutex);
        // Add the vehicle to the queue
        vehicles.push_back(vehicle);
        currentCount = vehicles.size();
    }

    // Log the action
    std::ostringstream oss;
    oss << "Vehicle " << vehicle->getId() << " added to lane " << laneId << laneNumber;
    DebugLogger::log(oss.str());

    // Update priority if this is the priority lane
    if (isPriority) {
        if (currentCount > Constants::PRIORITY_THRESHOLD_HIGH) {
            priority = 100; // High priority
            std::ostringstream oss;
            oss << "Lane " << laneId << laneNumber
                << " priority increased (vehicles: " << currentCount << ")";
            DebugLogger::log(oss.str());
        }
        else if (currentCount < Constants::PRIORITY_THRESHOLD_LOW) {
            priority = 0; // Normal priority
            std::ostringstream oss;
            oss << "Lane " << laneId << laneNumber
                << " priority reset to normal (vehicles: " << currentCount << ")";
            DebugLogger::log(oss.str());
        }
    }
}

Vehicle* Lane::dequeue() {
    Vehicle* vehicle = nullptr;
    int currentCount = 0;

    {
        std::lock_guard<std::mutex> lock(mutex);

        if (vehicles.empty()) {
            return nullptr;
        }

        // Remove the first vehicle (FIFO queue behavior)
        vehicle = vehicles.front();
        vehicles.erase(vehicles.begin());
        currentCount = vehicles.size();
    }

    // Log the action
    std::ostringstream oss;
    oss << "Vehicle " << vehicle->getId() << " removed from lane " << laneId << laneNumber;
    DebugLogger::log(oss.str());

    // Update priority if this is the priority lane
    if (isPriority) {
        if (currentCount > Constants::PRIORITY_THRESHOLD_HIGH) {
            priority = 100; // High priority
        }
        else if (currentCount < Constants::PRIORITY_THRESHOLD_LOW) {
            priority = 0; // Normal priority
            std::ostringstream oss;
            oss << "Lane " << laneId << laneNumber
                << " priority reset to normal (vehicles: " << currentCount << ")";
            DebugLogger::log(oss.str());
        }
    }

    return vehicle;
}

Vehicle* Lane::peek() const {
    std::lock_guard<std::mutex> lock(mutex);

    if (vehicles.empty()) {
        return nullptr;
    }

    return vehicles.front();
}

bool Lane::isEmpty() const {
    std::lock_guard<std::mutex> lock(mutex);
    return vehicles.empty();
}

int Lane::getVehicleCount() const {
    std::lock_guard<std::mutex> lock(mutex);
    return vehicles.size();
}

const std::vector<Vehicle*>& Lane::getVehicles() const {
    return vehicles;
}

int Lane::getPriority() const {
    return priority;
}

void Lane::updatePriority() {
    int count;
    {
        std::lock_guard<std::mutex> lock(mutex);
        count = vehicles.size();
    }

    // Update priority based on vehicle count for AL2 lane
    if (isPriority) {
        if (count > Constants::PRIORITY_THRESHOLD_HIGH) {
            priority = 100; // High priority
            std::ostringstream oss;
            oss << "Lane " << laneId << laneNumber
                << " priority increased (vehicles: " << count << ")";
            DebugLogger::log(oss.str());
        }
        else if (count < Constants::PRIORITY_THRESHOLD_LOW) {
            priority = 0; // Normal priority
            std::ostringstream oss;
            oss << "Lane " << laneId << laneNumber
                << " priority reset to normal (vehicles: " << count << ")";
            DebugLogger::log(oss.str());
        }
    }
}

bool Lane::isPriorityLane() const {
    return isPriority;
}

char Lane::getLaneId() const {
    return laneId;
}

int Lane::getLaneNumber() const {
    return laneNumber;
}

std::string Lane::getName() const {
    std::string name;
    name += laneId;
    name += std::to_string(laneNumber);
    return name;
}


//===== END FILE: {file_path} =====//

//===== FILE: src/core/TrafficLight.cpp =====//

// FILE: src/core/TrafficLight.cpp
#include "core/TrafficLight.h"
#include "utils/DebugLogger.h"
#include <sstream>
#include <cmath>
#include <SDL3/SDL.h>
#include "core/Constants.h"

TrafficLight::TrafficLight()
    : currentState(State::ALL_RED),
      nextState(State::A_GREEN),
      lastStateChangeTime(SDL_GetTicks()),
      isPriorityMode(false),
      shouldResumeNormalMode(false) {

    DebugLogger::log("TrafficLight initialized");
}

TrafficLight::~TrafficLight() {
    DebugLogger::log("TrafficLight destroyed");
}

void TrafficLight::update(const std::vector<Lane*>& lanes) {
    uint32_t currentTime = SDL_GetTicks();
    uint32_t elapsedTime = currentTime - lastStateChangeTime;

    // Find AL2 lane to check priority
    Lane* al2Lane = nullptr;
    for (auto* lane : lanes) {
        if (lane->getLaneId() == 'A' && lane->getLaneNumber() == 2) {
            al2Lane = lane;
            break;
        }
    }

    // Check priority conditions
    if (al2Lane) {
        int vehicleCount = al2Lane->getVehicleCount();

        // Enter priority mode
        if (!isPriorityMode && vehicleCount > Constants::PRIORITY_THRESHOLD_HIGH) {
            isPriorityMode = true;
            std::ostringstream oss;
            oss << "Priority mode activated: A2 has " << vehicleCount << " vehicles";
            DebugLogger::log(oss.str());

            // If not already serving A, switch to it after ALL_RED
            if (currentState != State::A_GREEN) {
                nextState = State::ALL_RED;
            }
        }
        // Exit priority mode
        else if (isPriorityMode && vehicleCount < Constants::PRIORITY_THRESHOLD_LOW) {
            shouldResumeNormalMode = true;
            std::ostringstream oss;
            oss << "Priority mode deactivated: A2 now has " << vehicleCount << " vehicles";
            DebugLogger::log(oss.str());
        }
    }

    // Calculate appropriate duration based on the formula from the assignment
    int stateDuration;
    if (currentState == State::ALL_RED) {
        stateDuration = allRedDuration; // 2 seconds for ALL_RED
    } else {
        // Formula: |V| = (1/n) * Î£|Li| for normal lanes
        int normalLaneCount = 0;
        int totalVehicleCount = 0;

        for (auto* lane : lanes) {
            // Only count normal lanes (lane 2) across all roads
            if (lane->getLaneNumber() == 2) {
                normalLaneCount++;
                totalVehicleCount += lane->getVehicleCount();
            }
        }

        // Calculate average vehicle count as per formula
        float averageVehicleCount = (normalLaneCount > 0) ?
            static_cast<float>(totalVehicleCount) / normalLaneCount : 0.0f;

        // Set the duration based on the formula: Total time = |V| * t
        // where t is 2 seconds per vehicle
        stateDuration = static_cast<int>(averageVehicleCount * 2000); // 2 seconds = 2000ms

        // Apply minimum and maximum limits
        if (stateDuration < 3000) stateDuration = 3000; // Min 3 seconds
        if (stateDuration > 15000) stateDuration = 15000; // Max 15 seconds

        // Debug log
        std::ostringstream oss;
        oss << "Traffic light timing: |V| = " << averageVehicleCount
            << ", Duration = " << stateDuration / 1000.0f << " seconds";
        DebugLogger::log(oss.str());
    }

    // State transition
    if (elapsedTime >= stateDuration) {
        // Change state
        currentState = nextState;

        // Determine next state
        if (isPriorityMode && !shouldResumeNormalMode) {
            // In priority mode, alternate between A_GREEN and ALL_RED
            if (currentState == State::ALL_RED) {
                nextState = State::A_GREEN;
            } else {
                nextState = State::ALL_RED;
            }
        } else {
            // If we should exit priority mode, do it now
            if (shouldResumeNormalMode) {
                isPriorityMode = false;
                shouldResumeNormalMode = false;
                DebugLogger::log("Resuming normal traffic light sequence");
            }

            // In normal mode, rotate through all lanes
            if (currentState == State::ALL_RED) {
                // Determine which green state to go to next
                switch (nextState) {
                    case State::A_GREEN: nextState = State::B_GREEN; break;
                    case State::B_GREEN: nextState = State::C_GREEN; break;
                    case State::C_GREEN: nextState = State::D_GREEN; break;
                    case State::D_GREEN: nextState = State::A_GREEN; break;
                    default: nextState = State::A_GREEN; break;
                }
            } else {
                // Any green state goes to ALL_RED next
                nextState = State::ALL_RED;
            }
        }

        // Log state change
        std::ostringstream oss;
        oss << "Traffic light changed to state: " << static_cast<int>(currentState);
        DebugLogger::log(oss.str());

        lastStateChangeTime = currentTime;
    }
}

void TrafficLight::render(SDL_Renderer* renderer) {
    // Draw traffic light for each road
    drawLightForA(renderer, !isGreen('A'));
    drawLightForB(renderer, !isGreen('B'));
    drawLightForC(renderer, !isGreen('C'));
    drawLightForD(renderer, !isGreen('D'));

    // Priority mode indicator
    if (isPriorityMode) {
        SDL_SetRenderDrawColor(renderer, 255, 165, 0, 255); // Orange
        SDL_FRect priorityIndicator = {10, 10, 30, 30};
        SDL_RenderFillRect(renderer, &priorityIndicator);

        // Black border
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderRect(renderer, &priorityIndicator);
    }
}

void TrafficLight::setNextState(State state) {
    nextState = state;
}

bool TrafficLight::isGreen(char lane) const {
    switch (lane) {
        case 'A': return currentState == State::A_GREEN;
        case 'B': return currentState == State::B_GREEN;
        case 'C': return currentState == State::C_GREEN;
        case 'D': return currentState == State::D_GREEN;
        default: return false;
    }
}

void TrafficLight::drawLightForA(SDL_Renderer* renderer, bool isRed) {
    const int LIGHT_SIZE = 20;
    const int LIGHT_BOX_WIDTH = 25;
    const int LIGHT_BOX_HEIGHT = 60;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 800;

    // Position for road A
    int x = WINDOW_WIDTH/2 + 40;
    int y = WINDOW_HEIGHT/2 - 120;

    // Traffic light box
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255); // Dark gray
    SDL_FRect lightBox = {(float)x, (float)y, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &lightBox);

    // Black border
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &lightBox);

    // Red light
    SDL_SetRenderDrawColor(renderer, isRed ? 255 : 80, 0, 0, 255);
    SDL_FRect redLight = {(float)(x + 2.5), (float)(y + 5), LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &redLight);

    // Green light
    SDL_SetRenderDrawColor(renderer, 0, isRed ? 80 : 255, 0, 255);
    SDL_FRect greenLight = {(float)(x + 2.5), (float)(y + 35), LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &greenLight);

    // Black borders around lights
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}

void TrafficLight::drawLightForB(SDL_Renderer* renderer, bool isRed) {
    const int LIGHT_SIZE = 20;
    const int LIGHT_BOX_WIDTH = 25;
    const int LIGHT_BOX_HEIGHT = 60;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 800;

    // Position for road B
    int x = WINDOW_WIDTH/2 - 65;
    int y = WINDOW_HEIGHT/2 + 60;

    // Traffic light box
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255); // Dark gray
    SDL_FRect lightBox = {(float)x, (float)y, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &lightBox);

    // Black border
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &lightBox);

    // Red light
    SDL_SetRenderDrawColor(renderer, isRed ? 255 : 80, 0, 0, 255);
    SDL_FRect redLight = {(float)(x + 2.5), (float)(y + 5), LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &redLight);

    // Green light
    SDL_SetRenderDrawColor(renderer, 0, isRed ? 80 : 255, 0, 255);
    SDL_FRect greenLight = {(float)(x + 2.5), (float)(y + 35), LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &greenLight);

    // Black borders around lights
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}

void TrafficLight::drawLightForC(SDL_Renderer* renderer, bool isRed) {
    const int LIGHT_SIZE = 20;
    const int LIGHT_BOX_WIDTH = 60;
    const int LIGHT_BOX_HEIGHT = 25;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 800;

    // Position for road C
    int x = WINDOW_WIDTH/2 + 60;
    int y = WINDOW_HEIGHT/2 - 65;

    // Traffic light box
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255); // Dark gray
    SDL_FRect lightBox = {(float)x, (float)y, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &lightBox);

    // Black border
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &lightBox);

    // Red light
    SDL_SetRenderDrawColor(renderer, isRed ? 255 : 80, 0, 0, 255);
    SDL_FRect redLight = {(float)(x + 5), (float)(y + 2.5), LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &redLight);

    // Green light
    SDL_SetRenderDrawColor(renderer, 0, isRed ? 80 : 255, 0, 255);
    SDL_FRect greenLight = {(float)(x + 35), (float)(y + 2.5), LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &greenLight);

    // Black borders around lights
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}

void TrafficLight::drawLightForD(SDL_Renderer* renderer, bool isRed) {
    const int LIGHT_SIZE = 20;
    const int LIGHT_BOX_WIDTH = 60;
    const int LIGHT_BOX_HEIGHT = 25;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 800;

    // Position for road D
    int x = WINDOW_WIDTH/2 - 120;
    int y = WINDOW_HEIGHT/2 + 40;

    // Traffic light box
    SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255); // Dark gray
    SDL_FRect lightBox = {(float)x, (float)y, LIGHT_BOX_WIDTH, LIGHT_BOX_HEIGHT};
    SDL_RenderFillRect(renderer, &lightBox);

    // Black border
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &lightBox);

    // Red light
    SDL_SetRenderDrawColor(renderer, isRed ? 255 : 80, 0, 0, 255);
    SDL_FRect redLight = {(float)(x + 5), (float)(y + 2.5), LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &redLight);

    // Green light
    SDL_SetRenderDrawColor(renderer, 0, isRed ? 80 : 255, 0, 255);
    SDL_FRect greenLight = {(float)(x + 35), (float)(y + 2.5), LIGHT_SIZE, LIGHT_SIZE};
    SDL_RenderFillRect(renderer, &greenLight);

    // Black borders around lights
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &redLight);
    SDL_RenderRect(renderer, &greenLight);
}


//===== END FILE: {file_path} =====//

//===== FILE: src/managers/FileHandler.cpp =====//

// FILE: src/managers/FileHandler.cpp
#include "managers/FileHandler.h"
#include "utils/DebugLogger.h"
#include <fstream>
#include <sstream>
#include <filesystem>

namespace fs = std::filesystem;

FileHandler::FileHandler(const std::string& dataPath)
    : dataPath(dataPath) {

    DebugLogger::log("FileHandler created with path: " + dataPath);
}

FileHandler::~FileHandler() {
    DebugLogger::log("FileHandler destroyed");
}

std::vector<Vehicle*> FileHandler::readVehiclesFromFiles() {
    std::lock_guard<std::mutex> lock(mutex);
    std::vector<Vehicle*> vehicles;

    // Read from each lane file (A, B, C, D)
    for (char laneId : {'A', 'B', 'C', 'D'}) {
        auto laneVehicles = readVehiclesFromFile(laneId);
        vehicles.insert(vehicles.end(), laneVehicles.begin(), laneVehicles.end());
    }

    // If we found any vehicles, log the total
    if (!vehicles.empty()) {
        std::ostringstream oss;
        oss << "Read " << vehicles.size() << " vehicles from lane files";
        DebugLogger::log(oss.str());
    }

    return vehicles;
}

std::vector<Vehicle*> FileHandler::readVehiclesFromFile(char laneId) {
    std::vector<Vehicle*> vehicles;
    std::string filePath = getLaneFilePath(laneId);
    std::ifstream file(filePath);

    if (!file.is_open()) {
        // This is normal if no vehicles have been generated yet
        return vehicles;
    }

    std::vector<std::string> lines;
    std::string line;

    // Read all lines from file
    while (std::getline(file, line)) {
        if (!line.empty()) {
            lines.push_back(line);
        }
    }
    file.close();

    // Clear the file after reading to prevent duplicates
    std::ofstream clearFile(filePath, std::ios::trunc);
    clearFile.close();

    // Process each line to create vehicles
    for (const auto& line : lines) {
        Vehicle* vehicle = parseVehicleLine(line);
        if (vehicle) {
            vehicles.push_back(vehicle);
        }
    }

    // Log number of vehicles read
    if (!vehicles.empty()) {
        std::ostringstream oss;
        oss << "Read " << vehicles.size() << " vehicles from lane " << laneId;
        DebugLogger::log(oss.str());
    }

    return vehicles;
}

Vehicle* FileHandler::parseVehicleLine(const std::string& line) {
    // Expected format: "vehicleId:laneId" or "vehicleId_L{laneNumber}:laneId"
    size_t pos = line.find(":");
    if (pos == std::string::npos) {
        DebugLogger::log("Error parsing line: " + line, DebugLogger::LogLevel::ERROR);
        return nullptr;
    }

    std::string vehicleId = line.substr(0, pos);
    char laneId = line[pos + 1];

    // Extract lane number from ID (format: V1_L2 where 2 is the lane number)
    int laneNumber = 2; // Default is lane 2
    size_t lanePos = vehicleId.find("_L");
    if (lanePos != std::string::npos && lanePos + 2 < vehicleId.length()) {
        char laneNumChar = vehicleId[lanePos + 2];
        if (laneNumChar >= '1' && laneNumChar <= '3') {
            laneNumber = laneNumChar - '0';
        }
    }

    // Determine if it's an emergency vehicle (optional, based on ID pattern)
    bool isEmergency = vehicleId.find("E") != std::string::npos;

    // Create and return the vehicle
    return new Vehicle(vehicleId, laneId, laneNumber, isEmergency);
}

void FileHandler::writeLaneStatus(char laneId, int laneNumber, int vehicleCount, bool isPriority) {
    std::lock_guard<std::mutex> lock(mutex);
    std::string statusPath = getLaneStatusFilePath();

    // Make sure the directory exists
    fs::path dir = fs::path(statusPath).parent_path();
    if (!fs::exists(dir)) {
        try {
            fs::create_directories(dir);
        } catch (const std::exception& e) {
            DebugLogger::log("Error creating directory: " + std::string(e.what()),
                           DebugLogger::LogLevel::ERROR);
            return;
        }
    }

    std::ofstream file(statusPath, std::ios::app);
    if (file.is_open()) {
        file << laneId << laneNumber << ": " << vehicleCount << " vehicles"
             << (isPriority ? " (PRIORITY)" : "") << std::endl;
        file.close();
    } else {
        DebugLogger::log("Warning: Could not open lane status file for writing",
                       DebugLogger::LogLevel::WARNING);
    }
}

bool FileHandler::checkFilesExist() {
    // Make sure data directory exists
    if (!fs::exists(dataPath)) {
        return false;
    }

    // Check for lane files
    for (char laneId : {'A', 'B', 'C', 'D'}) {
        std::string filePath = getLaneFilePath(laneId);
        if (!fs::exists(filePath)) {
            return false;
        }
    }
    return true;
}

bool FileHandler::initializeFiles() {
    std::lock_guard<std::mutex> lock(mutex);

    try {
        // Create data directory if it doesn't exist
        if (!fs::exists(dataPath)) {
            if (!fs::create_directories(dataPath)) {
                DebugLogger::log("Error: Failed to create directory " + dataPath,
                               DebugLogger::LogLevel::ERROR);
                return false;
            }
            DebugLogger::log("Created directory: " + dataPath);
        }

        // Create lane files if they don't exist
        for (char laneId : {'A', 'B', 'C', 'D'}) {
            std::string filePath = getLaneFilePath(laneId);
            if (!fs::exists(filePath)) {
                std::ofstream file(filePath);
                if (!file.is_open()) {
                    DebugLogger::log("Error: Failed to create file " + filePath,
                                   DebugLogger::LogLevel::ERROR);
                    return false;
                }
                file.close();
                DebugLogger::log("Created file: " + filePath);
            }
        }

        // Create or clear lane status file
        std::string statusPath = getLaneStatusFilePath();
        std::ofstream statusFile(statusPath, std::ios::trunc);
        if (!statusFile.is_open()) {
            DebugLogger::log("Error: Failed to create lane status file",
                           DebugLogger::LogLevel::ERROR);
            return false;
        }
        statusFile << "=== Lane Status Log ===\n";
        statusFile.close();

        return true;
    } catch (const std::exception& e) {
        DebugLogger::log("Error initializing files: " + std::string(e.what()),
                       DebugLogger::LogLevel::ERROR);
        return false;
    }
}

std::string FileHandler::getLaneFilePath(char laneId) const {
    return dataPath + "/lane" + laneId + ".txt";
}

std::string FileHandler::getLaneStatusFilePath() const {
    return dataPath + "/lane_status.txt";
}


//===== END FILE: {file_path} =====//

//===== FILE: src/managers/TrafficManager.cpp =====//

// FILE: src/managers/TrafficManager.cpp
#include "managers/TrafficManager.h"
#include "utils/DebugLogger.h"
#include <sstream>
#include <algorithm>
#include "core/Constants.h"

TrafficManager::TrafficManager()
    : trafficLight(nullptr),
      fileHandler(nullptr),
      lastFileCheckTime(0),
      lastPriorityUpdateTime(0),
      running(false) {

    DebugLogger::log("TrafficManager created");
}

TrafficManager::~TrafficManager() {
    // Clean up resources
    for (auto* lane : lanes) {
        delete lane;
    }
    lanes.clear();

    if (trafficLight) {
        delete trafficLight;
        trafficLight = nullptr;
    }

    if (fileHandler) {
        delete fileHandler;
        fileHandler = nullptr;
    }

    DebugLogger::log("TrafficManager destroyed");
}

bool TrafficManager::initialize() {
    // Create file handler
    fileHandler = new FileHandler(Constants::DATA_PATH);
    if (!fileHandler->initializeFiles()) {
        DebugLogger::log("Failed to initialize lane files");
        return false;
    }

    // Create lanes for each road and lane number
    for (char road : {'A', 'B', 'C', 'D'}) {
        for (int laneNum = 1; laneNum <= 3; laneNum++) {
            Lane* lane = new Lane(road, laneNum);
            lanes.push_back(lane);

            // Add to priority queue with initial priority
            lanePriorityQueue.enqueue(lane, lane->getPriority());
        }
    }

    // Create traffic light
    trafficLight = new TrafficLight();

    std::ostringstream oss;
    oss << "TrafficManager initialized with " << lanes.size() << " lanes";
    DebugLogger::log(oss.str());

    return true;
}

void TrafficManager::start() {
    running = true;
    DebugLogger::log("TrafficManager started");
}

void TrafficManager::stop() {
    running = false;
    DebugLogger::log("TrafficManager stopped");
}

void TrafficManager::update(uint32_t delta) {
    if (!running) return;

    uint32_t currentTime = SDL_GetTicks();

    // Check for new vehicles periodically
    if (currentTime - lastFileCheckTime >= 1000) { // Every second
        readVehicles();
        lastFileCheckTime = currentTime;
    }

    // Update lane priorities periodically
    if (currentTime - lastPriorityUpdateTime >= 500) { // Every half second
        updatePriorities();
        lastPriorityUpdateTime = currentTime;
    }

    // Process vehicles based on traffic light state
    processVehicles(delta);

    // Check for vehicles leaving the simulation
    checkVehicleBoundaries();

    // Update traffic light
    if (trafficLight) {
        trafficLight->update(lanes);
    }
}

void TrafficManager::readVehicles() {
    if (!fileHandler) return;

    // Read new vehicles from files
    std::vector<Vehicle*> newVehicles = fileHandler->readVehiclesFromFiles();

    // Add vehicles to appropriate lanes
    for (auto* vehicle : newVehicles) {
        addVehicle(vehicle);
    }
}

void TrafficManager::addVehicle(Vehicle* vehicle) {
    if (!vehicle) return;

    Lane* targetLane = findLane(vehicle->getLane(), vehicle->getLaneNumber());
    if (targetLane) {
        targetLane->enqueue(vehicle);

        // Log the action
        std::ostringstream oss;
        oss << "Added vehicle " << vehicle->getId() << " to lane "
            << vehicle->getLane() << vehicle->getLaneNumber();
        DebugLogger::log(oss.str());

        // Write lane status to file for monitoring
        if (fileHandler) {
            fileHandler->writeLaneStatus(
                targetLane->getLaneId(),
                targetLane->getLaneNumber(),
                targetLane->getVehicleCount(),
                targetLane->isPriorityLane() && targetLane->getPriority() > 0
            );
        }
    } else {
        // Clean up if lane not found
        delete vehicle;
        DebugLogger::log("Error: No matching lane found for vehicle");
    }
}

void TrafficManager::updatePriorities() {
    for (auto* lane : lanes) {
        // Store old priority
        int oldPriority = lane->getPriority();

        // Update priority
        lane->updatePriority();

        // If priority changed, update in the priority queue
        if (oldPriority != lane->getPriority()) {
            // Use a lambda to compare lane pointers
            auto compareLanes = [](const Lane* a, const Lane* b) -> bool {
                return a == b;
            };

            lanePriorityQueue.updatePriority(lane, lane->getPriority(), compareLanes);

            // Log the priority change
            std::ostringstream oss;
            oss << "Updated priority for lane " << lane->getName()
                << " from " << oldPriority << " to " << lane->getPriority();
            DebugLogger::log(oss.str());
        }
    }
}

void TrafficManager::processVehicles(uint32_t delta) {
    // Determine active lanes based on traffic light state
    char activeLaneId = ' ';
    if (trafficLight) {
        if (trafficLight->getCurrentState() == TrafficLight::State::A_GREEN) activeLaneId = 'A';
        else if (trafficLight->getCurrentState() == TrafficLight::State::B_GREEN) activeLaneId = 'B';
        else if (trafficLight->getCurrentState() == TrafficLight::State::C_GREEN) activeLaneId = 'C';
        else if (trafficLight->getCurrentState() == TrafficLight::State::D_GREEN) activeLaneId = 'D';
    }

    // Process vehicles in all lanes
    for (auto* lane : lanes) {
        bool isGreenLight = (lane->getLaneId() == activeLaneId) ||
                           (lane->getLaneNumber() == 3); // L3 is free lane

        // Get all vehicles in this lane
        const auto& vehicles = lane->getVehicles();
        float targetPos = 0.0f;
        int queuePos = 0;

        // Update each vehicle
        for (auto* vehicle : vehicles) {
            if (vehicle) {
                // Update vehicle position based on traffic light
                vehicle->update(delta, isGreenLight, targetPos);

                // Update queue position for visualization
                queuePos++;
                targetPos += 20.0f; // Space between vehicles
            }
        }
    }
}

void TrafficManager::checkVehicleBoundaries() {
    for (auto* lane : lanes) {
        // Check each vehicle
        while (!lane->isEmpty()) {
            Vehicle* vehicle = lane->peek();

            if (vehicle && vehicle->hasExited()) {
                // Remove the vehicle from the queue
                lane->dequeue();

                // Log vehicle exit
                std::ostringstream oss;
                oss << "Vehicle " << vehicle->getId() << " exited the simulation";
                DebugLogger::log(oss.str());

                // Delete the vehicle
                delete vehicle;
            } else {
                // If the first vehicle hasn't exited, the rest haven't either
                break;
            }
        }
    }
}

Lane* TrafficManager::findLane(char laneId, int laneNumber) const {
    for (auto* lane : lanes) {
        if (lane->getLaneId() == laneId && lane->getLaneNumber() == laneNumber) {
            return lane;
        }
    }
    return nullptr;
}

const std::vector<Lane*>& TrafficManager::getLanes() const {
    return lanes;
}

TrafficLight* TrafficManager::getTrafficLight() const {
    return trafficLight;
}

bool TrafficManager::isLanePrioritized(char laneId, int laneNumber) const {
    Lane* lane = findLane(laneId, laneNumber);
    return lane && lane->isPriorityLane() && lane->getPriority() > 0;
}

Lane* TrafficManager::getPriorityLane() const {
    return findLane('A', 2); // AL2 is the priority lane
}

std::string TrafficManager::getStatistics() const {
    std::ostringstream stats;
    stats << "Lane Statistics:\n";
    int totalVehicles = 0;

    for (auto* lane : lanes) {
        int count = lane->getVehicleCount();
        totalVehicles += count;

        stats << lane->getName() << ": " << count << " vehicles";
        if (lane->isPriorityLane() && lane->getPriority() > 0) {
            stats << " (PRIORITY)";
        }
        stats << "\n";
    }

    stats << "Total Vehicles: " << totalVehicles << "\n";

    return stats.str();
}


//===== END FILE: {file_path} =====//

//===== FILE: src/visualization/Renderer.cpp =====//

// FILE: src/visualization/Renderer.cpp
#include "visualization/Renderer.h"
#include "core/Lane.h"
#include "core/Vehicle.h"
#include "core/TrafficLight.h"
#include "managers/TrafficManager.h"
#include "utils/DebugLogger.h"
#include "core/Constants.h"

#include <sstream>
#include <algorithm>
#include <cmath>

Renderer::Renderer()
    : window(nullptr),
      renderer(nullptr),
      carTexture(nullptr),
      surface(nullptr),
      active(false),
      showDebugOverlay(true),
      frameRateLimit(60),
      lastFrameTime(0),
      windowWidth(800),
      windowHeight(800),
      trafficManager(nullptr) {}

Renderer::~Renderer() {
    cleanup();
}

bool Renderer::initialize(int width, int height, const std::string& title) {
    windowWidth = width;
    windowHeight = height;

    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        DebugLogger::log("Failed to initialize SDL: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Create window
    window = SDL_CreateWindow(title.c_str(), width, height, SDL_WINDOW_OPENGL);
    if (!window) {
        DebugLogger::log("Failed to create window: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Create renderer
    renderer = SDL_CreateRenderer(window, NULL);
    if (!renderer) {
        DebugLogger::log("Failed to create renderer: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Load textures
    if (!loadTextures()) {
        DebugLogger::log("Failed to load textures", DebugLogger::LogLevel::ERROR);
        return false;
    }

    active = true;
    DebugLogger::log("Renderer initialized successfully");

    return true;
}

bool Renderer::loadTextures() {
    // Create a simple surface directly with a solid color to avoid SDL_MapRGB issues
    surface = SDL_CreateSurface(20, 10, SDL_PIXELFORMAT_RGBA8888);
    if (!surface) {
        DebugLogger::log("Failed to create surface: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    // Fill with blue color using a simpler approach
    // Create a color value manually
    Uint32 blueColor = 0x0000FFFF; // RGBA format: blue with full alpha

    // Fill the entire surface with this color
    SDL_FillSurfaceRect(surface, NULL, blueColor);

    carTexture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_DestroySurface(surface);
    surface = nullptr;

    if (!carTexture) {
        DebugLogger::log("Failed to create car texture: " + std::string(SDL_GetError()), DebugLogger::LogLevel::ERROR);
        return false;
    }

    return true;
}

void Renderer::startRenderLoop() {
    if (!active || !trafficManager) {
        DebugLogger::log("Cannot start render loop - renderer not active or trafficManager not set", DebugLogger::LogLevel::ERROR);
        return;
    }

    DebugLogger::log("Starting render loop");

    uint32_t lastUpdate = SDL_GetTicks();
    const int updateInterval = 16; // ~60 FPS

    while (active) {
        uint32_t currentTime = SDL_GetTicks();
        uint32_t deltaTime = currentTime - lastUpdate;

        if (deltaTime >= updateInterval) {
            // Process events
            active = processEvents();

            // Update traffic manager
            trafficManager->update(deltaTime);

            // Render frame
            renderFrame();

            lastUpdate = currentTime;
        }

        // Delay to maintain frame rate
        uint32_t frameDuration = SDL_GetTicks() - currentTime;
        if (frameRateLimit > 0) {
            uint32_t targetFrameTime = 1000 / frameRateLimit;
            if (frameDuration < targetFrameTime) {
                SDL_Delay(targetFrameTime - frameDuration);
            }
        }
    }
}

bool Renderer::processEvents() {
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
            case SDL_EVENT_QUIT:
                return false;

            case SDL_EVENT_KEY_DOWN: {
                // Check based on the key scancode instead of using SDLK constants
                SDL_Scancode scancode = event.key.scancode;

                // D key scancode is usually 7 (for SDL_SCANCODE_D)
                if (scancode == SDL_SCANCODE_D) {
                    toggleDebugOverlay();
                }
                // Escape key scancode is usually 41 (for SDL_SCANCODE_ESCAPE)
                else if (scancode == SDL_SCANCODE_ESCAPE) {
                    return false;
                }
                break;
            }
        }
    }

    return true;
}

void Renderer::renderFrame() {
    if (!active || !renderer || !trafficManager) {
        return;
    }

    // Clear screen
    SDL_SetRenderDrawColor(renderer, 40, 40, 40, 255); // Darker background
    SDL_RenderClear(renderer);

    // Draw roads and lanes
    drawRoadsAndLanes();

    // Draw traffic lights
    drawTrafficLights();

    // Draw vehicles
    drawVehicles();

    // Draw lane labels and direction indicators
    drawLaneLabels();

    // Draw debug overlay if enabled
    if (showDebugOverlay) {
        drawDebugOverlay();
    }

    // Present render
    SDL_RenderPresent(renderer);

    // Update frame time
    lastFrameTime = SDL_GetTicks();
}

void Renderer::drawRoadsAndLanes() {
    const int ROAD_WIDTH = Constants::ROAD_WIDTH;
    const int LANE_WIDTH = Constants::LANE_WIDTH;

    // Draw intersection (dark gray)
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 255);
    SDL_FRect intersectionRect = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2),
        static_cast<float>(ROAD_WIDTH),
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &intersectionRect);

    // Draw horizontal road (dark gray)
    SDL_FRect horizontalRoad = {
        0, static_cast<float>(windowHeight/2 - ROAD_WIDTH/2),
        static_cast<float>(windowWidth), static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &horizontalRoad);

    // Draw vertical road (dark gray)
    SDL_FRect verticalRoad = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2), 0,
        static_cast<float>(ROAD_WIDTH), static_cast<float>(windowHeight)
    };
    SDL_RenderFillRect(renderer, &verticalRoad);

    // Highlight the priority lane (AL2) - North top road second lane
    if (trafficManager) {
        Lane* priorityLane = trafficManager->getPriorityLane();
        if (priorityLane && priorityLane->getVehicleCount() > Constants::PRIORITY_THRESHOLD_HIGH) {
            // Highlight AL2 lane in orange
            SDL_SetRenderDrawColor(renderer, 255, 165, 0, 100); // Semi-transparent orange

            // AL2 is second lane from left on top road (A)
            SDL_FRect priorityLaneRect = {
                static_cast<float>(windowWidth/2), // Start at center
                0, // Start at top
                static_cast<float>(LANE_WIDTH), // One lane width
                static_cast<float>(windowHeight/2 - ROAD_WIDTH/2) // Extend to intersection
            };
            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
            SDL_RenderFillRect(renderer, &priorityLaneRect);
            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);
        }
    }

    // Highlight free lanes (L3) in a light green
    SDL_SetRenderDrawColor(renderer, 100, 200, 100, 80); // Semi-transparent green
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

    // Free lanes (L3) on each road
    // Road A (North - Top) - Third lane from left
    SDL_FRect freeALane = {
        static_cast<float>(windowWidth/2 + LANE_WIDTH), // Start after center + 1 lane
        0, // Start at top
        static_cast<float>(LANE_WIDTH), // One lane width
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2) // Extend to intersection
    };
    SDL_RenderFillRect(renderer, &freeALane);

    // Road B (East - Right) - Third lane from top
    SDL_FRect freeBLane = {
        static_cast<float>(windowWidth/2 + ROAD_WIDTH/2), // Start at intersection edge
        static_cast<float>(windowHeight/2 + LANE_WIDTH), // Start after center + 1 lane
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2), // Extend to right edge
        static_cast<float>(LANE_WIDTH) // One lane width
    };
    SDL_RenderFillRect(renderer, &freeBLane);

    // Road C (South - Bottom) - Third lane from right
    SDL_FRect freeCLane = {
        static_cast<float>(windowWidth/2 - 2*LANE_WIDTH), // Start at center - 2 lanes
        static_cast<float>(windowHeight/2 + ROAD_WIDTH/2), // Start at intersection edge
        static_cast<float>(LANE_WIDTH), // One lane width
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2) // Extend to bottom
    };
    SDL_RenderFillRect(renderer, &freeCLane);

    // Road D (West - Left) - Third lane from bottom
    SDL_FRect freeDLane = {
        0, // Start at left edge
        static_cast<float>(windowHeight/2 - 2*LANE_WIDTH), // Start at center - 2 lanes
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2), // Extend to intersection
        static_cast<float>(LANE_WIDTH) // One lane width
    };
    SDL_RenderFillRect(renderer, &freeDLane);

    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    // Draw lane dividers (white dashed lines)
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    // Draw all lane dividers
    // Horizontal lane dividers
    for (int i = 1; i < 3; i++) {
        int y = windowHeight/2 - ROAD_WIDTH/2 + i * LANE_WIDTH;
        for (int x = 0; x < windowWidth; x += 30) {
            // Skip intersection area
            if (x < windowWidth/2 - ROAD_WIDTH/2 || x > windowWidth/2 + ROAD_WIDTH/2) {
                SDL_RenderLine(renderer, x, y, x + 15, y);
            }
        }
    }

    // Vertical lane dividers
    for (int i = 1; i < 3; i++) {
        int x = windowWidth/2 - ROAD_WIDTH/2 + i * LANE_WIDTH;
        for (int y = 0; y < windowHeight; y += 30) {
            // Skip intersection area
            if (y < windowHeight/2 - ROAD_WIDTH/2 || y > windowHeight/2 + ROAD_WIDTH/2) {
                SDL_RenderLine(renderer, x, y, x, y + 15);
            }
        }
    }

    // Draw center yellow lines
    SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255); // Yellow

    // Horizontal center line
    int y = windowHeight/2;
    for (int x = 0; x < windowWidth; x += 30) {
        // Skip intersection area
        if (x < windowWidth/2 - ROAD_WIDTH/2 || x > windowWidth/2 + ROAD_WIDTH/2) {
            SDL_RenderLine(renderer, x, y, x + 20, y);
        }
    }

    // Vertical center line
    int x = windowWidth/2;
    for (int y = 0; y < windowHeight; y += 30) {
        // Skip intersection area
        if (y < windowHeight/2 - ROAD_WIDTH/2 || y > windowHeight/2 + ROAD_WIDTH/2) {
            SDL_RenderLine(renderer, x, y, x, y + 20);
        }
    }

    // Draw stop lines at intersection (solid white lines)
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);

    // Top stop line (Road A)
    SDL_FRect topStopLine = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2 - 2),
        static_cast<float>(ROAD_WIDTH),
        4.0f
    };
    SDL_RenderFillRect(renderer, &topStopLine);

    // Bottom stop line (Road C)
    SDL_FRect bottomStopLine = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2),
        static_cast<float>(windowHeight/2 + ROAD_WIDTH/2 - 2),
        static_cast<float>(ROAD_WIDTH),
        4.0f
    };
    SDL_RenderFillRect(renderer, &bottomStopLine);

    // Left stop line (Road D)
    SDL_FRect leftStopLine = {
        static_cast<float>(windowWidth/2 - ROAD_WIDTH/2 - 2),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2),
        4.0f,
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &leftStopLine);

    // Right stop line (Road B)
    SDL_FRect rightStopLine = {
        static_cast<float>(windowWidth/2 + ROAD_WIDTH/2 - 2),
        static_cast<float>(windowHeight/2 - ROAD_WIDTH/2),
        4.0f,
        static_cast<float>(ROAD_WIDTH)
    };
    SDL_RenderFillRect(renderer, &rightStopLine);

    // Draw grid pattern on intersection for better visibility
    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);

    // Horizontal grid lines
    for (int y = windowHeight/2 - ROAD_WIDTH/2 + LANE_WIDTH;
         y < windowHeight/2 + ROAD_WIDTH/2;
         y += LANE_WIDTH) {
        SDL_RenderLine(renderer,
                     windowWidth/2 - ROAD_WIDTH/2, y,
                     windowWidth/2 + ROAD_WIDTH/2, y);
    }

    // Vertical grid lines
    for (int x = windowWidth/2 - ROAD_WIDTH/2 + LANE_WIDTH;
         x < windowWidth/2 + ROAD_WIDTH/2;
         x += LANE_WIDTH) {
        SDL_RenderLine(renderer,
                     x, windowHeight/2 - ROAD_WIDTH/2,
                     x, windowHeight/2 + ROAD_WIDTH/2);
    }
}

void Renderer::drawLaneLabels() {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    const int ROAD_WIDTH = Constants::ROAD_WIDTH;
    const int LANE_WIDTH = Constants::LANE_WIDTH;

    // Road A (North - Top) labels
    drawText("A (North)", windowWidth/2, 10, {255, 255, 255, 255});
    drawText("A1", windowWidth/2 - LANE_WIDTH, windowHeight/4, {0, 140, 255, 255});
    drawText("A2 (Priority)", windowWidth/2, windowHeight/4, {255, 140, 0, 255});
    drawText("A3 (Free)", windowWidth/2 + LANE_WIDTH, windowHeight/4, {0, 220, 60, 255});

    // Road B (East - Right) labels
    drawText("B (East)", windowWidth - 60, windowHeight/2, {255, 255, 255, 255});
    drawText("B1", 3*windowWidth/4, windowHeight/2 - LANE_WIDTH, {0, 140, 255, 255});
    drawText("B2", 3*windowWidth/4, windowHeight/2, {255, 255, 255, 255});
    drawText("B3 (Free)", 3*windowWidth/4, windowHeight/2 + LANE_WIDTH, {0, 220, 60, 255});

    // Road C (South - Bottom) labels
    drawText("C (South)", windowWidth/2, windowHeight - 30, {255, 255, 255, 255});
    drawText("C1", windowWidth/2 + LANE_WIDTH, 3*windowHeight/4, {0, 140, 255, 255});
    drawText("C2", windowWidth/2, 3*windowHeight/4, {255, 255, 255, 255});
    drawText("C3 (Free)", windowWidth/2 - LANE_WIDTH, 3*windowHeight/4, {0, 220, 60, 255});

    // Road D (West - Left) labels
    drawText("D (West)", 50, windowHeight/2, {255, 255, 255, 255});
    drawText("D1", windowWidth/4, windowHeight/2 + LANE_WIDTH, {0, 140, 255, 255});
    drawText("D2", windowWidth/4, windowHeight/2, {255, 255, 255, 255});
    drawText("D3 (Free)", windowWidth/4, windowHeight/2 - LANE_WIDTH, {0, 220, 60, 255});

    // Draw direction arrows
    // North (Road A) direction arrows
    drawArrow(windowWidth/2 - LANE_WIDTH*1.5, windowHeight/4 + 15, // Lane A1 arrow (straight)
             windowWidth/2 - LANE_WIDTH*1.5, windowHeight/4 + 30,
             windowWidth/2 - LANE_WIDTH*1.5 - 5, windowHeight/4 + 25,
             {0, 140, 255, 255});

    // Draw split arrows for Lane A2 (priority) - straight or right
    drawArrow(windowWidth/2, windowHeight/4 + 15, // Lane A2 arrow straight
             windowWidth/2, windowHeight/4 + 30,
             windowWidth/2 - 5, windowHeight/4 + 25,
             {255, 140, 0, 255});
    drawArrow(windowWidth/2 + 10, windowHeight/4 + 15, // Lane A2 arrow right
             windowWidth/2 + 20, windowHeight/4 + 20,
             windowWidth/2 + 15, windowHeight/4 + 10,
             {255, 140, 0, 255});

    // Draw left arrow for Lane A3 (free)
    drawArrow(windowWidth/2 + LANE_WIDTH*1.5 - 10, windowHeight/4 + 15, // Lane A3 arrow left
             windowWidth/2 + LANE_WIDTH*1.5 - 20, windowHeight/4 + 20,
             windowWidth/2 + LANE_WIDTH*1.5 - 15, windowHeight/4 + 10,
             {0, 220, 60, 255});

    // East (Road B) direction arrows - similar logic
    drawArrow(3*windowWidth/4 - 15, windowHeight/2 - LANE_WIDTH*1.5, // Lane B1 arrow (straight)
             3*windowWidth/4 - 30, windowHeight/2 - LANE_WIDTH*1.5,
             3*windowWidth/4 - 25, windowHeight/2 - LANE_WIDTH*1.5 - 5,
             {0, 140, 255, 255});

    // Draw split arrows for Lane B2 - straight or right
    drawArrow(3*windowWidth/4 - 15, windowHeight/2, // Lane B2 arrow straight
             3*windowWidth/4 - 30, windowHeight/2,
             3*windowWidth/4 - 25, windowHeight/2 - 5,
             {255, 255, 255, 255});
    drawArrow(3*windowWidth/4 - 15, windowHeight/2 + 10, // Lane B2 arrow right
             3*windowWidth/4 - 20, windowHeight/2 + 20,
             3*windowWidth/4 - 10, windowHeight/2 + 15,
             {255, 255, 255, 255});

    // Draw left arrow for Lane B3 (free)
    drawArrow(3*windowWidth/4 - 15, windowHeight/2 + LANE_WIDTH*1.5 - 10, // Lane B3 arrow left
             3*windowWidth/4 - 20, windowHeight/2 + LANE_WIDTH*1.5 - 20,
             3*windowWidth/4 - 10, windowHeight/2 + LANE_WIDTH*1.5 - 15,
             {0, 220, 60, 255});

    // South (Road C) direction arrows
    drawArrow(windowWidth/2 + LANE_WIDTH*1.5, 3*windowHeight/4 - 15, // Lane C1 arrow (straight)
             windowWidth/2 + LANE_WIDTH*1.5, 3*windowHeight/4 - 30,
             windowWidth/2 + LANE_WIDTH*1.5 + 5, 3*windowHeight/4 - 25,
             {0, 140, 255, 255});

    // Draw split arrows for Lane C2 - straight or right
    drawArrow(windowWidth/2, 3*windowHeight/4 - 15, // Lane C2 arrow straight
             windowWidth/2, 3*windowHeight/4 - 30,
             windowWidth/2 + 5, 3*windowHeight/4 - 25,
             {255, 255, 255, 255});
    drawArrow(windowWidth/2 - 10, 3*windowHeight/4 - 15, // Lane C2 arrow right
             windowWidth/2 - 20, 3*windowHeight/4 - 20,
             windowWidth/2 - 15, 3*windowHeight/4 - 10,
             {255, 255, 255, 255});

    // Draw left arrow for Lane C3 (free)
    drawArrow(windowWidth/2 - LANE_WIDTH*1.5 + 10, 3*windowHeight/4 - 15, // Lane C3 arrow left
             windowWidth/2 - LANE_WIDTH*1.5 + 20, 3*windowHeight/4 - 20,
             windowWidth/2 - LANE_WIDTH*1.5 + 15, 3*windowHeight/4 - 10,
             {0, 220, 60, 255});

    // West (Road D) direction arrows
    drawArrow(windowWidth/4 + 15, windowHeight/2 + LANE_WIDTH*1.5, // Lane D1 arrow (straight)
             windowWidth/4 + 30, windowHeight/2 + LANE_WIDTH*1.5,
             windowWidth/4 + 25, windowHeight/2 + LANE_WIDTH*1.5 + 5,
             {0, 140, 255, 255});

    // Draw split arrows for Lane D2 - straight or right
    drawArrow(windowWidth/4 + 15, windowHeight/2, // Lane D2 arrow straight
             windowWidth/4 + 30, windowHeight/2,
             windowWidth/4 + 25, windowHeight/2 + 5,
             {255, 255, 255, 255});
    drawArrow(windowWidth/4 + 15, windowHeight/2 - 10, // Lane D2 arrow right
             windowWidth/4 + 20, windowHeight/2 - 20,
             windowWidth/4 + 10, windowHeight/2 - 15,
             {255, 255, 255, 255});

    // Draw left arrow for Lane D3 (free)
    drawArrow(windowWidth/4 + 15, windowHeight/2 - LANE_WIDTH*1.5 + 10, // Lane D3 arrow left
             windowWidth/4 + 20, windowHeight/2 - LANE_WIDTH*1.5 + 20,
             windowWidth/4 + 10, windowHeight/2 - LANE_WIDTH*1.5 + 15,
             {0, 220, 60, 255});
}

void Renderer::drawTrafficLights() {
    if (!trafficManager) {
        return;
    }

    TrafficLight* trafficLight = trafficManager->getTrafficLight();
    if (!trafficLight) {
        return;
    }

    // Draw traffic lights
    trafficLight->render(renderer);
}

void Renderer::drawVehicles() {
    if (!trafficManager) {
        return;
    }

    // Get all lanes from traffic manager
    const std::vector<Lane*>& lanes = trafficManager->getLanes();

    // Draw vehicles in each lane
    for (Lane* lane : lanes) {
        if (!lane) {
            continue;
        }

        const std::vector<Vehicle*>& vehicles = lane->getVehicles();
        int queuePos = 0;

        for (Vehicle* vehicle : vehicles) {
            if (vehicle) {
                vehicle->render(renderer, carTexture, queuePos);
                queuePos++;
            }
        }
    }
}

void Renderer::drawDebugOverlay() {
    // Draw semi-transparent background
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 200); // More opaque background
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
    SDL_FRect overlayRect = {10, 10, 280, 180}; // Larger overlay
    SDL_RenderFillRect(renderer, &overlayRect);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    // Add border
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderRect(renderer, &overlayRect);

    // Draw statistics
    drawStatistics();

    // Draw title
    drawText("Traffic Junction Simulator", 20, 20, {255, 255, 255, 255});
    drawText("Press D to toggle debug overlay", 20, 40, {200, 200, 200, 255});

    // Draw recent logs
    std::vector<std::string> logs = DebugLogger::getRecentLogs(5);
    int y = 170;

    for (const auto& log : logs) {
        std::string truncatedLog = log.length() > 50 ? log.substr(0, 47) + "..." : log;
        drawText(truncatedLog, 10, y, {200, 200, 200, 255});
        y += 20;
    }
}

void Renderer::drawStatistics() {
    if (!trafficManager) {
        return;
    }

    // Get statistics from traffic manager
    std::string stats = trafficManager->getStatistics();

    // Split into lines
    std::istringstream stream(stats);
    std::string line;
    int y = 60;

    while (std::getline(stream, line)) {
        // Check if line contains priority info
        if (line.find("PRIORITY") != std::string::npos) {
            drawText(line, 20, y, {255, 140, 0, 255}); // Highlight priority lanes
        } else if (line.find("A2") != std::string::npos) {
            drawText(line, 20, y, {255, 200, 0, 255}); // Highlight A2 lane
        } else {
            drawText(line, 20, y, {255, 255, 255, 255});
        }
        y += 20;
    }

    // Show current traffic light state
    SDL_Color stateColor = {255, 255, 255, 255};
    std::string stateText = "Traffic Light: ";

    auto* trafficLight = trafficManager->getTrafficLight();
    if (trafficLight) {
        auto currentState = trafficLight->getCurrentState();
        switch (currentState) {
            case TrafficLight::State::ALL_RED:
                stateText += "All Red";
                stateColor = {255, 100, 100, 255};
                break;
            case TrafficLight::State::A_GREEN:
                stateText += "A Green (North)";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::B_GREEN:
                stateText += "B Green (East)";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::C_GREEN:
                stateText += "C Green (South)";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::D_GREEN:
                stateText += "D Green (West)";
                stateColor = {100, 255, 100, 255};
                break;
        }
    }

    drawText(stateText, 20, y, stateColor);
}

void Renderer::drawText(const std::string& text, int x, int y, SDL_Color color) {
    // Since we don't have SDL_ttf configured, draw a colored rectangle
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);
    SDL_FRect textRect = {static_cast<float>(x), static_cast<float>(y),
                         static_cast<float>(8 * text.length()), 15};

    // Draw colored rectangle representing text
    SDL_RenderFillRect(renderer, &textRect);

    // Draw text outline
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderRect(renderer, &textRect);
}

void Renderer::drawArrow(int x1, int y1, int x2, int y2, int x3, int y3, SDL_Color color) {
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);

    // Draw triangle outline
    SDL_RenderLine(renderer, x1, y1, x2, y2);
    SDL_RenderLine(renderer, x2, y2, x3, y3);
    SDL_RenderLine(renderer, x3, y3, x1, y1);

    // Create vertices for filled triangle with SDL_FColor for SDL3 compatibility
    SDL_Vertex vertices[3];

    // Convert SDL_Color to SDL_FColor for vertices
    SDL_FColor fcolor = {
        static_cast<float>(color.r) / 255.0f,
        static_cast<float>(color.g) / 255.0f,
        static_cast<float>(color.b) / 255.0f,
        static_cast<float>(color.a) / 255.0f
    };

    // First vertex
    vertices[0].position.x = x1;
    vertices[0].position.y = y1;
    vertices[0].color = fcolor;

    // Second vertex
    vertices[1].position.x = x2;
    vertices[1].position.y = y2;
    vertices[1].color = fcolor;

    // Third vertex
    vertices[2].position.x = x3;
    vertices[2].position.y = y3;
    vertices[2].color = fcolor;

    // Draw the filled triangle
    SDL_RenderGeometry(renderer, NULL, vertices, 3, NULL, 0);
}

void Renderer::cleanup() {
    if (carTexture) {
        SDL_DestroyTexture(carTexture);
        carTexture = nullptr;
    }

    if (renderer) {
        SDL_DestroyRenderer(renderer);
        renderer = nullptr;
    }

    if (window) {
        SDL_DestroyWindow(window);
        window = nullptr;
    }

    DebugLogger::log("Renderer resources cleaned up");
}

bool Renderer::isActive() const {
    return active;
}

void Renderer::toggleDebugOverlay() {
    showDebugOverlay = !showDebugOverlay;
    DebugLogger::log("Debug overlay " + std::string(showDebugOverlay ? "enabled" : "disabled"));
}

void Renderer::setFrameRateLimit(int fps) {
    frameRateLimit = fps;
}

void Renderer::setTrafficManager(TrafficManager* manager) {
    trafficManager = manager;
}


//===== END FILE: {file_path} =====//

//===== FILE: src/utils/DebugLogger.cpp =====//

#include "utils/DebugLogger.h"
#include <iostream>
#include <fstream>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <sstream>

// Static class members initialization
std::string DebugLogger::logFilePath = "traffic_simulator.log";
std::vector<std::string> DebugLogger::recentLogs;
std::mutex DebugLogger::logMutex;
bool DebugLogger::initialized = false;

void DebugLogger::initialize(const std::string& path) {
    std::lock_guard<std::mutex> lock(logMutex);
    logFilePath = path;

    // Create/clear the log file
    std::ofstream file(logFilePath, std::ios::trunc);
    if (file.is_open()) {
        file << "=== Traffic Simulator Log ===\n";
        file.close();
    }

    initialized = true;
}

void DebugLogger::log(const std::string& message, LogLevel level) {
    if (!initialized) {
        initialize(); // Initialize with default path if not done already
    }

    std::string levelStr;
    switch (level) {
        case LogLevel::INFO:    levelStr = "INFO"; break;
        case LogLevel::WARNING: levelStr = "WARNING"; break;
        case LogLevel::ERROR:   levelStr = "ERROR"; break;
        case LogLevel::DEBUG:   levelStr = "DEBUG"; break;
        default:                levelStr = "INFO"; break;
    }

    std::string timestamp = getTimestamp();
    std::string formattedMessage = "[" + timestamp + "] [" + levelStr + "] " + message;

    // Store in recent logs (limited to last 100)
    {
        std::lock_guard<std::mutex> lock(logMutex);
        recentLogs.push_back(formattedMessage);
        if (recentLogs.size() > 100) {
            recentLogs.erase(recentLogs.begin());
        }
    }

    // Write to file
    writeToFile(formattedMessage);

    // Also output to console
    std::cout << formattedMessage << std::endl;
}

std::vector<std::string> DebugLogger::getRecentLogs(int count) {
    std::lock_guard<std::mutex> lock(logMutex);

    if (count <= 0 || recentLogs.empty()) {
        return {};
    }

    if (count >= static_cast<int>(recentLogs.size())) {
        return recentLogs;
    }

    // Return last 'count' logs
    return std::vector<std::string>(
        recentLogs.end() - count,
        recentLogs.end()
    );
}

void DebugLogger::clearLogs() {
    std::lock_guard<std::mutex> lock(logMutex);
    recentLogs.clear();

    // Clear the log file
    std::ofstream file(logFilePath, std::ios::trunc);
    if (file.is_open()) {
        file << "=== Traffic Simulator Log (Cleared) ===\n";
        file.close();
    }
}

void DebugLogger::shutdown() {
    std::lock_guard<std::mutex> lock(logMutex);

    if (!initialized) {
        return;
    }

    writeToFile("[" + getTimestamp() + "] [INFO] Logger shutdown");
    initialized = false;
}

std::string DebugLogger::getTimestamp() {
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;

    std::stringstream ss;
    ss << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S")
       << '.' << std::setfill('0') << std::setw(3) << ms.count();

    return ss.str();
}

void DebugLogger::writeToFile(const std::string& message) {
    std::ofstream file(logFilePath, std::ios::app);
    if (file.is_open()) {
        file << message << std::endl;
        file.close();
    }
}


//===== END FILE: {file_path} =====//

//===== FILE: src/main.cpp =====//

#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <SDL3/SDL.h>
#include <fstream>
#include <filesystem>
#include <vector>
#include <map>
#include <algorithm>
#include <random>
#include <cmath>

// Include the necessary headers
#include "core/Vehicle.h"
#include "core/Lane.h"
#include "core/TrafficLight.h"
#include "managers/TrafficManager.h"
#include "managers/FileHandler.h"
#include "visualization/Renderer.h"
#include "utils/DebugLogger.h"

namespace fs = std::filesystem;

// Constants
const int WINDOW_WIDTH = 800;
const int WINDOW_HEIGHT = 800;
const std::string DATA_DIR = "data/lanes";
const int PRIORITY_THRESHOLD_HIGH = 10;
const int PRIORITY_THRESHOLD_LOW = 5;

// Car colors for variety
const SDL_Color CAR_COLORS[] = {
    {200, 0, 0, 255},    // Red
    {0, 0, 200, 255},    // Blue
    {0, 150, 0, 255},    // Green
    {150, 150, 0, 255},  // Yellow
    {100, 100, 100, 255},// Gray
    {0, 150, 150, 255},  // Teal
    {150, 0, 150, 255},  // Purple
    {200, 100, 0, 255},  // Orange
    {0, 0, 0, 255}       // Black
};
const int NUM_CAR_COLORS = 9;

// Road colors
const SDL_Color ROAD_COLOR = {60, 60, 60, 255};
const SDL_Color LANE_MARKER_COLOR = {255, 255, 255, 255};
const SDL_Color YELLOW_MARKER_COLOR = {255, 255, 0, 255};
const SDL_Color INTERSECTION_COLOR = {50, 50, 50, 255};
const SDL_Color SIDEWALK_COLOR = {180, 180, 180, 255};
const SDL_Color GRASS_COLOR = {100, 200, 100, 255};

// Simple logging function
void log_message(const std::string& msg) {
    std::cout << "[Simulator] " << msg << std::endl;

    // Also log to file
    std::ofstream log("simulator_debug.log", std::ios::app);
    if (log.is_open()) {
        log << "[Simulator] " << msg << std::endl;
        log.close();
    }

    // Also use DebugLogger
    DebugLogger::log(msg);
}

// Ensure data directories exist
bool ensure_directories() {
    try {
        if (!fs::exists(DATA_DIR)) {
            fs::create_directories(DATA_DIR);
            log_message("Created directory: " + DATA_DIR);
        }
        return true;
    } catch (const std::exception& e) {
        log_message("Error creating directories: " + std::string(e.what()));
        return false;
    }
}

// Create a random number generator
std::mt19937 rng(std::random_device{}());

// Direction enum
enum class VehicleDirection {
    STRAIGHT = 0,
    LEFT = 1,
    RIGHT = 2
};

// The RenderSystem class for main visualization
class RenderSystem {
public:
    SDL_Window* window;
    SDL_Renderer* rendererSDL;
    int windowWidth;
    int windowHeight;
    bool active;
    bool showDebug;
    TrafficManager* trafficMgr;

    RenderSystem()
        : window(nullptr),
          rendererSDL(nullptr),
          windowWidth(800),
          windowHeight(800),
          active(false),
          showDebug(false), // Set to false to disable debug overlay
          trafficMgr(nullptr) {}

    ~RenderSystem() {
        cleanup();
    }

    // Initialize renderer
    bool initialize(int width, int height, const std::string& title) {
        windowWidth = width;
        windowHeight = height;

        // Create window
        window = SDL_CreateWindow(title.c_str(), width, height, SDL_WINDOW_OPENGL);
        if (!window) {
            log_message("Failed to create window: " + std::string(SDL_GetError()));
            return false;
        }

        // Create renderer
        rendererSDL = SDL_CreateRenderer(window, NULL);
        if (!rendererSDL) {
            log_message("Failed to create renderer: " + std::string(SDL_GetError()));
            return false;
        }

        active = true;
        log_message("Renderer initialized successfully");
        return true;
    }

    // Set traffic manager
    void setTrafficManager(TrafficManager* manager) {
        trafficMgr = manager;
    }

    // Draw a realistic road layout
    void drawRoadLayout() {
        const int ROAD_WIDTH = 150;
        const int LANE_WIDTH = 50;
        const int SIDEWALK_WIDTH = 20;

        // Draw grass background
        SDL_SetRenderDrawColor(rendererSDL, GRASS_COLOR.r, GRASS_COLOR.g, GRASS_COLOR.b, GRASS_COLOR.a);
        SDL_RenderClear(rendererSDL);

        // Draw sidewalks
        SDL_SetRenderDrawColor(rendererSDL, SIDEWALK_COLOR.r, SIDEWALK_COLOR.g, SIDEWALK_COLOR.b, SIDEWALK_COLOR.a);

        // Horizontal sidewalks
        SDL_FRect hSidewalk1 = {0, (float)(windowHeight/2 - ROAD_WIDTH/2 - SIDEWALK_WIDTH),
                               (float)windowWidth, (float)SIDEWALK_WIDTH};
        SDL_FRect hSidewalk2 = {0, (float)(windowHeight/2 + ROAD_WIDTH/2),
                               (float)windowWidth, (float)SIDEWALK_WIDTH};
        SDL_RenderFillRect(rendererSDL, &hSidewalk1);
        SDL_RenderFillRect(rendererSDL, &hSidewalk2);

        // Vertical sidewalks
        SDL_FRect vSidewalk1 = {(float)(windowWidth/2 - ROAD_WIDTH/2 - SIDEWALK_WIDTH), 0,
                               (float)SIDEWALK_WIDTH, (float)windowHeight};
        SDL_FRect vSidewalk2 = {(float)(windowWidth/2 + ROAD_WIDTH/2), 0,
                               (float)SIDEWALK_WIDTH, (float)windowHeight};
        SDL_RenderFillRect(rendererSDL, &vSidewalk1);
        SDL_RenderFillRect(rendererSDL, &vSidewalk2);

        // Draw main roads (dark gray)
        SDL_SetRenderDrawColor(rendererSDL, ROAD_COLOR.r, ROAD_COLOR.g, ROAD_COLOR.b, ROAD_COLOR.a);

        // Horizontal road
        SDL_FRect hRoad = {0, (float)(windowHeight/2 - ROAD_WIDTH/2),
                          (float)windowWidth, (float)ROAD_WIDTH};
        SDL_RenderFillRect(rendererSDL, &hRoad);

        // Vertical road
        SDL_FRect vRoad = {(float)(windowWidth/2 - ROAD_WIDTH/2), 0,
                          (float)ROAD_WIDTH, (float)windowHeight};
        SDL_RenderFillRect(rendererSDL, &vRoad);

        // Draw intersection (slightly darker)
        SDL_SetRenderDrawColor(rendererSDL, INTERSECTION_COLOR.r, INTERSECTION_COLOR.g, INTERSECTION_COLOR.b, INTERSECTION_COLOR.a);
        SDL_FRect intersection = {(float)(windowWidth/2 - ROAD_WIDTH/2), (float)(windowHeight/2 - ROAD_WIDTH/2),
                                 (float)ROAD_WIDTH, (float)ROAD_WIDTH};
        SDL_RenderFillRect(rendererSDL, &intersection);

        // Draw lane dividers
        // Horizontal lane dividers
        for (int i = 1; i < 3; i++) {
            int y = windowHeight/2 - ROAD_WIDTH/2 + i * LANE_WIDTH;

            if (i == 1) {
                // Center line (yellow)
                SDL_SetRenderDrawColor(rendererSDL, YELLOW_MARKER_COLOR.r, YELLOW_MARKER_COLOR.g,
                                     YELLOW_MARKER_COLOR.b, YELLOW_MARKER_COLOR.a);
            } else {
                // Other lane dividers (white)
                SDL_SetRenderDrawColor(rendererSDL, LANE_MARKER_COLOR.r, LANE_MARKER_COLOR.g,
                                     LANE_MARKER_COLOR.b, LANE_MARKER_COLOR.a);
            }

            // Draw dashed lines outside intersection
            for (int x = 0; x < windowWidth; x += 30) {
                if (x < windowWidth/2 - ROAD_WIDTH/2 || x > windowWidth/2 + ROAD_WIDTH/2) {
                    SDL_FRect line = {(float)x, (float)y - 2, 15, 4};
                    SDL_RenderFillRect(rendererSDL, &line);
                }
            }
        }

        // Vertical lane dividers
        for (int i = 1; i < 3; i++) {
            int x = windowWidth/2 - ROAD_WIDTH/2 + i * LANE_WIDTH;

            if (i == 1) {
                // Center line (yellow)
                SDL_SetRenderDrawColor(rendererSDL, YELLOW_MARKER_COLOR.r, YELLOW_MARKER_COLOR.g,
                                     YELLOW_MARKER_COLOR.b, YELLOW_MARKER_COLOR.a);
            } else {
                // Other lane dividers (white)
                SDL_SetRenderDrawColor(rendererSDL, LANE_MARKER_COLOR.r, LANE_MARKER_COLOR.g,
                                     LANE_MARKER_COLOR.b, LANE_MARKER_COLOR.a);
            }

            // Draw dashed lines outside intersection
            for (int y = 0; y < windowHeight; y += 30) {
                if (y < windowHeight/2 - ROAD_WIDTH/2 || y > windowHeight/2 + ROAD_WIDTH/2) {
                    SDL_FRect line = {(float)x - 2, (float)y, 4, 15};
                    SDL_RenderFillRect(rendererSDL, &line);
                }
            }
        }

        // Draw crosswalks
        SDL_SetRenderDrawColor(rendererSDL, 255, 255, 255, 255);

        // North crosswalk
        for (int i = 0; i < 10; i++) {
            SDL_FRect stripe = {(float)(windowWidth/2 - ROAD_WIDTH/2 + 15*i),
                               (float)(windowHeight/2 - ROAD_WIDTH/2 - 15), 10, 15};
            SDL_RenderFillRect(rendererSDL, &stripe);
        }

        // South crosswalk
        for (int i = 0; i < 10; i++) {
            SDL_FRect stripe = {(float)(windowWidth/2 - ROAD_WIDTH/2 + 15*i),
                               (float)(windowHeight/2 + ROAD_WIDTH/2), 10, 15};
            SDL_RenderFillRect(rendererSDL, &stripe);
        }

        // East crosswalk
        for (int i = 0; i < 10; i++) {
            SDL_FRect stripe = {(float)(windowWidth/2 + ROAD_WIDTH/2),
                               (float)(windowHeight/2 - ROAD_WIDTH/2 + 15*i), 15, 10};
            SDL_RenderFillRect(rendererSDL, &stripe);
        }

        // West crosswalk
        for (int i = 0; i < 10; i++) {
            SDL_FRect stripe = {(float)(windowWidth/2 - ROAD_WIDTH/2 - 15),
                               (float)(windowHeight/2 - ROAD_WIDTH/2 + 15*i), 15, 10};
            SDL_RenderFillRect(rendererSDL, &stripe);
        }
    }

    // Render a frame
    void renderFrame() {
        if (!active || !rendererSDL || !trafficMgr) {
            return;
        }

        // Draw realistic road layout
        drawRoadLayout();

        // Draw traffic lights
        if (trafficMgr->getTrafficLight()) {
            trafficMgr->getTrafficLight()->render(rendererSDL);
        }

        // Draw vehicles
        for (auto* lane : trafficMgr->getLanes()) {
            for (auto* vehicle : lane->getVehicles()) {
                if (vehicle) {
                    // Create default parameters for vehicle rendering
                    int queuePos = 0; // Not important for this call
                    vehicle->render(rendererSDL, nullptr, queuePos);
                }
            }
        }

        // Draw debug overlay only if enabled
        if (showDebug) {
            drawDebugOverlay();
        }

        // Present render
        SDL_RenderPresent(rendererSDL);
    }

    // Start render loop
    void startRenderLoop() {
        if (!active) {
            return;
        }

        log_message("Starting render loop");

        bool running = true;
        uint32_t lastUpdateTime = SDL_GetTicks();

        while (running) {
            // Process events
            SDL_Event event;
            while (SDL_PollEvent(&event)) {
                if (event.type == SDL_EVENT_QUIT) {
                    running = false;
                } else if (event.type == SDL_EVENT_KEY_DOWN) {
                    // Fixed SDL3 key handling
                    int key = event.key.which;

                    if (key == SDL_SCANCODE_D) {
                        showDebug = !showDebug;
                        log_message("Debug overlay " + std::string(showDebug ? "enabled" : "disabled"));
                    } else if (key == SDL_SCANCODE_ESCAPE) {
                        running = false;
                    }
                }
            }

            // Calculate delta time
            uint32_t currentTime = SDL_GetTicks();
            uint32_t deltaTime = currentTime - lastUpdateTime;

            // Update traffic manager
            if (trafficMgr) {
                trafficMgr->update(deltaTime);
            }

            // Render frame
            renderFrame();

            // Limit frame rate
            SDL_Delay(16); // ~60 FPS

            lastUpdateTime = currentTime;
        }
    }

    // Draw debug overlay - now much smaller and less intrusive
    void drawDebugOverlay() {
        if (!trafficMgr) return;

        // Draw semi-transparent background
        SDL_SetRenderDrawColor(rendererSDL, 0, 0, 0, 180);
        SDL_SetRenderDrawBlendMode(rendererSDL, SDL_BLENDMODE_BLEND);
        SDL_FRect overlayRect = {10, 10, 200, 100}; // Much smaller overlay
        SDL_RenderFillRect(rendererSDL, &overlayRect);
        SDL_SetRenderDrawBlendMode(rendererSDL, SDL_BLENDMODE_NONE);

        // Draw border
        SDL_SetRenderDrawColor(rendererSDL, 255, 255, 255, 255);
        SDL_RenderRect(rendererSDL, &overlayRect);

        // Function to draw text (simplified with rectangles)
        auto drawText = [this](const std::string& text, float x, float y, SDL_Color color) {
            SDL_SetRenderDrawColor(rendererSDL, color.r, color.g, color.b, color.a);
            SDL_FRect rect = {x, y, text.length() * 7.0f, 16.0f};
            SDL_RenderFillRect(rendererSDL, &rect);

            // Black border
            SDL_SetRenderDrawColor(rendererSDL, 0, 0, 0, 255);
            SDL_RenderRect(rendererSDL, &rect);
        };

        // Title
        drawText("Traffic Simulator", 20, 20, {255, 255, 255, 255});

        // Traffic light state
        std::string stateStr = "Light: ";
        SDL_Color stateColor = {255, 255, 255, 255};

        auto currentState = trafficMgr->getTrafficLight()->getCurrentState();

        switch (currentState) {
            case TrafficLight::State::ALL_RED:
                stateStr += "All Red";
                stateColor = {255, 100, 100, 255};
                break;
            case TrafficLight::State::A_GREEN:
                stateStr += "A Green";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::B_GREEN:
                stateStr += "B Green";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::C_GREEN:
                stateStr += "C Green";
                stateColor = {100, 255, 100, 255};
                break;
            case TrafficLight::State::D_GREEN:
                stateStr += "D Green";
                stateColor = {100, 255, 100, 255};
                break;
        }

        drawText(stateStr, 20, 45, stateColor);

        // Priority status
        bool isPriorityMode = false;
        Lane* priorityLane = trafficMgr->getPriorityLane();
        if (priorityLane && priorityLane->getPriority() > 0) {
            isPriorityMode = true;
            drawText("PRIORITY MODE", 20, 70, {255, 165, 0, 255});
        }
    }

    // Clean up resources
    void cleanup() {
        if (rendererSDL) {
            SDL_DestroyRenderer(rendererSDL);
            rendererSDL = nullptr;
        }

        if (window) {
            SDL_DestroyWindow(window);
            window = nullptr;
        }

        active = false;
    }
};

// Main function
int main(int argc, char* argv[]) {
    try {
        // Initialize debug logger
        DebugLogger::initialize();
        log_message("Starting Traffic Junction Simulator");


        // Create traffic manager
        TrafficManager trafficManager;
        if (!trafficManager.initialize()) {
            log_message("Failed to initialize traffic manager");
            SDL_Quit();
            return 1;
        }

        // Create renderer
        RenderSystem renderer;
        if (!renderer.initialize(WINDOW_WIDTH, WINDOW_HEIGHT, "Traffic Junction Simulator")) {
            log_message("Failed to initialize renderer");
            SDL_Quit();
            return 1;
        }

        // Connect traffic manager to renderer
        renderer.setTrafficManager(&trafficManager);

        // Start traffic manager
        trafficManager.start();

        // Start render loop
        renderer.startRenderLoop();

        // Cleanup
        trafficManager.stop();
        renderer.cleanup();
        SDL_Quit();

        log_message("Simulator shutdown complete");
        return 0;
    }
    catch (const std::exception& e) {
        log_message("Unhandled exception: " + std::string(e.what()));
        SDL_Quit();
        return 1;
    }
}


//===== END FILE: {file_path} =====//

//===== FILE: src/traffic_generator.cpp =====//

// FILE: src/traffic_generator.cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <random>
#include <chrono>
#include <thread>
#include <filesystem>
#include <ctime>
#include <mutex>
#include <iomanip>
#include <atomic>
#include <csignal>
#include <map>  // Added missing map header

// Include Windows-specific headers if on Windows
#ifdef _WIN32
#include <windows.h>
#endif

// Namespaces
namespace fs = std::filesystem;

// Constants for the generator
const std::string DATA_DIR = "data/lanes";
const int GENERATION_INTERVAL_MS = 800;
const int MAX_VEHICLES_PER_BATCH = 50;
const int PRIORITY_THRESHOLD_HIGH = 10;
const int PRIORITY_THRESHOLD_LOW = 5;

// Vehicle direction (for lane assignment)
enum class Direction {
    LEFT,
    STRAIGHT,
    RIGHT
};

// Global atomic flag to control continuous generation
std::atomic<bool> keepRunning(true);

// Signal handler for clean shutdown
void signalHandler(int signum) {
    keepRunning = false;
    std::cout << "\nReceived termination signal. Stopping generator...\n";
}

// Set up colored console output
void setupConsole() {
#ifdef _WIN32
    // Enable ANSI escape codes on Windows
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD dwMode = 0;
    GetConsoleMode(hOut, &dwMode);
    SetConsoleMode(hOut, dwMode | ENABLE_VIRTUAL_TERMINAL_PROCESSING);
#endif
}

// Simple console log with color
void console_log(const std::string& message, const std::string& color = "\033[1;36m") {
    std::time_t now = std::time(nullptr);
    std::tm timeinfo;

#ifdef _WIN32
    localtime_s(&timeinfo, &now);
#else
    localtime_r(&now, &timeinfo);
#endif

    char timestamp[64];
    std::strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", &timeinfo);

    std::cout << color << "[" << timestamp << "]\033[0m " << message << std::endl;
}

// Ensure data directories exist
void ensure_directories() {
    if (!fs::exists(DATA_DIR)) {
        fs::create_directories(DATA_DIR);
        console_log("Created directory: " + DATA_DIR);
    }
}

// Write a vehicle to lane file
void write_vehicle(const std::string& id, char lane, int laneNumber, Direction dir = Direction::LEFT) {
    static std::mutex fileMutex;
    std::lock_guard<std::mutex> lock(fileMutex);

    // Skip invalid lane numbers
    if (laneNumber < 1 || laneNumber > 3) {
        return;
    }

    std::string filepath = DATA_DIR + "/lane" + lane + ".txt";
    std::ofstream file(filepath, std::ios::app);

    if (file.is_open()) {
        // Format: vehicleId_L{laneNumber}:lane
        file << id << "_L" << laneNumber;

        // Add direction info based on lane and specific rules
        if (laneNumber == 3) {
            // Lane 3 always turns left
            file << "_LEFT";
        } else if (laneNumber == 2) {
            // Lane 2 can go straight or right
            if (dir == Direction::STRAIGHT) {
                file << "_STRAIGHT";
            } else {
                file << "_RIGHT";
            }
        } else if (laneNumber == 1) {
            // Lane 1 is incoming lane - no special handling needed
        }

        file << ":" << lane << std::endl;
        file.close();

        // Format log message with colors based on lane type
        std::string color = "\033[1;32m"; // Default green
        std::string dirStr = "";

        if (laneNumber == 3) {
            color = "\033[1;32m"; // Green for free lane
            dirStr = " (LEFT turn)";
        } else if (laneNumber == 2 && lane == 'A') {
            color = "\033[1;33m"; // Yellow for priority lane
            dirStr = (dir == Direction::STRAIGHT) ? " (STRAIGHT)" : " (RIGHT turn)";
        } else if (laneNumber == 2) {
            color = "\033[1;37m"; // White for normal lane 2
            dirStr = (dir == Direction::STRAIGHT) ? " (STRAIGHT)" : " (RIGHT turn)";
        } else {
            color = "\033[1;36m"; // Cyan for lane 1
        }

        console_log("Added " + id + " to lane " + lane + std::to_string(laneNumber) + dirStr, color);
    } else {
        console_log("ERROR: Could not open file " + filepath, "\033[1;31m");
    }
}

// Generate a random lane (A, B, C, D) - North, East, South, West
char random_lane() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_int_distribution<int> dist(0, 3);
    return 'A' + dist(gen);
}

// Generate a lane number with improved distribution (1, 2, or 3)
int random_lane_number() {
    static std::random_device rd;
    static std::mt19937 gen(rd());

    // Improved distribution: 20% lane 1, 50% lane 2, 30% lane 3
    std::vector<double> weights = {0.2, 0.5, 0.3};
    std::discrete_distribution<int> dist(weights.begin(), weights.end());

    return dist(gen) + 1; // Returns 1, 2, or 3
}

// Generate direction (straight, left, right) based on lane rules
Direction random_direction(int laneNumber) {
    static std::random_device rd;
    static std::mt19937 gen(rd());

    if (laneNumber == 3) {
        // Lane 3 always goes left
        return Direction::LEFT;
    } else if (laneNumber == 2) {
        // Lane 2 can go straight (60%) or right (40%)
        std::vector<double> weights = {0.0, 0.6, 0.4}; // [LEFT, STRAIGHT, RIGHT]
        std::discrete_distribution<int> dist(weights.begin(), weights.end());
        return static_cast<Direction>(dist(gen));
    } else {
        // Lane 1 is incoming lane
        return Direction::STRAIGHT;
    }
}

// Clear existing files
void clear_files() {
    for (char lane = 'A'; lane <= 'D'; lane++) {
        std::string filepath = DATA_DIR + "/lane" + lane + ".txt";
        std::ofstream file(filepath, std::ios::trunc);
        file.close();
        console_log("Cleared file: " + filepath);
    }
}

// Display status of current generation
void display_status(int current, int total, int a2_count) {
    const int barWidth = 40;
    float progress = static_cast<float>(current) / total;
    int pos = static_cast<int>(barWidth * progress);

    std::cout << "\r\033[1;33m[";
    for (int i = 0; i < barWidth; ++i) {
        if (i < pos) std::cout << "=";
        else if (i == pos) std::cout << ">";
        else std::cout << " ";
    }

    std::cout << "] " << int(progress * 100.0) << "% "
              << "Vehicles: " << current << "/" << total
              << " (A2: " << a2_count << ")\033[0m" << std::flush;
}

// Count current vehicles in each lane from files
std::map<std::string, int> count_vehicles_in_lanes() {
    std::map<std::string, int> counts;

    for (char lane = 'A'; lane <= 'D'; lane++) {
        std::string filepath = DATA_DIR + "/lane" + lane + ".txt";
        std::ifstream file(filepath);

        if (file.is_open()) {
            std::string line;
            while (std::getline(file, line)) {
                // Extract lane number
                size_t lanePos = line.find("_L");
                if (lanePos != std::string::npos && lanePos + 2 < line.length()) {
                    char laneNumChar = line[lanePos + 2];
                    if (laneNumChar >= '1' && laneNumChar <= '3') {
                        std::string laneKey = std::string(1, lane) + laneNumChar;
                        counts[laneKey]++;
                    }
                }
            }
            file.close();
        }
    }

    return counts;
}

// Display current lane statistics
void display_lane_stats() {
    auto counts = count_vehicles_in_lanes();

    std::cout << "\033[1;34m";
    std::cout << "ââââââââââââââââââââââââââââââââââââââ\n";
    std::cout << "â          Lane Statistics           â\n";
    std::cout << "ââââââââââ¬ââââââââ¬ââââââââ¬ââââââââââââ¤\n";
    std::cout << "â  Road  â  L1   â  L2   â  L3(Free) â\n";
    std::cout << "ââââââââââ¼ââââââââ¼ââââââââ¼ââââââââââââ¤\n";

    int total = 0;
    for (char lane = 'A'; lane <= 'D'; lane++) {
        std::string laneLabel;
        switch (lane) {
            case 'A': laneLabel = "A(North)"; break;
            case 'B': laneLabel = "B(East) "; break;
            case 'C': laneLabel = "C(South)"; break;
            case 'D': laneLabel = "D(West) "; break;
        }

        std::cout << "â " << laneLabel << " â";

        for (int i = 1; i <= 3; i++) {
            std::string laneKey = std::string(1, lane) + std::to_string(i);
            int count = counts[laneKey];
            total += count;

            // Highlight A2 (priority lane) if over threshold
            if (lane == 'A' && i == 2 && count > PRIORITY_THRESHOLD_HIGH) {
                std::cout << " \033[1;33m" << std::setw(5) << count << "\033[1;34m â";
            } else {
                std::cout << " " << std::setw(5) << count << " â";
            }
        }
        std::cout << "\n";
    }

    std::cout << "ââââââââââ´ââââââââ´ââââââââ´ââââââââââââ¤\n";
    std::cout << "â Total vehicles: " << std::setw(20) << total << " â\n";
    std::cout << "ââââââââââââââââââââââââââââââââââââââ\033[0m\n";
}

int main() {
    try {
        // Set up signal handler for clean termination
        std::signal(SIGINT, signalHandler);

        // Set up console for colored output
        setupConsole();

        console_log("â Traffic generator starting", "\033[1;35m");

        // Create directories and clear files
        ensure_directories();
        clear_files();

        // Random generators
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> delay_dist(0.7, 1.3); // For randomized intervals

        // Global tracking variables
        int total_vehicles = 0;
        int a2_count = 0;
        int current_batch = 0;

        // First generate A2 priority lane vehicles
        console_log("ð¦ Generating priority lane vehicles (A2)", "\033[1;33m");
        for (int i = 0; i < 12 && keepRunning; i++) {
            std::string id = "V" + std::to_string(total_vehicles + 1);

            // Alternate between straight and right turns for lane A2
            Direction dir = (i % 2 == 0) ? Direction::STRAIGHT : Direction::RIGHT;
            write_vehicle(id, 'A', 2, dir); // Lane A2 with direction

            total_vehicles++;
            a2_count++;
            current_batch++;

            // Display progress
            display_status(current_batch, MAX_VEHICLES_PER_BATCH, a2_count);

            // Wait between vehicles with slight randomization
            std::this_thread::sleep_for(
                std::chrono::milliseconds(
                    static_cast<int>(GENERATION_INTERVAL_MS * delay_dist(gen))
                )
            );
        }

        std::cout << std::endl;
        console_log("ð Generating continuous traffic flow", "\033[1;34m");

        // Display starting lane stats
        display_lane_stats();

        // Stats display timer
        auto lastStatsTime = std::chrono::steady_clock::now();
        bool in_priority_mode = false;

        // Continuous generation until terminated
        while (keepRunning) {
            char lane = random_lane();
            int lane_num = random_lane_number();
            Direction dir = random_direction(lane_num);

            // For testing priority condition, occasionally bias toward lane A2
            if (gen() % 10 == 0) {
                lane = 'A';
                lane_num = 2;
                dir = (gen() % 2 == 0) ? Direction::STRAIGHT : Direction::RIGHT;
            }

            // Also ensure good distribution for lane 3 (free lane)
            if (gen() % 15 == 0) {
                lane = random_lane();
                lane_num = 3; // Force lane 3 (free lane)
                dir = Direction::LEFT; // Lane 3 always turns left
            }

            std::string id = "V" + std::to_string(total_vehicles + 1);

            // Write vehicle to file with appropriate direction
            write_vehicle(id, lane, lane_num, dir);

            // Update counters
            total_vehicles++;
            current_batch++;
            if (lane == 'A' && lane_num == 2) {
                a2_count++;
            }

            // Display progress
            display_status(current_batch, MAX_VEHICLES_PER_BATCH, a2_count);

            // Periodically display lane stats (every 5 seconds)
            auto currentTime = std::chrono::steady_clock::now();
            if (std::chrono::duration_cast<std::chrono::seconds>(currentTime - lastStatsTime).count() >= 5) {
                std::cout << std::endl;
                display_lane_stats();
                lastStatsTime = currentTime;
            }

            // Reset batch counter when it reaches max
            if (current_batch >= MAX_VEHICLES_PER_BATCH) {
                current_batch = 0;
                std::cout << std::endl;
                console_log("â»ï¸ New batch starting", "\033[1;34m");
                display_lane_stats();
            }

            // Check priority lane count and log state changes
            auto counts = count_vehicles_in_lanes();
            int a2_count_current = counts["A2"];

            if (!in_priority_mode && a2_count_current > PRIORITY_THRESHOLD_HIGH) {
                in_priority_mode = true;
                console_log("â ï¸ Priority mode activated (A2: " + std::to_string(a2_count_current) +
                          " vehicles)", "\033[1;31m");
            } else if (in_priority_mode && a2_count_current < PRIORITY_THRESHOLD_LOW) {
                in_priority_mode = false;
                console_log("â Priority mode deactivated (A2: " + std::to_string(a2_count_current) +
                          " vehicles)", "\033[1;32m");
            }

            // Wait between vehicles with slight randomization
            std::this_thread::sleep_for(
                std::chrono::milliseconds(
                    static_cast<int>(GENERATION_INTERVAL_MS * delay_dist(gen))
                )
            );
        }

        std::cout << std::endl;
        console_log("â Traffic generator completed. Generated " +
                   std::to_string(total_vehicles) + " vehicles.", "\033[1;35m");

        return 0;
    }
    catch (const std::exception& e) {
        std::cerr << "\033[1;31mError: " << e.what() << "\033[0m" << std::endl;
        return 1;
    }
}


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\traffic_generator.h =====//

// include/traffic_generator.h
#pragma once
#include <string>
#include <random>
#include <map>
#include <filesystem>
#include <fstream>
#include <thread>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <mutex>

// Define constants similar to those in the main project
namespace Constants {
    static constexpr int MAX_QUEUE_SIZE = 100;
    static constexpr int PRIORITY_THRESHOLD = 10;
    static constexpr int NORMAL_THRESHOLD = 5;

    // Lane IDs (matching the main project)
    enum class LaneId {
        AL1_INCOMING = 0,
        AL2_PRIORITY = 1,
        AL3_FREELANE = 2,
        BL1_INCOMING = 3,
        BL2_NORMAL = 4,
        BL3_FREELANE = 5,
        CL1_INCOMING = 6,
        CL2_NORMAL = 7,
        CL3_FREELANE = 8,
        DL1_INCOMING = 9,
        DL2_NORMAL = 10,
        DL3_FREELANE = 11
    };

    // Direction values
    enum class Direction {
        STRAIGHT = 0,
        LEFT = 1,
        RIGHT = 2
    };
}

// Generator class to create vehicle data
class Generator {
private:
    std::mt19937 rng;  // Random number generator
    std::map<Constants::LaneId, std::filesystem::path> laneFiles;  // Lane file paths
    uint32_t nextVehicleId;  // ID counter for vehicles
    std::filesystem::path dataDir;  // Directory for data files
    std::mutex fileMutex;  // Thread safety for file operations

    // Settings for each lane
    struct LaneConfig {
        double spawnRate;
        int maxVehicles;
        bool canGoStraight;
        bool canGoLeft;
        bool canGoRight;
    };
    std::map<Constants::LaneId, LaneConfig> laneConfigs;

    // Private helper methods
    void initializeLaneFiles();
    void setupLaneConfigs();
    Constants::Direction getRandomDirection(const LaneConfig& config);
    size_t countVehiclesInFile(const std::filesystem::path& filepath) const;
    void writeVehicleToFile(const std::filesystem::path& filepath, uint32_t id,
                          Constants::Direction dir);
    void writeVehicleToCombinedFile(Constants::LaneId lane, uint32_t id);
    bool shouldGenerateVehicle(const LaneConfig& config, size_t currentCount);
    void clearAllFiles();
    void logGeneration(Constants::LaneId lane, uint32_t vehicleId, Constants::Direction dir,
                     size_t currentCount, int maxCount);

public:
    Generator();

    // Generate traffic for all lanes
    void generateTraffic();

    // Display generator status
    void displayStatus() const;
};


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\core\Constants.h =====//

// FILE: include/core/Constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

#include <string>
#include <SDL3/SDL.h>

namespace Constants {
    // Window settings
    constexpr int WINDOW_WIDTH = 800;
    constexpr int WINDOW_HEIGHT = 800;
    const std::string WINDOW_TITLE = "Traffic Junction Simulator";
    constexpr float SCALE = 1.1f;

    // Road settings
    constexpr int ROAD_WIDTH = 150;
    constexpr int LANE_WIDTH = 50;
    constexpr int ARROW_SIZE = 15;

    // Vehicle settings
    constexpr int MAX_VEHICLE_ID = 9999;
    constexpr float VEHICLE_LENGTH = 12.0f;
    constexpr float VEHICLE_WIDTH = 6.0f;
    constexpr float VEHICLE_GAP = 15.0f;
    constexpr float TURN_DURATION = 1500.0f;
    constexpr float BEZIER_CONTROL_OFFSET = 80.0f;
    constexpr float TURN_SPEED = 0.0008f;
    constexpr float MOVE_SPEED = 0.2f;

    // Traffic light settings
    constexpr int ALL_RED_DURATION = 2000; // 2 seconds
    constexpr int GREEN_DURATION_BASE = 3000;   // 3 seconds

    // Queue settings
    constexpr int MAX_QUEUE_SIZE = 100;

    // Priority settings
    constexpr int PRIORITY_THRESHOLD_HIGH = 10; // Enter priority mode when > 10 vehicles
    constexpr int PRIORITY_THRESHOLD_LOW = 5;   // Exit priority mode when < 5 vehicles

    // File paths
    const std::string DATA_PATH = "data/lanes";
    const std::string LOG_FILE = "traffic_simulator.log";

    // Colors
    constexpr SDL_Color ROAD_COLOR = {50, 50, 50, 255};
    constexpr SDL_Color LANE_MARKER_COLOR = {255, 255, 255, 255};
    constexpr SDL_Color YELLOW_MARKER_COLOR = {255, 255, 0, 255};
    constexpr SDL_Color RED_LIGHT_COLOR = {255, 0, 0, 255};
    constexpr SDL_Color GREEN_LIGHT_COLOR = {0, 255, 0, 255};
    constexpr SDL_Color NORMAL_VEHICLE_COLOR = {0, 0, 255, 255};
    constexpr SDL_Color EMERGENCY_VEHICLE_COLOR = {255, 0, 0, 255};
    constexpr SDL_Color PRIORITY_VEHICLE_COLOR = {255, 140, 0, 255}; // Orange for priority lane
    constexpr SDL_Color FREE_LANE_VEHICLE_COLOR = {0, 220, 60, 255}; // Green for free lane
    constexpr SDL_Color PRIORITY_INDICATOR_COLOR = {255, 165, 0, 255};
    constexpr SDL_Color TEXT_COLOR = {255, 255, 255, 255};
    constexpr SDL_Color DEBUG_BACKGROUND_COLOR = {0, 0, 0, 128};
}

#endif // CONSTANTS_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\core\Lane.h =====//

// FILE: include/core/Lane.h
#ifndef LANE_H
#define LANE_H

#include <vector>
#include <mutex>
#include <string>
#include "core/Vehicle.h"
#include "utils/Queue.h"

class Lane {
public:
    Lane(char laneId, int laneNumber);
    ~Lane();

    // Queue operations
    void enqueue(Vehicle* vehicle);
    Vehicle* dequeue();
    Vehicle* peek() const;
    bool isEmpty() const;
    int getVehicleCount() const;

    // Priority related operations
    int getPriority() const;
    void updatePriority();
    bool isPriorityLane() const;

    // Lane identification
    char getLaneId() const;
    int getLaneNumber() const;
    std::string getName() const;

    // For iteration through vehicles (for rendering)
    const std::vector<Vehicle*>& getVehicles() const;

private:
    char laneId;               // A, B, C, or D
    int laneNumber;            // 1, 2, or 3
    bool isPriority;           // Is this a priority lane (AL2)
    int priority;              // Current priority (higher means served first)
    std::vector<Vehicle*> vehicles; // Storage for vehicles in the lane
    mutable std::mutex mutex;  // For thread safety
};

#endif // LANE_Hendif // LANE_Hendif // LANE_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\core\TrafficLight.h =====//

// FILE: include/core/TrafficLight.h
#ifndef TRAFFIC_LIGHT_H
#define TRAFFIC_LIGHT_H

#include <cstdint>
#include <vector>
#include <string>
#include <SDL3/SDL.h>
#include "core/Lane.h"

class TrafficLight {
public:
    enum class State {
        ALL_RED = 0,
        A_GREEN = 1,
        B_GREEN = 2,
        C_GREEN = 3,
        D_GREEN = 4
    };

    TrafficLight();
    ~TrafficLight();

    // Updates the traffic light state based on lane priorities
    void update(const std::vector<Lane*>& lanes);

    // Renders the traffic lights
    void render(SDL_Renderer* renderer);

    // Returns the current traffic light state
    State getCurrentState() const { return currentState; }

    // Returns the next traffic light state
    State getNextState() const { return nextState; }

    // Sets the next traffic light state
    void setNextState(State state);

    // Checks if the specific lane gets green light
    bool isGreen(char lane) const;

private:
    State currentState;
    State nextState;

    // Timing for the green and red states
    const int allRedDuration = 2000; // 2 seconds for all red

    // Last state change time in milliseconds
    uint32_t lastStateChangeTime;

    // Priority mode flag
    bool isPriorityMode;

    // Track when normal mode should resume (after priority mode drops to 5 vehicles)
    bool shouldResumeNormalMode;

    // Helper drawing functions
    void drawLightForA(SDL_Renderer* renderer, bool isRed);
    void drawLightForB(SDL_Renderer* renderer, bool isRed);
    void drawLightForC(SDL_Renderer* renderer, bool isRed);
    void drawLightForD(SDL_Renderer* renderer, bool isRed);
};

#endif // TRAFFIC_LIGHT_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\core\Vehicle.h =====//

// FILE: include/core/Vehicle.h
#ifndef VEHICLE_H
#define VEHICLE_H

#include <string>
#include <SDL3/SDL.h>
#include <ctime>
#include <vector>

// Define all enums here instead of just forward declaring them
enum class Destination {
    STRAIGHT,
    LEFT,
    RIGHT
};

enum class Direction {
    UP,
    DOWN,
    LEFT,
    RIGHT
};

enum class VehicleState {
    APPROACHING,
    IN_INTERSECTION,
    EXITING,
    EXITED
};

// Point structure for waypoints
struct Point {
    float x;
    float y;
};

class Vehicle {
public:
    Vehicle(const std::string& id, char lane, int laneNumber, bool isEmergency = false);
    ~Vehicle();

    // Getters and setters
    std::string getId() const;
    char getLane() const;
    void setLane(char lane);
    int getLaneNumber() const;
    void setLaneNumber(int number);
    bool isEmergencyVehicle() const;
    time_t getArrivalTime() const;

    // Animation related
    float getAnimationPos() const;
    void setAnimationPos(float pos);
    bool isTurning() const;
    void setTurning(bool turning);
    float getTurnProgress() const;
    void setTurnProgress(float progress);
    float getTurnPosX() const;
    void setTurnPosX(float x);
    float getTurnPosY() const;
    void setTurnPosY(float y);

    // Update vehicle position
    void update(uint32_t delta, bool isGreenLight, float targetPos);

    // Render vehicle
    void render(SDL_Renderer* renderer, SDL_Texture* vehicleTexture, int queuePos);

    // Calculate turn path
    void calculateTurnPath(float startX, float startY, float controlX, float controlY,
                          float endX, float endY, float progress);

    // Initialize waypoints for movement path
    void initializeWaypoints();

    // Check if vehicle has exited the screen
    bool hasExited() const { return state == VehicleState::EXITED; }

private:
    std::string id;
    char lane;
    int laneNumber;
    bool isEmergency;
    time_t arrivalTime;

    // Animation properties
    float animPos;
    bool turning;
    float turnProgress;
    float turnPosX;
    float turnPosY;

    // Destination (where the vehicle is heading)
    Destination destination;

    // Current direction of travel
    Direction currentDirection;

    // Vehicle state
    VehicleState state;

    // Waypoints for movement
    std::vector<Point> waypoints;
    size_t currentWaypoint;

    // Helper methods
    float easeInOutQuad(float t) const;

    // Helper for drawing triangles (SDL3 compatible)
    void SDL_RenderFillTriangleF(SDL_Renderer* renderer, float x1, float y1, float x2, float y2, float x3, float y3);
};

#endif // VEHICLE_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\managers\FileHandler.h =====//

// FILE: include/managers/FileHandler.h
#ifndef FILE_HANDLER_H
#define FILE_HANDLER_H

#include <string>
#include <vector>
#include <mutex>
#include "core/Vehicle.h"

class FileHandler {
public:
    FileHandler(const std::string& dataPath = "data/lanes");
    ~FileHandler();

    // Read vehicles from lane files
    std::vector<Vehicle*> readVehiclesFromFiles();

    // Write lane status to file (for debugging/monitoring)
    void writeLaneStatus(char laneId, int laneNumber, int vehicleCount, bool isPriority);

    // Check if files exist/are readable
    bool checkFilesExist();

    // Create directories and empty files if they don't exist
    bool initializeFiles();

private:
    std::string dataPath;
    std::mutex mutex;

    // Lane file paths
    std::string getLaneFilePath(char laneId) const;

    // Read vehicles from a specific lane file
    std::vector<Vehicle*> readVehiclesFromFile(char laneId);

    // Parse a vehicle line from the file
    Vehicle* parseVehicleLine(const std::string& line);

    // Get the lane status file path
    std::string getLaneStatusFilePath() const;
};

#endif // FILE_HANDLER_Hendif // FILE_HANDLER_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\managers\TrafficManager.h =====//

// FILE: include/managers/TrafficManager.h
#ifndef TRAFFIC_MANAGER_H
#define TRAFFIC_MANAGER_H

#include <vector>
#include <map>
#include <atomic>
#include <memory>
#include <string>
#include <SDL3/SDL.h>

#include "core/Lane.h"
#include "core/TrafficLight.h"
#include "managers/FileHandler.h"
#include "utils/PriorityQueue.h"

class TrafficManager {
public:
    TrafficManager();
    ~TrafficManager();

    // Initialize the manager
    bool initialize();

    // Start the manager
    void start();

    // Stop the manager
    void stop();

    // Update the traffic state
    void update(uint32_t delta);

    // Get the lanes for rendering
    const std::vector<Lane*>& getLanes() const;

    // Get the traffic light
    TrafficLight* getTrafficLight() const;

    // Check if a lane is being prioritized
    bool isLanePrioritized(char laneId, int laneNumber) const;

    // Get the priority lane
    Lane* getPriorityLane() const;

    // Get statistics for display
    std::string getStatistics() const;

    // Find lane by ID and number
    Lane* findLane(char laneId, int laneNumber) const;

private:
    // Lanes for each road
    std::vector<Lane*> lanes;

    // Priority queue for lane management
    PriorityQueue<Lane*> lanePriorityQueue;

    // Traffic light
    TrafficLight* trafficLight;

    // File handler for reading vehicle data
    FileHandler* fileHandler;

    // Flag to indicate if the manager is running
    std::atomic<bool> running;

    // Time tracking for periodic operations
    uint32_t lastFileCheckTime;
    uint32_t lastPriorityUpdateTime;

    // Read vehicles from files
    void readVehicles();

    // Update lane priorities
    void updatePriorities();

    // Add a vehicle to the appropriate lane
    void addVehicle(Vehicle* vehicle);

    // Process vehicles in lanes
    void processVehicles(uint32_t delta);

    // Check for vehicles leaving the simulation
    void checkVehicleBoundaries();
};

#endif // TRAFFIC_MANAGER_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\utils\DebugLogger.h =====//

#ifndef DEBUG_LOGGER_H
#define DEBUG_LOGGER_H

#include <string>
#include <vector>
#include <mutex>

class DebugLogger {
public:
    // Log levels
    enum class LogLevel {
        INFO,
        WARNING,
        ERROR,
        DEBUG
    };

    // Initialize the logger
    static void initialize(const std::string& logFilePath = "traffic_simulator.log");

    // Log a message with a specific level
    static void log(const std::string& message, LogLevel level = LogLevel::INFO);

    // Get recent log messages for display
    static std::vector<std::string> getRecentLogs(int count = 10);

    // Clear all logs
    static void clearLogs();

    // Shutdown the logger
    static void shutdown();

private:
    static std::string logFilePath;
    static std::vector<std::string> recentLogs;
    static std::mutex logMutex;
    static bool initialized;

    // Get timestamp for log messages
    static std::string getTimestamp();

    // Write to log file
    static void writeToFile(const std::string& message);
};

#endif // DEBUG_LOGGER_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\utils\PriorityQueue.h =====//

// FILE: include/utils/PriorityQueue.h
#ifndef PRIORITY_QUEUE_H
#define PRIORITY_QUEUE_H

#include <vector>
#include <algorithm>
#include <functional>
#include <mutex>

// A priority queue implementation for the traffic simulation
template<typename T>
class PriorityQueue {
public:
    // Element with priority
    struct PriorityElement {
        T element;
        int priority;

        // Constructor
        PriorityElement(const T& e, int p) : element(e), priority(p) {}

        // Comparison operator for std::sort
        bool operator<(const PriorityElement& other) const {
            return priority < other.priority;
        }

        bool operator>(const PriorityElement& other) const {
            return priority > other.priority;
        }
    };

    PriorityQueue() = default;
    ~PriorityQueue() = default;

    // Add element with priority
    void enqueue(const T& element, int priority) {
        std::lock_guard<std::mutex> lock(mutex);

        // Add element with priority
        elements.push_back(PriorityElement(element, priority));

        // Sort in descending order (higher priority first)
        std::sort(elements.begin(), elements.end(), std::greater<PriorityElement>());
    }

    // Get the highest priority element
    T dequeue() {
        std::lock_guard<std::mutex> lock(mutex);

        if (elements.empty()) {
            throw std::runtime_error("PriorityQueue is empty");
        }

        // Get the highest priority element
        T element = elements.front().element;
        elements.erase(elements.begin());

        return element;
    }

    // Peek at the highest priority element without removing it
    T peek() const {
        std::lock_guard<std::mutex> lock(mutex);

        if (elements.empty()) {
            throw std::runtime_error("PriorityQueue is empty");
        }

        return elements.front().element;
    }

    // Update the priority of an element if it exists
    bool updatePriority(const T& element, int newPriority, std::function<bool(const T&, const T&)> comparator) {
        std::lock_guard<std::mutex> lock(mutex);

        // Find the element
        auto it = std::find_if(elements.begin(), elements.end(),
                             [&](const PriorityElement& pe) {
                                 return comparator(pe.element, element);
                             });

        if (it != elements.end()) {
            // Update the priority
            it->priority = newPriority;

            // Re-sort the elements
            std::sort(elements.begin(), elements.end(), std::greater<PriorityElement>());

            return true;
        }

        return false;
    }

    // Check if the queue is empty
    bool isEmpty() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements.empty();
    }

    // Get the size of the queue
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements.size();
    }

    // Clear the queue
    void clear() {
        std::lock_guard<std::mutex> lock(mutex);
        elements.clear();
    }

    // Get all elements in priority order
    std::vector<T> getAllElements() const {
        std::lock_guard<std::mutex> lock(mutex);

        std::vector<T> result;
        result.reserve(elements.size());

        for (const auto& pe : elements) {
            result.push_back(pe.element);
        }

        return result;
    }

private:
    std::vector<PriorityElement> elements;
    mutable std::mutex mutex;
};

#endif // PRIORITY_QUEUE_Hendif // PRIORITY_QUEUE_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\utils\Queue.h =====//

// FILE: include/utils/Queue.h
#ifndef QUEUE_H
#define QUEUE_H

#include <vector>
#include <mutex>
#include <stdexcept>

// A thread-safe queue implementation for the traffic simulation
template<typename T>
class Queue {
public:
    Queue() = default;
    ~Queue() = default;

    // Add element to the queue
    void enqueue(const T& element) {
        std::lock_guard<std::mutex> lock(mutex);
        elements.push_back(element);
    }

    // Remove and return the front element
    T dequeue() {
        std::lock_guard<std::mutex> lock(mutex);

        if (elements.empty()) {
            throw std::runtime_error("Queue is empty");
        }

        T element = elements.front();
        elements.erase(elements.begin());

        return element;
    }

    // Peek at the front element without removing it
    T peek() const {
        std::lock_guard<std::mutex> lock(mutex);

        if (elements.empty()) {
            throw std::runtime_error("Queue is empty");
        }

        return elements.front();
    }

    // Check if the queue is empty
    bool isEmpty() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements.empty();
    }

    // Get the size of the queue
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements.size();
    }

    // Clear the queue
    void clear() {
        std::lock_guard<std::mutex> lock(mutex);
        elements.clear();
    }

    // Get all elements for iteration (e.g., for rendering)
    std::vector<T> getAllElements() const {
        std::lock_guard<std::mutex> lock(mutex);
        return elements;
    }

private:
    std::vector<T> elements;
    mutable std::mutex mutex;
};

#endif // QUEUE_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\visualization\DebugOverlay.h =====//

#ifndef DEBUG_OVERLAY_H
#define DEBUG_OVERLAY_H

#include <vector>
#include <string>
#include <SDL3/SDL.h>

// Forward declarations
class TrafficManager;

class DebugOverlay {
public:
    DebugOverlay();
    ~DebugOverlay();

    // Initialize the overlay
    void initialize(TrafficManager* trafficManager);

    // Update overlay data
    void update();

    // Render the overlay
    void render(SDL_Renderer* renderer);

    // Toggle overlay visibility
    void toggleVisibility();

    // Check if overlay is visible
    bool isVisible() const;

    // Add a message to the overlay
    void addMessage(const std::string& message);

    // Clear all messages
    void clearMessages();

private:
    bool visible;
    TrafficManager* trafficManager;
    std::vector<std::string> messages;

    // Render vehicle counts for each lane
    void renderVehicleCounts(SDL_Renderer* renderer);

    // Render traffic light state
    void renderTrafficLightState(SDL_Renderer* renderer);

    // Render priority lane information
    void renderPriorityInfo(SDL_Renderer* renderer);

    // Render custom messages
    void renderMessages(SDL_Renderer* renderer);

    // Helper to render text
    void renderText(SDL_Renderer* renderer, const std::string& text, int x, int y, SDL_Color color);
};

#endif // DEBUG_OVERLAY_H


//===== END FILE: {file_path} =====//

//===== FILE: E:\Collage\comp_Assignment\include\visualization\Renderer.h =====//

// FILE: include/visualization/Renderer.h
#ifndef RENDERER_H
#define RENDERER_H

#include <SDL3/SDL.h>
#include <string>
#include <vector>
#include <memory>

class Lane;
class Vehicle;
class TrafficLight;
class TrafficManager;

class Renderer {
public:
    Renderer();
    ~Renderer();

    // Initialize renderer with window dimensions
    bool initialize(int width, int height, const std::string& title);

    // Start rendering loop
    void startRenderLoop();

    // Set traffic manager to render
    void setTrafficManager(TrafficManager* manager);

    // Render a single frame
    void renderFrame();

    // Clean up resources
    void cleanup();

    // Check if rendering is active
    bool isActive() const;

    // Toggle debug overlay
    void toggleDebugOverlay();

    // Set frame rate limiter
    void setFrameRateLimit(int fps);

private:
    // SDL components
    SDL_Window* window;
    SDL_Renderer* renderer;
    SDL_Texture* carTexture;
    SDL_Surface* surface;

    // Rendering state
    bool active;
    bool showDebugOverlay;
    int frameRateLimit;
    uint32_t lastFrameTime;

    // Window dimensions
    int windowWidth;
    int windowHeight;

    // Traffic manager
    TrafficManager* trafficManager;

    // Helper drawing functions
    void drawRoadsAndLanes();
    void drawTrafficLights();
    void drawVehicles();
    void drawDebugOverlay();
    void drawLaneLabels();
    void drawStatistics();

    // Text rendering (simplified without TTF)
    void drawText(const std::string& text, int x, int y, SDL_Color color);

    // Load textures
    bool loadTextures();

    // Process SDL events
    bool processEvents();

    // Helper to draw a filled road arrow
    void drawArrow(int x1, int y1, int x2, int y2, int x3, int y3, SDL_Color color);
};

#endif // RENDERER_Hendif // RENDERER_Hendif // RENDERER_H


//===== END FILE: {file_path} =====//

